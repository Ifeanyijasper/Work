{
  "/home/tushar/coala/CONTRIBUTING.md": [
    "# How to contribute\n",
    "\n",
    "Welcome to *coala*! The following guidelines will give you a short overview\n",
    "over how we handle issues and PRs in this repository. *coala* is maintained\n",
    "by a growing community and newcomers are always welcome!\n",
    "\n",
    "We appreciate all valuable contributions - bug reports, documentation and\n",
    "design enhancements issues as well as pull Requests to make *coala* more\n",
    "convenient, functional and bug free.\n",
    "\n",
    "To begin contributing have a look at the open issues labeled with\n",
    "difficulty/newcomer -\n",
    "[newcomer issues](https://github.com/coala-analyzer/coala/issues?q=is%3Aissue+is%3Aopen+label%3Adifficulty%2Fnewcomer).\n",
    "\n",
    "Follow the instructions\n",
    "[here](http://coala.readthedocs.org/en/latest/Getting_Involved/README.html)\n",
    "and get involved to help us make a better software.\n",
    "\n",
    "## Filing Issues\n",
    "\n",
    "When filing an issue, please use this template:\n",
    "\n",
    "```\n",
    "### Overview Description\n",
    "\n",
    "# Steps to Reproduce\n",
    "\n",
    "1.\n",
    "2.\n",
    "3.\n",
    "\n",
    "# Actual Results\n",
    "\n",
    "# Expected Results\n",
    "\n",
    "# Reproducibility\n",
    "\n",
    "# Additional Information:\n",
    "\n",
    "```\n",
    "\n",
    "## PR Merge Criteria\n",
    "\n",
    "For a PR to be merged, the following statements must hold true:\n",
    "\n",
    "- All CI services pass. (CircleCI, AppVeyor, Scrutinizer, CodeCov)\n",
    "- All commits must have been reviewed and approved by GitMate and a *coala*\n",
    "  maintainer who is not the author of the PR.\n",
    "- Commits shall comply to the commit guidelines as outlined in the docs.\n",
    "\n",
    "Commit guidelines can be found at the\n",
    "[Good Commits page](http://coala.readthedocs.org/en/latest/Getting_Involved/Writing_Good_Commits.html)\n",
    "\n",
    "## Correcting PRs\n",
    "\n",
    "Rebasing PRs is preferred over merging master into the source branches again\n",
    "and again cluttering our history. If a reviewer has suggestions, the commit\n",
    "shall be amended so the history is not cluttered by \"fixup commits\".\n",
    "\n",
    "For further information/queries feel free to discuss with us on\n",
    "[gitter](https://gitter.im/coala-analyzer/coala).\n"
  ],
  "/home/tushar/coala/README.rst": [
    ".. Start ignoring LineLengthBear\n",
    "\n",
    "::\n",
    "\n",
    "                                                         .o88Oo._\n",
    "                                                        d8P         .ooOO8bo._\n",
    "                                                        88                  '*Y8bo.\n",
    "                                          __            YA                      '*Y8b   __\n",
    "                                        ,dPYb,           YA                        68o68**8Oo.\n",
    "                                        IP'`Yb            \"8D                       *\"'    \"Y8o\n",
    "                                        I8  8I             Y8     'YB                       .8D\n",
    "                                        I8  8P             '8               d8'             8D\n",
    "                                        I8  8'              8       d8888b          d      AY\n",
    "         ,gggo,    ,ggggo,    ,gggo,gg  I8 dP    ,gggo,gg   Y,     d888888         d'  _.oP\"\n",
    "        dP\"  \"Yb  dP\"  \"Y8go*8P\"  \"Y8I  I8dP    dP\"  \"Y8I    q.    Y8888P'        d8\n",
    "       i8'       i8'    ,8P i8'    ,8I  I8P    i8'    ,8I     \"q.  `Y88P'       d8\"\n",
    "      ,d8,_    _,d8,   ,d8' d8,   ,d8b,,d8b,_ ,d8,   ,d8b,       Y           ,o8P\n",
    "    ooP\"\"Y8888PP*\"Y8888P\"   \"Y8888P\"`Y88P'\"Y88P\"Y8888P\"`Y8            oooo888P\"\n",
    "\n",
    ".. Stop ignoring LineLengthBear\n",
    "\n",
    "Get coala to lint all your languages in your project with one tool and config!\n",
    "\n",
    "Demo (Click to View)\n",
    "--------------------\n",
    "\n",
    "|asciicast|\n",
    "\n",
    ".. |asciicast| image:: https://asciinema.org/a/42968.png\n",
    "   :target: https://asciinema.org/a/42968?autoplay=1\n",
    "   :width: 100%\n",
    "\n",
    "About\n",
    "-----\n",
    "\n",
    "*coala* is a language independent analysis toolkit. It empowers developers\n",
    "to create rules which a project's code should conform to. coala takes care\n",
    "of showing these issues to users in a friendly manner, is versatile and can be\n",
    "used in any environment. Patches to automatically fix code will be managed too.\n",
    "*coala* has a set of official bears (plugins) to provide an out-of-the-box\n",
    "analysis functionality for many popular languages in addition to some\n",
    "generically applicable algorithms.\n",
    "\n",
    "For information on the languages supported by *coala-bears*, refer to\n",
    "`this link <https://github.com/coala-analyzer/coala-bears/wiki/Supported-languages>`__.\n",
    "\n",
    "For information on the various bears supported by *coala*, refer to the link\n",
    "`here <https://github.com/coala-analyzer/coala-bears/wiki/Available-bears>`__.\n",
    "\n",
    "*coala* is written with a lower case \"c\".\n",
    "\n",
    "Read more at our `documentation <http://coala.rtfd.org/>`__.\n",
    "\n",
    "Why use coala?\n",
    "--------------\n",
    "\n",
    "- *coala* provides **built-in checking routines** (named bears in *coala*).\n",
    "- **Serves your requirement**: You can easily write your own checks (using\n",
    "  bears).\n",
    "- *coala* provides **user-friendly interfaces** like json, formatted and\n",
    "  interactive output in the CLI and *plugins for various editors* are\n",
    "  available as well.\n",
    "- **Optimal performance**: *coala* manages parallelizing the checking-routines\n",
    "  without you having to worry.\n",
    "- **Unified interface**: One tool for all programming languages.\n",
    "\n",
    "If you want to learn more about *coala*, its functionality and its usage,\n",
    "please take a look at our\n",
    "`tutorial <http://coala.rtfd.org/en/latest/Users/Tutorials/Tutorial.html>`__.\n",
    "\n",
    "Installation\n",
    "------------\n",
    "\n",
    "To install *coala* with the official set of analysis routines you can simply run\n",
    "``pip3 install coala-bears``.\n",
    "\n",
    "*coala* only, without the official bears, can be installed with\n",
    "``pip3 install coala``. If you need more information about the installation and\n",
    "dependencies, take a look at our `installation documentation\n",
    "<http://coala.rtfd.org/en/latest/Users/Install.html>`__.\n",
    "\n",
    "The latest code from master is automatically deployed to PyPI as a\n",
    "development version. Get it with ``pip3 install coala --pre``.\n",
    "\n",
    "|PyPI|\n",
    "\n",
    "Authors\n",
    "-------\n",
    "\n",
    "*coala* is maintained by a growing community. Please take a look at the\n",
    "meta information in `setup.py <setup.py>`__ for current maintainers.\n",
    "\n",
    "Project Status\n",
    "--------------\n",
    "\n",
    "|Linux Build Status| |Windows Build status|\n",
    "\n",
    "|Scrutinizer Code Quality| |codecov.io|\n",
    "\n",
    "|Documentation Status| |Gitmate|\n",
    "\n",
    "Newcomers Guide and Getting Involved\n",
    "------------------------------------\n",
    "\n",
    "If you are new and would like to contribute, read our `Getting Involved Site\n",
    "<http://coala.readthedocs.org/en/latest/Getting_Involved/README.html>`__!\n",
    "\n",
    "We appreciate any help! Feel free to message us on\n",
    "`gitter <https://gitter.im/coala-analyzer/coala>`__. If you have any\n",
    "questions we're happy to help you!\n",
    "\n",
    "\n",
    "License\n",
    "-------\n",
    "\n",
    "|AGPL|\n",
    "\n",
    "This code falls under the GNU Affero General Public License as published\n",
    "by the Free Software Foundation, either version 3 of the License, or (at\n",
    "your option) any later version.\n",
    "\n",
    "Please note that some files or content may be copied from other places.\n",
    "Most of them are GPL compatible. There is a small portion of code in the\n",
    "tests that falls under the Creative Commons license, see\n",
    "https://creativecommons.org/licenses/by-sa/3.0/deed.de for more\n",
    "information.\n",
    "\n",
    ".. |PyPI| image:: https://img.shields.io/pypi/pyversions/coala.svg\n",
    "   :target: https://pypi.python.org/pypi/coala\n",
    ".. |Linux Build Status| image:: https://img.shields.io/circleci/project/coala-analyzer/coala/master.svg?label=linux%20build\n",
    "   :target: https://circleci.com/gh/coala-analyzer/coala\n",
    ".. |Windows Build status| image:: https://img.shields.io/appveyor/ci/coala/coala/master.svg?label=windows%20build\n",
    "   :target: https://ci.appveyor.com/project/coala/coala/branch/master\n",
    ".. |Scrutinizer Code Quality| image:: https://img.shields.io/scrutinizer/g/coala-analyzer/coala.svg?label=scrutinizer%20quality\n",
    "   :target: https://scrutinizer-ci.com/g/coala-analyzer/coala/?branch=master\n",
    ".. |codecov.io| image:: https://img.shields.io/codecov/c/github/coala-analyzer/coala/master.svg?label=branch%20coverage\n",
    "   :target: https://codecov.io/github/coala-analyzer/coala?branch=master\n",
    ".. |Documentation Status| image:: https://readthedocs.org/projects/coala/badge/?version=latest\n",
    "   :target: http://coala.rtfd.org/\n",
    ".. |https://gitter.im/coala-analyzer/coala| image:: https://img.shields.io/badge/gitter-join%20chat%20%E2%86%92-brightgreen.svg\n",
    "   :target: https://gitter.im/coala-analyzer/coala\n",
    ".. |AGPL| image:: https://img.shields.io/github/license/coala-analyzer/coala.svg\n",
    "   :target: https://www.gnu.org/licenses/agpl-3.0.html\n",
    ".. |Gitmate| image:: https://img.shields.io/badge/Gitmate-0%20issues-brightgreen.svg\n",
    "   :target: http://gitmate.com/\n"
  ],
  "/home/tushar/coala/coala": [
    "#!/usr/bin/env python3\n",
    "\n",
    "# This program is free software: you can redistribute it and/or modify it\n",
    "# under the terms of the GNU Affero General Public License as published by the\n",
    "# Free Software Foundation, either version 3 of the License, or (at your\n",
    "# option) any later version.\n",
    "#\n",
    "# This program is distributed in the hope that it will be useful, but WITHOUT\n",
    "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n",
    "# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License\n",
    "# for more details.\n",
    "#\n",
    "# You should have received a copy of the GNU Affero General Public License\n",
    "# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n",
    "\n",
    "import sys\n",
    "\n",
    "# Start ignoring PyImportSortBear, we need to assert the version before\n",
    "# importing things that could cause an ImportError\n",
    "from coalib import assert_supported_version\n",
    "\n",
    "assert_supported_version()\n",
    "# Stop ignoring\n",
    "\n",
    "from coalib.coala import main\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    sys.exit(main())\n"
  ],
  "/home/tushar/coala/coalib/__init__.py": [
    "import sys\n",
    "from os.path import join, dirname\n",
    "\n",
    "\n",
    "VERSION_FILE = join(dirname(__file__), \"VERSION\")\n",
    "\n",
    "\n",
    "def get_version():\n",
    "    with open(VERSION_FILE, 'r') as ver:\n",
    "        return ver.readline().strip()\n",
    "\n",
    "\n",
    "VERSION = get_version()\n",
    "__version__ = VERSION\n",
    "\n",
    "# Needed by setup.py and thus cannot live in Constants as it contains the\n",
    "# appdirs import that will break setup if appdirs isn't available yet.\n",
    "BUS_NAME = \"org.coala_analyzer.v1\"\n",
    "\n",
    "\n",
    "def assert_supported_version():  # pragma: no cover\n",
    "    if not sys.version_info > (3, 2):\n",
    "        print(\"coala supports only python 3.3 or later.\")\n",
    "        exit(4)\n"
  ],
  "/home/tushar/coala/coalib/bearlib/__init__.py": [
    "\"\"\"\n",
    "The bearlib is an optional library designed to ease the task of any Bear. Just\n",
    "as the rest of coala the bearlib is designed to be as easy to use as possible\n",
    "while offering the best possible flexibility.\n",
    "\"\"\"\n"
  ],
  "/home/tushar/coala/coalib/bearlib/abstractions/Lint.py": [
    "import os\n",
    "import re\n",
    "import shlex\n",
    "import shutil\n",
    "from coalib.parsing.StringProcessing import escape\n",
    "from subprocess import check_call, CalledProcessError, DEVNULL\n",
    "import tempfile\n",
    "\n",
    "from coalib.bears.Bear import Bear\n",
    "from coala_decorators.decorators import enforce_signature\n",
    "from coalib.misc.Shell import run_shell_command, get_shell_type\n",
    "from coalib.results.Diff import Diff\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.RESULT_SEVERITY import RESULT_SEVERITY\n",
    "\n",
    "\n",
    "def escape_path_argument(path, shell=get_shell_type()):\n",
    "    \"\"\"\n",
    "    Makes a raw path ready for using as parameter in a shell command (escapes\n",
    "    illegal characters, surrounds with quotes etc.).\n",
    "\n",
    "    :param path:  The path to make ready for shell.\n",
    "    :param shell: The shell platform to escape the path argument for. Possible\n",
    "                  values are \"sh\", \"powershell\", and \"cmd\" (others will be ignored and return the \n",
    "                  given path without modification).\n",
    "    :return:      The escaped path argument.\n",
    "    \"\"\"\n",
    "    if shell == \"cmd\":\n",
    "        # If a quote (\") occurs in path (which is illegal for NTFS file\n",
    "        # systems, but maybe for others), escape it by preceding it with\n",
    "        # a caret (^).\n",
    "        return '\"' + escape(path, '\"', '^') + '\"'\n",
    "    elif shell == \"sh\":\n",
    "        return shlex.quote(path)\n",
    "    else:\n",
    "        # Any other non-supported system doesn't get a path escape.\n",
    "        return path\n",
    "\n",
    "\n",
    "class Lint(Bear):\n",
    "\n",
    "    \"\"\"\n",
    "    Deals with the creation of linting bears.\n",
    "\n",
    "    For the tutorial see:\n",
    "    http://coala.readthedocs.org/en/latest/Users/Tutorials/Linter_Bears.html\n",
    "\n",
    "    :param executable:                  The executable to run the linter.\n",
    "    :param prerequisite_command:        The command to run as a prerequisite\n",
    "                                        and is of type ``list``.\n",
    "    :param prerequisites_fail_msg:      The message to be displayed if the\n",
    "                                        prerequisite fails.\n",
    "    :param arguments:                   The arguments to supply to the linter,\n",
    "                                        such that the file name to be analyzed\n",
    "                                        can be appended to the end. Note that\n",
    "                                        we use ``.format()`` on the arguments -\n",
    "                                        so, ``{abc}`` needs to be given as\n",
    "                                        ``{{abc}}``. Currently, the following\n",
    "                                        will be replaced:\n",
    "\n",
    "                                         - ``{filename}`` - The filename passed\n",
    "                                           to ``lint()``\n",
    "                                         - ``{config_file}`` - The config file\n",
    "                                           created using ``config_file()``\n",
    "\n",
    "    :param output_regex:    The regex which will match the output of the linter\n",
    "                            to get results. This is not used if\n",
    "                            ``gives_corrected`` is set. This regex should give\n",
    "                            out the following variables:\n",
    "\n",
    "                             - line - The line where the issue starts.\n",
    "                             - column - The column where the issue starts.\n",
    "                             - end_line - The line where the issue ends.\n",
    "                             - end_column - The column where the issue ends.\n",
    "                             - severity - The severity of the issue.\n",
    "                             - message - The message of the result.\n",
    "                             - origin - The origin of the issue.\n",
    "\n",
    "    :param diff_severity:   The severity to use for all results if\n",
    "                            ``gives_corrected`` is set.\n",
    "    :param diff_message:    The message to use for all results if\n",
    "                            ``gives_corrected`` is set.\n",
    "    :param use_stderr:      Uses stderr as the output stream is it's True.\n",
    "    :param use_stdin:       Sends file as stdin instead of giving the file name.\n",
    "    :param gives_corrected: True if the executable gives the corrected file\n",
    "                            or just the issues.\n",
    "    :param severity_map:    A dict where the keys are the possible severity\n",
    "                            values the Linter gives out and the values are the\n",
    "                            severity of the coala Result to set it to. If it is\n",
    "                            not a dict, it is ignored.\n",
    "    \"\"\"\n",
    "    executable = None\n",
    "    prerequisite_command = None\n",
    "    prerequisite_fail_msg = 'Unknown failure.'\n",
    "    arguments = \"\"\n",
    "    output_regex = re.compile(r'(?P<line>\\d+)\\.(?P<column>\\d+)\\|'\n",
    "                              r'(?P<severity>\\d+): (?P<message>.*)')\n",
    "    diff_message='No result message was set'\n",
    "    diff_severity = RESULT_SEVERITY.NORMAL\n",
    "    use_stderr = False\n",
    "    use_stdin = False\n",
    "    gives_corrected = False\n",
    "    severity_map = None\n",
    "\n",
    "    def lint(self, filename=None, file=None):\n",
    "        \"\"\"\n",
    "        Takes a file and lints it using the linter variables defined apriori.\n",
    "\n",
    "        :param filename:  The name of the file to execute.\n",
    "        :param file:      The contents of the file as a list of strings.\n",
    "        \"\"\"\n",
    "        assert ((self.use_stdin and file is not None) or\n",
    "                (not self.use_stdin and filename is not None))\n",
    "\n",
    "        config_file = self.generate_config_file()\n",
    "        self.command = self._create_command(filename=filename,\n",
    "                                            config_file=config_file)\n",
    "\n",
    "        stdin_input = \"\".join(file) if self.use_stdin else None\n",
    "        stdout_output, stderr_output = run_shell_command(self.command,\n",
    "                                                         stdin=stdin_input,\n",
    "                                                         shell=True)\n",
    "        self.stdout_output = tuple(stdout_output.splitlines(keepends=True))\n",
    "        self.stderr_output = tuple(stderr_output.splitlines(keepends=True))\n",
    "        results_output = (self.stderr_output if self.use_stderr\n",
    "                          else self.stdout_output)\n",
    "        results = self.process_output(results_output, filename, file)\n",
    "        if not self.use_stderr:\n",
    "            self._print_errors(self.stderr_output)\n",
    "\n",
    "        if config_file:\n",
    "            os.remove(config_file)\n",
    "\n",
    "        return results\n",
    "\n",
    "    def process_output(self, output, filename, file):\n",
    "        \"\"\"\n",
    "        Take the output (from stdout or stderr) and use it to create Results.\n",
    "        If the class variable ``gives_corrected`` is set to True, the\n",
    "        ``_process_corrected()`` is called. If it is False,\n",
    "        ``_process_issues()`` is called.\n",
    "\n",
    "        :param output:   The output to be used to obtain Results from. The\n",
    "                         output is either stdout or stderr depending on the\n",
    "                         class variable ``use_stderr``.\n",
    "        :param filename: The name of the file whose output is being processed.\n",
    "        :param file:     The contents of the file whose output is being\n",
    "                         processed.\n",
    "        :return:         Generator which gives Results produced based on this\n",
    "                         output.\n",
    "        \"\"\"\n",
    "        if self.gives_corrected:\n",
    "            return self._process_corrected(output, filename, file)\n",
    "        else:\n",
    "            return self._process_issues(output, filename)\n",
    "\n",
    "    def _process_corrected(self, output, filename, file):\n",
    "        \"\"\"\n",
    "        Process the output and use it to create Results by creating diffs.\n",
    "        The diffs are created by comparing the output and the original file.\n",
    "\n",
    "        :param output:   The corrected file contents.\n",
    "        :param filename: The name of the file.\n",
    "        :param file:     The original contents of the file.\n",
    "        :return:         Generator which gives Results produced based on the\n",
    "                         diffs created by comparing the original and corrected\n",
    "                         contents.\n",
    "        \"\"\"\n",
    "        for diff in self.__yield_diffs(file, output):\n",
    "            yield Result(self,\n",
    "                         self.diff_message,\n",
    "                         affected_code=(diff.range(filename),),\n",
    "                         diffs={filename: diff},\n",
    "                         severity=self.diff_severity)\n",
    "\n",
    "    def _process_issues(self, output, filename):\n",
    "        \"\"\"\n",
    "        Process the output using the regex provided in ``output_regex`` and\n",
    "        use it to create Results by using named captured groups from the regex.\n",
    "\n",
    "        :param output:   The output to be parsed by regex.\n",
    "        :param filename: The name of the file.\n",
    "        :param file:     The original contents of the file.\n",
    "        :return:         Generator which gives Results produced based on regex\n",
    "                         matches using the ``output_regex`` provided and the\n",
    "                         ``output`` parameter.\n",
    "        \"\"\"\n",
    "        regex = self.output_regex\n",
    "        if isinstance(regex, str):\n",
    "            regex = regex % {\"file_name\": filename}\n",
    "\n",
    "        # Note: We join ``output`` because the regex may want to capture\n",
    "        #       multiple lines also.\n",
    "        for match in re.finditer(regex, \"\".join(output)):\n",
    "            yield self.match_to_result(match, filename)\n",
    "\n",
    "    def _get_groupdict(self, match):\n",
    "        \"\"\"\n",
    "        Convert a regex match's groups into a dictionary with data to be used\n",
    "        to create a Result. This is used internally in ``match_to_result``.\n",
    "\n",
    "        :param match:    The match got from regex parsing.\n",
    "        :param filename: The name of the file from which this match is got.\n",
    "        :return:         The dictionary containing the information:\n",
    "                         - line - The line where the result starts.\n",
    "                         - column - The column where the result starts.\n",
    "                         - end_line - The line where the result ends.\n",
    "                         - end_column - The column where the result ends.\n",
    "                         - severity - The severity of the result.\n",
    "                         - message - The message of the result.\n",
    "                         - origin - The origin of the result.\n",
    "        \"\"\"\n",
    "        groups = match.groupdict()\n",
    "        if (\n",
    "                isinstance(self.severity_map, dict) and\n",
    "                \"severity\" in groups and\n",
    "                groups[\"severity\"] in self.severity_map):\n",
    "            groups[\"severity\"] = self.severity_map[groups[\"severity\"]]\n",
    "        return groups\n",
    "\n",
    "    def _create_command(self, **kwargs):\n",
    "        command = self.executable + ' ' + self.arguments\n",
    "        for key in (\"filename\", \"config_file\"):\n",
    "            kwargs[key] = escape_path_argument(kwargs.get(key, \"\") or \"\")\n",
    "        return command.format(**kwargs)\n",
    "\n",
    "    def _print_errors(self, errors):\n",
    "        for line in filter(lambda error: bool(error.strip()), errors):\n",
    "            self.warn(line)\n",
    "\n",
    "    @staticmethod\n",
    "    def __yield_diffs(file, new_file):\n",
    "        if tuple(new_file) != tuple(file):\n",
    "            wholediff = Diff.from_string_arrays(file, new_file)\n",
    "\n",
    "            for diff in wholediff.split_diff():\n",
    "                yield diff\n",
    "\n",
    "    def match_to_result(self, match, filename):\n",
    "        \"\"\"\n",
    "        Convert a regex match's groups into a coala Result object.\n",
    "\n",
    "        :param match:    The match got from regex parsing.\n",
    "        :param filename: The name of the file from which this match is got.\n",
    "        :return:         The Result object.\n",
    "        \"\"\"\n",
    "        groups = self._get_groupdict(match)\n",
    "\n",
    "        # Pre process the groups\n",
    "        for variable in (\"line\", \"column\", \"end_line\", \"end_column\"):\n",
    "            if variable in groups and groups[variable]:\n",
    "                groups[variable] = int(groups[variable])\n",
    "\n",
    "        if \"origin\" in groups:\n",
    "            groups['origin'] = \"{} ({})\".format(str(self.name),\n",
    "                                                str(groups[\"origin\"]))\n",
    "\n",
    "        return Result.from_values(\n",
    "            origin=groups.get(\"origin\", self),\n",
    "            message=groups.get(\"message\", \"\"),\n",
    "            file=filename,\n",
    "            severity=int(groups.get(\"severity\", RESULT_SEVERITY.NORMAL)),\n",
    "            line=groups.get(\"line\", None),\n",
    "            column=groups.get(\"column\", None),\n",
    "            end_line=groups.get(\"end_line\", None),\n",
    "            end_column=groups.get(\"end_column\", None))\n",
    "\n",
    "    @classmethod\n",
    "    def check_prerequisites(cls):\n",
    "        \"\"\"\n",
    "        Checks for prerequisites required by the Linter Bear.\n",
    "\n",
    "        It uses the class variables:\n",
    "        -  ``executable`` - Checks that it is available in the PATH using\n",
    "        ``shutil.which``.\n",
    "        -  ``prerequisite_command`` - Checks that when this command is run,\n",
    "        the exitcode is 0. If it is not zero, ``prerequisite_fail_msg``\n",
    "        is gives as the failure message.\n",
    "\n",
    "        If either of them is set to ``None`` that check is ignored.\n",
    "\n",
    "        :return: True is all checks are valid, else False.\n",
    "        \"\"\"\n",
    "        return cls._check_executable_command(\n",
    "            executable=cls.executable,\n",
    "            command=cls.prerequisite_command,\n",
    "            fail_msg=cls.prerequisite_fail_msg)\n",
    "\n",
    "    @classmethod\n",
    "    @enforce_signature\n",
    "    def _check_executable_command(cls, executable,\n",
    "                                  command: (list, tuple, None), fail_msg):\n",
    "        \"\"\"\n",
    "        Checks whether the required executable is found and the\n",
    "        required command succesfully executes.\n",
    "\n",
    "        The function is intended be used with classes having an\n",
    "        executable, prerequisite_command and prerequisite_fail_msg.\n",
    "\n",
    "        :param executable:   The executable to check for.\n",
    "        :param command:      The command to check as a prerequisite.\n",
    "        :param fail_msg:     The fail message to display when the\n",
    "                             command doesn't return an exitcode of zero.\n",
    "\n",
    "        :return: True if command successfully executes, or is not required.\n",
    "                 not True otherwise, with a string containing a\n",
    "                 detailed description of the error.\n",
    "        \"\"\"\n",
    "        if cls._check_executable(executable):\n",
    "            if command is None:\n",
    "                return True  # when there are no prerequisites\n",
    "            try:\n",
    "                check_call(command, stdout=DEVNULL, stderr=DEVNULL)\n",
    "                return True\n",
    "            except (OSError, CalledProcessError):\n",
    "                return fail_msg\n",
    "        else:\n",
    "            return repr(executable) + \" is not installed.\"\n",
    "\n",
    "    @staticmethod\n",
    "    def _check_executable(executable):\n",
    "        \"\"\"\n",
    "        Checks whether the needed executable is present in the system.\n",
    "\n",
    "        :param executable: The executable to check for.\n",
    "\n",
    "        :return: True if binary is present, or is not required.\n",
    "                 not True otherwise, with a string containing a\n",
    "                 detailed description of what's missing.\n",
    "        \"\"\"\n",
    "        if executable is None:\n",
    "            return True\n",
    "        return shutil.which(executable) is not None\n",
    "\n",
    "    def generate_config_file(self):\n",
    "        \"\"\"\n",
    "        Generates a temporary config file.\n",
    "        Note: The user of the function is responsible for deleting the\n",
    "        tempfile when done with it.\n",
    "\n",
    "        :return: The file name of the tempfile created.\n",
    "        \"\"\"\n",
    "        config_lines = self.config_file()\n",
    "        config_file = \"\"\n",
    "        if config_lines is not None:\n",
    "            for i, line in enumerate(config_lines):\n",
    "                config_lines[i] = line if line.endswith(\"\\n\") else line + \"\\n\"\n",
    "            config_fd, config_file = tempfile.mkstemp()\n",
    "            os.close(config_fd)\n",
    "            with open(config_file, 'w') as conf_file:\n",
    "                conf_file.writelines(config_lines)\n",
    "        return config_file\n",
    "\n",
    "    @staticmethod\n",
    "    def config_file():\n",
    "        \"\"\"\n",
    "        Returns a configuation file from the section given to the bear.\n",
    "        The section is available in ``self.section``. To add the config\n",
    "        file's name generated by this function to the arguments,\n",
    "        use ``{config_file}``.\n",
    "\n",
    "        :return: A list of lines of the config file to be used or None.\n",
    "        \"\"\"\n",
    "        return None\n"
  ],
  "/home/tushar/coala/coalib/bearlib/abstractions/Linter.py": [
    "from contextlib import contextmanager\n",
    "from functools import partial\n",
    "import inspect\n",
    "from itertools import chain, compress\n",
    "import re\n",
    "import shutil\n",
    "from subprocess import check_call, CalledProcessError, DEVNULL\n",
    "from types import MappingProxyType\n",
    "\n",
    "from coalib.bears.LocalBear import LocalBear\n",
    "from coalib.misc.ContextManagers import make_temp\n",
    "from coala_decorators.decorators import assert_right_type, enforce_signature\n",
    "from coalib.misc.Future import partialmethod\n",
    "from coalib.misc.Shell import run_shell_command\n",
    "from coalib.results.Diff import Diff\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.RESULT_SEVERITY import RESULT_SEVERITY\n",
    "from coalib.settings.FunctionMetadata import FunctionMetadata\n",
    "import random\n",
    "\n",
    "def _prepare_options(options):\n",
    "    \"\"\"\n",
    "    Prepares options for ``linter`` for a given options dict in-place.\n",
    "\n",
    "    :param options:\n",
    "        The options dict that contains user/developer inputs.\n",
    "    \"\"\"\n",
    "    allowed_options = {\"executable\",\n",
    "                       \"output_format\",\n",
    "                       \"use_stdin\",\n",
    "                       \"use_stdout\",\n",
    "                       \"use_stderr\",\n",
    "                       \"config_suffix\",\n",
    "                       \"executable_check_fail_info\",\n",
    "                       \"prerequisite_check_command\"}\n",
    "\n",
    "    if not options[\"use_stdout\"] and not options[\"use_stderr\"]:\n",
    "        raise ValueError(\"No output streams provided at all.\")\n",
    "\n",
    "    if options[\"output_format\"] == \"corrected\":\n",
    "        if (\n",
    "                \"diff_severity\" in options and\n",
    "                options[\"diff_severity\"] not in RESULT_SEVERITY.reverse):\n",
    "            raise TypeError(\"Invalid value for `diff_severity`: \" +\n",
    "                            repr(options[\"diff_severity\"]))\n",
    "\n",
    "        if \"result_message\" in options:\n",
    "            assert_right_type(options[\"result_message\"], str, \"result_message\")\n",
    "\n",
    "        if \"diff_distance\" in options:\n",
    "            assert_right_type(options[\"diff_distance\"], int, \"diff_distance\")\n",
    "\n",
    "        allowed_options |= {\"diff_severity\", \"result_message\", \"diff_distance\"}\n",
    "    elif options[\"output_format\"] == \"regex\":\n",
    "        if \"output_regex\" not in options:\n",
    "            raise ValueError(\"`output_regex` needed when specified \"\n",
    "                             \"output-format 'regex'.\")\n",
    "\n",
    "        options[\"output_regex\"] = re.compile(options[\"output_regex\"])\n",
    "\n",
    "        # Don't setup severity_map if one is provided by user or if it's not\n",
    "        # used inside the output_regex. If one is manually provided but not\n",
    "        # used in the output_regex, throw an exception.\n",
    "        if \"severity_map\" in options:\n",
    "            if \"severity\" not in options[\"output_regex\"].groupindex:\n",
    "                raise ValueError(\"Provided `severity_map` but named group `severity` is not used in `output_regex`.\")\n",
    "            assert_right_type(options[\"severity_map\"], dict, \"severity_map\")\n",
    "\n",
    "            for key, value in options[\"severity_map\"].items():\n",
    "                assert_right_type(key, str, \"severity_map key\")\n",
    "\n",
    "                try:\n",
    "                    assert_right_type(value, int, \"<severity_map dict-value>\")\n",
    "                except TypeError:\n",
    "                    raise TypeError(\n",
    "                        \"The value {!r} for key {!r} inside given \"\n",
    "                        \"severity-map is no valid severity value.\".format(\n",
    "                            value, key))\n",
    "\n",
    "                if value not in RESULT_SEVERITY.reverse:\n",
    "                    raise TypeError(\n",
    "                        \"Invalid severity value {!r} for key {!r} inside \"\n",
    "                        \"given severity-map.\".format(value, key))\n",
    "\n",
    "            # Auto-convert keys to lower-case. This creates automatically a new\n",
    "            # dict which prevents runtime-modifications.\n",
    "            options[\"severity_map\"] = {\n",
    "                key.lower(): value\n",
    "                for key, value in options[\"severity_map\"].items()}\n",
    "\n",
    "        if \"result_message\" in options:\n",
    "            assert_right_type(options[\"result_message\"], str, \"result_message\")\n",
    "\n",
    "        allowed_options |= {\"output_regex\", \"severity_map\", \"result_message\"}\n",
    "    elif options[\"output_format\"] is not None:\n",
    "        raise ValueError(\"Invalid `output_format` specified.\")\n",
    "\n",
    "    if options[\"prerequisite_check_command\"]:\n",
    "        if \"prerequisite_check_fail_message\" in options:\n",
    "            assert_right_type(options[\"prerequisite_check_fail_message\"],\n",
    "                              str,\n",
    "                              \"prerequisite_check_fail_message\")\n",
    "        else:\n",
    "            options[\"prerequisite_check_fail_message\"] = (\n",
    "                \"Prerequisite check failed.\")\n",
    "\n",
    "        allowed_options.add(\"prerequisite_check_fail_message\")\n",
    "\n",
    "    # Check for illegal superfluous options.\n",
    "    superfluous_options = options.keys() - allowed_options\n",
    "    if superfluous_options:\n",
    "        raise ValueError(\n",
    "            \"Invalid keyword arguments provided: \" +\n",
    "            \", \".join(repr(s) for s in sorted(superfluous_options)))\n",
    "\n",
    "\n",
    "def _create_linter(klass, options):\n",
    "    class LinterMeta(type):\n",
    "\n",
    "        def __repr__(cls):\n",
    "            return \"<{} linter class (wrapping {!r})>\".format(\n",
    "                cls.__name__, options[\"executable\"])\n",
    "\n",
    "    class LinterBase(LocalBear, metaclass=LinterMeta):\n",
    "\n",
    "        @staticmethod\n",
    "        def generate_config(filename, file):\n",
    "            \"\"\"\n",
    "            Generates the content of a config-file the linter-tool might need.\n",
    "\n",
    "            The contents generated from this function are written to a\n",
    "            temporary file and the path is provided inside\n",
    "            ``create_arguments()``.\n",
    "\n",
    "            By default no configuration is generated.\n",
    "\n",
    "            You can provide additional keyword arguments and defaults. These\n",
    "            will be interpreted as required settings that need to be provided\n",
    "            through a coafile-section.\n",
    "\n",
    "            :param filename:\n",
    "                The name of the file currently processed.\n",
    "            :param file:\n",
    "                The contents of the file currently processed.\n",
    "            :return:\n",
    "                The config-file-contents as a string or ``None``.\n",
    "            \"\"\"\n",
    "            return None\n",
    "\n",
    "        @staticmethod\n",
    "        def create_arguments(filename, file, config_file):\n",
    "            \"\"\"\n",
    "            Creates the arguments for the linter.\n",
    "\n",
    "            You can provide additional keyword arguments and defaults. These\n",
    "            will be interpreted as required settings that need to be provided\n",
    "            through a coafile-section.\n",
    "\n",
    "            :param filename:\n",
    "                The name of the file the linter-tool shall process.\n",
    "            :param file:\n",
    "                The contents of the file.\n",
    "            :param config_file:\n",
    "                The path of the config-file if used. ``None`` if unused.\n",
    "            :return:\n",
    "                A sequence of arguments to feed the linter-tool with.\n",
    "            \"\"\"\n",
    "            raise NotImplementedError\n",
    "\n",
    "        @staticmethod\n",
    "        def get_executable():\n",
    "            \"\"\"\n",
    "            Returns the executable of this class.\n",
    "\n",
    "            :return:\n",
    "                The executable name.\n",
    "            \"\"\"\n",
    "            return options[\"executable\"]\n",
    "\n",
    "        @classmethod\n",
    "        def check_prerequisites(cls):\n",
    "            \"\"\"\n",
    "            Checks whether the linter-tool the bear uses is operational.\n",
    "\n",
    "            :return:\n",
    "                True if operational, otherwise a string containing more info.\n",
    "            \"\"\"\n",
    "            if shutil.which(cls.get_executable()) is None:\n",
    "                return (repr(cls.get_executable()) + \" is not installed.\" +\n",
    "                        (\" \" + options[\"executable_check_fail_info\"]\n",
    "                         if options[\"executable_check_fail_info\"] else\n",
    "                         \"\"))\n",
    "            else:\n",
    "                if options[\"prerequisite_check_command\"]:\n",
    "                    try:\n",
    "                        check_call(options[\"prerequisite_check_command\"],\n",
    "                                   stdout=DEVNULL,\n",
    "                                   stderr=DEVNULL)\n",
    "                        return True\n",
    "                    except (OSError, CalledProcessError):\n",
    "                        return options[\"prerequisite_check_fail_message\"]\n",
    "                return True\n",
    "\n",
    "        @classmethod\n",
    "        def _get_create_arguments_metadata(cls):\n",
    "            return FunctionMetadata.from_function(\n",
    "                cls.create_arguments,\n",
    "                omit={\"self\", \"filename\", \"file\", \"config_file\"})\n",
    "\n",
    "        @classmethod\n",
    "        def _get_generate_config_metadata(cls):\n",
    "            return FunctionMetadata.from_function(\n",
    "                cls.generate_config,\n",
    "                omit={\"filename\", \"file\"})\n",
    "\n",
    "        @classmethod\n",
    "        def _get_process_output_metadata(cls):\n",
    "            metadata = FunctionMetadata.from_function(cls.process_output)\n",
    "\n",
    "            if options[\"output_format\"] is None:\n",
    "                omitted = {\"self\", \"output\", \"filename\", \"file\"}\n",
    "            else:\n",
    "                # If a specific output format is provided, function signatures\n",
    "                # from process_output functions should not appear in the help.\n",
    "                omitted = set(chain(metadata.non_optional_params,\n",
    "                                    metadata.optional_params))\n",
    "\n",
    "            metadata.omit = omitted\n",
    "            return metadata\n",
    "\n",
    "        @classmethod\n",
    "        def get_metadata(cls):\n",
    "            merged_metadata = FunctionMetadata.merge(\n",
    "                cls._get_process_output_metadata(),\n",
    "                cls._get_generate_config_metadata(),\n",
    "                cls._get_create_arguments_metadata())\n",
    "            merged_metadata.desc = (\n",
    "                \"{}\\n\\nThis bear uses the {!r} tool.\".format(\n",
    "                    inspect.getdoc(cls), cls.get_executable()))\n",
    "\n",
    "            return merged_metadata\n",
    "\n",
    "        def _convert_output_regex_match_to_result(self,\n",
    "                                                  match,\n",
    "                                                  filename,\n",
    "                                                  severity_map,\n",
    "                                                  result_message):\n",
    "            \"\"\"\n",
    "            Converts the matched named-groups of ``output_regex`` to an actual\n",
    "            ``Result``.\n",
    "\n",
    "            :param match:\n",
    "                The regex match object.\n",
    "            :param filename:\n",
    "                The name of the file this match belongs to.\n",
    "            :param severity_map:\n",
    "                The dict to use to map the severity-match to an actual\n",
    "                ``RESULT_SEVERITY``.\n",
    "            :param result_message:\n",
    "                The static message to use for results instead of grabbing it\n",
    "                from the executable output via the ``message`` named regex\n",
    "                group.\n",
    "            \"\"\"\n",
    "            # Pre process the groups\n",
    "            groups = match.groupdict()\n",
    "\n",
    "            if 'severity' in groups:\n",
    "                try:\n",
    "                    groups[\"severity\"] = severity_map[\n",
    "                        groups[\"severity\"].lower()]\n",
    "                except KeyError:\n",
    "                    self.warn(\n",
    "                        repr(groups[\"severity\"]) + \" not found in \"\n",
    "                        \"severity-map. Assuming `RESULT_SEVERITY.NORMAL`.\")\n",
    "                    groups[\"severity\"] = RESULT_SEVERITY.NORMAL\n",
    "            else:\n",
    "                groups['severity'] = RESULT_SEVERITY.NORMAL\n",
    "\n",
    "            for variable in (\"line\", \"column\", \"end_line\", \"end_column\"):\n",
    "                groups[variable] = (None\n",
    "                                    if groups.get(variable, None) is None else\n",
    "                                    int(groups[variable]))\n",
    "\n",
    "            if \"origin\" in groups:\n",
    "                groups[\"origin\"] = \"{} ({})\".format(klass.__name__,\n",
    "                                                    groups[\"origin\"].strip())\n",
    "\n",
    "            # Construct the result.\n",
    "            return Result.from_values(\n",
    "                origin=groups.get(\"origin\", self),\n",
    "                message=(groups.get(\"message\", \"\").strip()\n",
    "                         if result_message is None else result_message),\n",
    "                file=filename,\n",
    "                severity=groups[\"severity\"],\n",
    "                line=groups[\"line\"],\n",
    "                column=groups[\"column\"],\n",
    "                end_line=groups[\"end_line\"],\n",
    "                end_column=groups[\"end_column\"],\n",
    "                additional_info=groups.get(\"additional_info\", \"\").strip())\n",
    "\n",
    "        def process_output_corrected(self,\n",
    "                                     output,\n",
    "                                     filename,\n",
    "                                     file,\n",
    "                                     diff_severity=RESULT_SEVERITY.NORMAL,\n",
    "                                     result_message=\"Inconsistency found.\",\n",
    "                                     diff_distance=1):\n",
    "            \"\"\"\n",
    "            Processes the executable's output as a corrected file.\n",
    "\n",
    "            :param output:\n",
    "                The output of the program. This can be either a single\n",
    "                string or a sequence of strings.\n",
    "            :param filename:\n",
    "                The filename of the file currently being corrected.\n",
    "            :param file:\n",
    "                The contents of the file currently being corrected.\n",
    "            :param diff_severity:\n",
    "                The severity to use for generating results.\n",
    "            :param result_message:\n",
    "                The message to use for generating results.\n",
    "            :param diff_distance:\n",
    "                Number of unchanged lines that are allowed in between two\n",
    "                changed lines so they get yielded as one diff. If a negative\n",
    "                distance is given, every change will be yielded as an own diff,\n",
    "                even if they are right beneath each other.\n",
    "            :return:\n",
    "                An iterator returning results containing patches for the\n",
    "                file to correct.\n",
    "            \"\"\"\n",
    "            if isinstance(output, str):\n",
    "                output = (output,)\n",
    "\n",
    "            for string in output:\n",
    "                for diff in Diff.from_string_arrays(\n",
    "                        file,\n",
    "                        string.splitlines(keepends=True)).split_diff(\n",
    "                            distance=diff_distance):\n",
    "                    yield Result(self,\n",
    "                                 result_message,\n",
    "                                 affected_code=diff.affected_code(filename),\n",
    "                                 diffs={filename: diff},\n",
    "                                 severity=diff_severity)\n",
    "\n",
    "        def process_output_regex(\n",
    "                self, output, filename, file, output_regex,\n",
    "                severity_map=MappingProxyType({\n",
    "                    \"error\": RESULT_SEVERITY.MAJOR,\n",
    "                    \"warning\": RESULT_SEVERITY.NORMAL,\n",
    "                    \"warn\": RESULT_SEVERITY.NORMAL,\n",
    "                    \"information\": RESULT_SEVERITY.INFO,\n",
    "                    \"info\": RESULT_SEVERITY.INFO}),\n",
    "                result_message=None):\n",
    "            \"\"\"\n",
    "            Processes the executable's output using a regex.\n",
    "\n",
    "            :param output:\n",
    "                The output of the program. This can be either a single\n",
    "                string or a sequence of strings.\n",
    "            :param filename:\n",
    "                The filename of the file currently being corrected.\n",
    "            :param file:\n",
    "                The contents of the file currently being corrected.\n",
    "            :param output_regex:\n",
    "                The regex to parse the output with. It should use as many\n",
    "                of the following named groups (via ``(?P<name>...)``) to\n",
    "                provide a good result:\n",
    "\n",
    "                - line - The line where the issue starts.\n",
    "                - column - The column where the issue starts.\n",
    "                - end_line - The line where the issue ends.\n",
    "                - end_column - The column where the issue ends.\n",
    "                - severity - The severity of the issue.\n",
    "                - message - The message of the result.\n",
    "                - origin - The origin of the issue.\n",
    "                - additional_info - Additional info provided by the issue.\n",
    "\n",
    "                The groups ``line``, ``column``, ``end_line`` and\n",
    "                ``end_column`` don't have to match numbers only, they can\n",
    "                also match nothing, the generated ``Result`` is filled\n",
    "                automatically with ``None`` then for the appropriate\n",
    "                properties.\n",
    "            :param severity_map:\n",
    "                A dict used to map a severity string (captured from the\n",
    "                ``output_regex`` with the named group ``severity``) to an\n",
    "                actual ``coalib.results.RESULT_SEVERITY`` for a result.\n",
    "            :param result_message:\n",
    "                The static message to use for results instead of grabbing it\n",
    "                from the executable output via the ``message`` named regex\n",
    "                group.\n",
    "            :return:\n",
    "                An iterator returning results.\n",
    "            \"\"\"\n",
    "            if isinstance(output, str):\n",
    "                output = (output,)\n",
    "\n",
    "            for string in output:\n",
    "                for match in re.finditer(output_regex, string):\n",
    "                    yield self._convert_output_regex_match_to_result(\n",
    "                        match, filename, severity_map=severity_map,\n",
    "                        result_message=result_message)\n",
    "\n",
    "        if options[\"output_format\"] is None:\n",
    "            # Check if user supplied a `process_output` override.\n",
    "            if not callable(getattr(klass, \"process_output\", None)):\n",
    "                raise ValueError(\"`process_output` not provided by given \"\n",
    "                                 \"class {!r}.\".format(klass.__name__))\n",
    "                # No need to assign to `process_output` here, the class mixing\n",
    "                # below automatically does that.\n",
    "        else:\n",
    "            # Prevent people from accidentally defining `process_output`\n",
    "            # manually, as this would implicitly override the internally\n",
    "            # set-up `process_output`.\n",
    "            if hasattr(klass, \"process_output\"):\n",
    "                raise ValueError(\"Found `process_output` already defined \"\n",
    "                                 \"by class {!r}, but {!r} output-format is \"\n",
    "                                 \"specified.\".format(klass.__name__,\n",
    "                                                     options[\"output_format\"]))\n",
    "\n",
    "            if options[\"output_format\"] == \"corrected\":\n",
    "                process_output_args = {\n",
    "                    key: options[key]\n",
    "                    for key in (\"result_message\", \"diff_severity\",\n",
    "                                \"diff_distance\")\n",
    "                    if key in options}\n",
    "\n",
    "                process_output = partialmethod(\n",
    "                    process_output_corrected, **process_output_args)\n",
    "\n",
    "            else:\n",
    "                assert options[\"output_format\"] == \"regex\"\n",
    "\n",
    "                process_output_args = {\n",
    "                    key: options[key]\n",
    "                    for key in (\"output_regex\", \"severity_map\",\n",
    "                                \"result_message\")\n",
    "                    if key in options}\n",
    "\n",
    "                process_output = partialmethod(\n",
    "                    process_output_regex, **process_output_args)\n",
    "\n",
    "        @classmethod\n",
    "        @contextmanager\n",
    "        def _create_config(cls, filename, file, **kwargs):\n",
    "            \"\"\"\n",
    "            Provides a context-manager that creates the config file if the\n",
    "            user provides one and cleans it up when done with linting.\n",
    "\n",
    "            :param filename:\n",
    "                The filename of the file.\n",
    "            :param file:\n",
    "                The file contents.\n",
    "            :param kwargs:\n",
    "                Section settings passed from ``run()``.\n",
    "            :return:\n",
    "                A context-manager handling the config-file.\n",
    "            \"\"\"\n",
    "            content = cls.generate_config(filename, file, **kwargs)\n",
    "            if content is None:\n",
    "                yield None\n",
    "            else:\n",
    "                with make_temp(\n",
    "                        suffix=options[\"config_suffix\"]) as config_file:\n",
    "                    with open(config_file, mode=\"w\") as fl:\n",
    "                        fl.write(content)\n",
    "                    yield config_file\n",
    "\n",
    "        def run(self, filename, file, **kwargs):\n",
    "            # Get the **kwargs params to forward to `generate_config()`\n",
    "            # (from `_create_config()`).\n",
    "            generate_config_kwargs = FunctionMetadata.filter_parameters(\n",
    "                self._get_generate_config_metadata(), kwargs)\n",
    "\n",
    "            with self._create_config(\n",
    "                    filename,\n",
    "                    file,\n",
    "                    **generate_config_kwargs) as config_file:\n",
    "                # And now retrieve the **kwargs for `create_arguments()`.\n",
    "                create_arguments_kwargs = (\n",
    "                    FunctionMetadata.filter_parameters(\n",
    "                        self._get_create_arguments_metadata(), kwargs))\n",
    "\n",
    "                args = self.create_arguments(filename, file, config_file,\n",
    "                                             **create_arguments_kwargs)\n",
    "\n",
    "                try:\n",
    "                    args = tuple(args)\n",
    "                except TypeError:\n",
    "                    self.err(\"The given arguments \"\n",
    "                             \"{!r} are not iterable.\".format(args))\n",
    "                    return\n",
    "\n",
    "                arguments = (self.get_executable(),) + args\n",
    "                self.debug(\"Running '{}'\".format(' '.join(arguments)))\n",
    "\n",
    "                output = run_shell_command(\n",
    "                    arguments,\n",
    "                    stdin=\"\".join(file) if options[\"use_stdin\"] else None)\n",
    "\n",
    "                output = tuple(compress(\n",
    "                    output,\n",
    "                    (options[\"use_stdout\"], options[\"use_stderr\"])))\n",
    "                if len(output) == 1:\n",
    "                    output = output[0]\n",
    "\n",
    "                process_output_kwargs = FunctionMetadata.filter_parameters(\n",
    "                    self._get_process_output_metadata(), kwargs)\n",
    "                return self.process_output(output, filename, file,\n",
    "                                           **process_output_kwargs)\n",
    "\n",
    "        def __repr__(self):\n",
    "            return \"<{} linter object (wrapping {!r}) at {}>\".format(\n",
    "                type(self).__name__, self.get_executable(), hex(id(self)))\n",
    "\n",
    "    # Mixin the linter into the user-defined interface, otherwise\n",
    "    # `create_arguments` and other methods would be overridden by the\n",
    "    # default version.\n",
    "    result_klass = type(klass.__name__, (klass, LinterBase), {})\n",
    "    result_klass.__doc__ = klass.__doc__ if klass.__doc__ else \"\"\n",
    "    return result_klass\n",
    "\n",
    "\n",
    "@enforce_signature\n",
    "def linter(executable: str,\n",
    "           use_stdin: bool=False,\n",
    "           use_stdout: bool=True,\n",
    "           use_stderr: bool=False,\n",
    "           config_suffix: str=\"\",\n",
    "           executable_check_fail_info: str=\"\",\n",
    "           prerequisite_check_command: tuple=(),\n",
    "           output_format: (str, None)=None,\n",
    "           **options):\n",
    "    \"\"\"\n",
    "    Decorator that creates a ``LocalBear`` that is able to process results from\n",
    "    an external linter tool.\n",
    "\n",
    "    The main functionality is achieved through the ``create_arguments()``\n",
    "    function that constructs the command-line-arguments that get parsed to your\n",
    "    executable.\n",
    "\n",
    "    >>> @linter(\"xlint\", output_format=\"regex\", output_regex=\"...\")\n",
    "    ... class XLintBear:\n",
    "    ...     @staticmethod\n",
    "    ...     def create_arguments(filename, file, config_file):\n",
    "    ...         return \"--lint\", filename\n",
    "\n",
    "    Requiring settings is possible like in ``Bear.run()`` with supplying\n",
    "    additional keyword arguments (and if needed with defaults).\n",
    "\n",
    "    >>> @linter(\"xlint\", output_format=\"regex\", output_regex=\"...\")\n",
    "    ... class XLintBear:\n",
    "    ...     @staticmethod\n",
    "    ...     def create_arguments(filename,\n",
    "    ...                          file,\n",
    "    ...                          config_file,\n",
    "    ...                          lintmode: str,\n",
    "    ...                          enable_aggressive_lints: bool=False):\n",
    "    ...         arguments = (\"--lint\", filename, \"--mode=\" + lintmode)\n",
    "    ...         if enable_aggressive_lints:\n",
    "    ...             arguments += (\"--aggressive\",)\n",
    "    ...         return arguments\n",
    "\n",
    "    Sometimes your tool requires an actual file that contains configuration.\n",
    "    ``linter`` allows you to just define the contents the configuration shall\n",
    "    contain via ``generate_config()`` and handles everything else for you.\n",
    "\n",
    "    >>> @linter(\"xlint\", output_format=\"regex\", output_regex=\"...\")\n",
    "    ... class XLintBear:\n",
    "    ...     @staticmethod\n",
    "    ...     def generate_config(filename,\n",
    "    ...                         file,\n",
    "    ...                         lintmode,\n",
    "    ...                         enable_aggressive_lints):\n",
    "    ...         modestring = (\"aggressive\"\n",
    "    ...                       if enable_aggressive_lints else\n",
    "    ...                       \"non-aggressive\")\n",
    "    ...         contents = (\"<xlint>\",\n",
    "    ...                     \"    <mode>\" + lintmode + \"</mode>\",\n",
    "    ...                     \"    <aggressive>\" + modestring + \"</aggressive>\",\n",
    "    ...                     \"</xlint>\")\n",
    "    ...         return \"\\\\n\".join(contents)\n",
    "    ...\n",
    "    ...     @staticmethod\n",
    "    ...     def create_arguments(filename,\n",
    "    ...                          file,\n",
    "    ...                          config_file):\n",
    "    ...         return \"--lint\", filename, \"--config\", config_file\n",
    "\n",
    "    As you can see you don't need to copy additional keyword-arguments you\n",
    "    introduced from ``create_arguments()`` to ``generate_config()`` and\n",
    "    vice-versa. ``linter`` takes care of forwarding the right arguments to the\n",
    "    right place, so you are able to avoid signature duplication.\n",
    "\n",
    "    If you override ``process_output``, you have the same feature like above\n",
    "    (auto-forwarding of the right arguments defined in your function\n",
    "    signature).\n",
    "\n",
    "    Note when overriding ``process_output``: Providing a single output stream\n",
    "    (via ``use_stdout`` or ``use_stderr``) puts the according string attained\n",
    "    from the stream into parameter ``output``, providing both output streams\n",
    "    inputs a tuple with ``(stdout, stderr)``. Providing ``use_stdout=False``\n",
    "    and ``use_stderr=False`` raises a ``ValueError``. By default ``use_stdout``\n",
    "    is ``True`` and ``use_stderr`` is ``False``.\n",
    "\n",
    "    Documentation:\n",
    "    Bear description shall be provided at class level.\n",
    "    If you document your additional parameters inside ``create_arguments``,\n",
    "    ``generate_config`` and ``process_output``, beware that conflicting\n",
    "    documentation between them may be overridden. Document duplicated\n",
    "    parameters inside ``create_arguments`` first, then in ``generate_config``\n",
    "    and after that inside ``process_output``.\n",
    "\n",
    "    For the tutorial see:\n",
    "    http://coala.readthedocs.org/en/latest/Users/Tutorials/Linter_Bears.html\n",
    "\n",
    "    :param executable:\n",
    "        The linter tool.\n",
    "    :param use_stdin:\n",
    "        Whether the input file is sent via stdin instead of passing it over the\n",
    "        command-line-interface.\n",
    "    :param use_stdout:\n",
    "        Whether to use the stdout output stream.\n",
    "    :param use_stderr:\n",
    "        Whether to use the stderr output stream.\n",
    "    :param config_suffix:\n",
    "        The suffix-string to append to the filename of the configuration file\n",
    "        created when ``generate_config`` is supplied. Useful if your executable\n",
    "        expects getting a specific file-type with specific file-ending for the\n",
    "        configuration file.\n",
    "    :param executable_check_fail_info:\n",
    "        Information that is provided together with the fail message from the\n",
    "        normal executable check. By default no additional info is printed.\n",
    "    :param prerequisite_check_command:\n",
    "        A custom command to check for when ``check_prerequisites`` gets\n",
    "        invoked (via ``subprocess.check_call()``). Must be an ``Iterable``.\n",
    "    :param prerequisite_check_fail_message:\n",
    "        A custom message that gets displayed when ``check_prerequisites``\n",
    "        fails while invoking ``prerequisite_check_command``. Can only be\n",
    "        provided together with ``prerequisite_check_command``.\n",
    "    :param output_format:\n",
    "        The output format of the underlying executable. Valid values are\n",
    "\n",
    "        - ``None``: Define your own format by overriding ``process_output``.\n",
    "          Overriding ``process_output`` is then mandatory, not specifying it\n",
    "          raises a ``ValueError``.\n",
    "        - ``'regex'``: Parse output using a regex. See parameter\n",
    "          ``output_regex``.\n",
    "        - ``'corrected'``: The output is the corrected of the given file. Diffs\n",
    "          are then generated to supply patches for results.\n",
    "\n",
    "        Passing something else raises a ``ValueError``.\n",
    "    :param output_regex:\n",
    "        The regex expression as a string that is used to parse the output\n",
    "        generated by the underlying executable. It should use as many of the\n",
    "        following named groups (via ``(?P<name>...)``) to provide a good\n",
    "        result:\n",
    "\n",
    "        - line - The line where the issue starts.\n",
    "        - column - The column where the issue starts.\n",
    "        - end_line - The line where the issue ends.\n",
    "        - end_column - The column where the issue ends.\n",
    "        - severity - The severity of the issue.\n",
    "        - message - The message of the result.\n",
    "        - origin - The origin of the issue.\n",
    "        - additional_info - Additional info provided by the issue.\n",
    "\n",
    "        The groups ``line``, ``column``, ``end_line`` and ``end_column`` don't\n",
    "        have to match numbers only, they can also match nothing, the generated\n",
    "        ``Result`` is filled automatically with ``None`` then for the\n",
    "        appropriate properties.\n",
    "\n",
    "        Needs to be provided if ``output_format`` is ``'regex'``.\n",
    "    :param severity_map:\n",
    "        A dict used to map a severity string (captured from the\n",
    "        ``output_regex`` with the named group ``severity``) to an actual\n",
    "        ``coalib.results.RESULT_SEVERITY`` for a result. Severity strings are\n",
    "        mapped **case-insensitive**!\n",
    "\n",
    "        - ``RESULT_SEVERITY.MAJOR``: Mapped by ``error``.\n",
    "        - ``RESULT_SEVERITY.NORMAL``: Mapped by ``warning`` or ``warn``.\n",
    "        - ``RESULT_SEVERITY.MINOR``: Mapped by ``info``.\n",
    "\n",
    "        A ``ValueError`` is raised when the named group ``severity`` is not\n",
    "        used inside ``output_regex`` and this parameter is given.\n",
    "    :param diff_severity:\n",
    "        The severity to use for all results if ``output_format`` is\n",
    "        ``'corrected'``. By default this value is\n",
    "        ``coalib.results.RESULT_SEVERITY.NORMAL``. The given value needs to be\n",
    "        defined inside ``coalib.results.RESULT_SEVERITY``.\n",
    "    :param result_message:\n",
    "        The message-string to use for all results. Can be used only together\n",
    "        with ``corrected`` or ``regex`` output format. When using\n",
    "        ``corrected``, the default value is ``\"Inconsistency found.\"``, while\n",
    "        for ``regex`` this static message is disabled and the message matched\n",
    "        by ``output_regex`` is used instead.\n",
    "    :param diff_distance:\n",
    "        Number of unchanged lines that are allowed in between two changed lines\n",
    "        so they get yielded as one diff if ``corrected`` output-format is\n",
    "        given. If a negative distance is given, every change will be yielded as\n",
    "        an own diff, even if they are right beneath each other. By default this\n",
    "        value is ``1``.\n",
    "    :raises ValueError:\n",
    "        Raised when invalid options are supplied.\n",
    "    :raises TypeError:\n",
    "        Raised when incompatible types are supplied.\n",
    "        See parameter documentations for allowed types.\n",
    "    :return:\n",
    "        A ``LocalBear`` derivation that lints code using an external tool.\n",
    "    \"\"\"\n",
    "    options[\"executable\"] = executable\n",
    "    options[\"output_format\"] = output_format\n",
    "    options[\"use_stdin\"] = use_stdin\n",
    "    options[\"use_stdout\"] = use_stdout\n",
    "    options[\"use_stderr\"] = use_stderr\n",
    "    options[\"config_suffix\"] = config_suffix\n",
    "    options[\"executable_check_fail_info\"] = executable_check_fail_info\n",
    "    options[\"prerequisite_check_command\"] = prerequisite_check_command\n",
    "\n",
    "    _prepare_options(options)\n",
    "\n",
    "    return partial(_create_linter, options=options)\n"
  ],
  "/home/tushar/coala/coalib/bearlib/abstractions/SectionCreatable.py": [
    "from coalib.settings.FunctionMetadata import FunctionMetadata\n",
    "\n",
    "\n",
    "class SectionCreatable:\n",
    "    \"\"\"\n",
    "    A SectionCreatable is an object that is creatable out of a section object.\n",
    "    Thus this is the class for many helper objects provided by the bearlib.\n",
    "\n",
    "    If you want to use an object that inherits from this class the following\n",
    "    approach is recommended: Instantiate it via the from_section method. You\n",
    "    can provide default arguments via the lower case keyword arguments.\n",
    "\n",
    "    Example:\n",
    "\n",
    "    ::\n",
    "\n",
    "        SpacingHelper.from_section(section, tabwidth=8)\n",
    "\n",
    "    creates a SpacingHelper and if the \"tabwidth\" setting is needed and not\n",
    "    contained in section, 8 will be taken.\n",
    "\n",
    "    It is recommended to write the prototype of the __init__ method according\n",
    "    to this example:\n",
    "\n",
    "    ::\n",
    "\n",
    "        def __init__(self, setting_one: int, setting_two: bool=False):\n",
    "            pass  # Implementation\n",
    "\n",
    "    This way the get_optional_settings and the get_non_optional_settings method\n",
    "    will extract automatically that:\n",
    "\n",
    "    -  setting_one should be an integer\n",
    "    -  setting_two should be a bool and defaults to False\n",
    "\n",
    "    If you write a documentation comment, you can use :param to add\n",
    "    descriptions to your parameters. These will be available too automatically.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self):\n",
    "        pass  # Method needs to be available\n",
    "\n",
    "    @classmethod\n",
    "    def from_section(cls, section, **kwargs):\n",
    "        \"\"\"\n",
    "        Creates the object from a section object.\n",
    "\n",
    "        :param section: A section object containing at least the settings\n",
    "                        specified by get_non_optional_settings()\n",
    "        :param kwargs:  Additional keyword arguments\n",
    "        \"\"\"\n",
    "        kwargs.update(cls.get_metadata().create_params_from_section(section))\n",
    "\n",
    "        return cls(**kwargs)\n",
    "\n",
    "    @classmethod\n",
    "    def get_metadata(cls):\n",
    "        return FunctionMetadata.from_function(cls.__init__, omit={\"self\"})\n",
    "\n",
    "    @classmethod\n",
    "    def get_non_optional_settings(cls):\n",
    "        \"\"\"\n",
    "        Retrieves the minimal set of settings that need to be defined in order\n",
    "        to use this object.\n",
    "\n",
    "        :return: a dictionary of needed settings as keys and help texts as\n",
    "                 values\n",
    "        \"\"\"\n",
    "        return cls.get_metadata().non_optional_params\n",
    "\n",
    "    @classmethod\n",
    "    def get_optional_settings(cls):\n",
    "        \"\"\"\n",
    "        Retrieves the settings needed IN ADDITION to the ones of\n",
    "        get_non_optional_settings to use this object without internal defaults.\n",
    "\n",
    "        :return: a dictionary of needed settings as keys and help texts as\n",
    "                 values\n",
    "        \"\"\"\n",
    "        return cls.get_metadata().optional_params\n"
  ],
  "/home/tushar/coala/coalib/bearlib/abstractions/__init__.py": [
    "\"\"\"\n",
    "The abstractions package contains classes that serve as interfaces for\n",
    "helper classes in the bearlib.\n",
    "\"\"\"\n"
  ],
  "/home/tushar/coala/coalib/bearlib/languages/LanguageDefinition.py": [
    "import os\n",
    "\n",
    "from coalib.bearlib.abstractions.SectionCreatable import SectionCreatable\n",
    "from coalib.misc import Constants\n",
    "from coalib.parsing.ConfParser import ConfParser\n",
    "\n",
    "\n",
    "class LanguageDefinition(SectionCreatable):\n",
    "\n",
    "    def __init__(self, language_family: str, language: str):\n",
    "        \"\"\"\n",
    "        Creates a new LanguageDefinition object from file.\n",
    "\n",
    "        A Language Definition holds constants which may help parsing the\n",
    "        language. If you want to write a bear you'll probably want to use those\n",
    "        definitions to keep your bear independent of the semantics of each\n",
    "        language.\n",
    "\n",
    "        :param language_family:    The language family. E.g. C for C++ and C\n",
    "                                   and C# and so on.\n",
    "        :param language:           The actual language (e.g. C++).\n",
    "        :raises FileNotFoundError: Raised when no definition is available for\n",
    "                                   the given family.\n",
    "        :raises KeyError:          Raised when no definition is available for\n",
    "                                   the given language.\n",
    "        \"\"\"\n",
    "        SectionCreatable.__init__(self)\n",
    "        self.language = language.lower()\n",
    "        filename = os.path.join(Constants.language_definitions,\n",
    "                                language_family.lower() + \".coalang\")\n",
    "        self.lang_dict = ConfParser().parse(filename)[language.lower()]\n",
    "\n",
    "    def __getitem__(self, item):\n",
    "        return self.lang_dict[item]\n",
    "\n",
    "    def __contains__(self, item):\n",
    "        return item in self.lang_dict\n"
  ],
  "/home/tushar/coala/coalib/bearlib/languages/__init__.py": [
    "\"\"\"\n",
    "This directory holds means to get generic information for specific languages.\n",
    "\"\"\"\n"
  ],
  "/home/tushar/coala/coalib/bearlib/languages/definitions/__init__.py": [
    "\"\"\"\n",
    "This directory holds language definitions.\n",
    "\n",
    "Language definitions hold expressions that help defining specific syntax\n",
    "elements for a programming language.\n",
    "\n",
    "Currently defined keys are:\n",
    "\n",
    "  names\n",
    "  extensions\n",
    "  comment_delimiter\n",
    "  multiline_comment_delimiters\n",
    "  string_delimiters\n",
    "  multiline_string_delimiters\n",
    "  keywords\n",
    "  special_chars\n",
    "\"\"\"\n"
  ],
  "/home/tushar/coala/coalib/bearlib/languages/documentation/DocstyleDefinition.py": [
    "import os.path\n",
    "\n",
    "from coala_decorators.decorators import (\n",
    "    enforce_signature, generate_eq, generate_repr)\n",
    "from coalib.parsing.ConfParser import ConfParser\n",
    "\n",
    "\n",
    "@generate_repr()\n",
    "@generate_eq(\"language\", \"docstyle\", \"markers\")\n",
    "class DocstyleDefinition:\n",
    "    \"\"\"\n",
    "    The DocstyleDefinition class holds values that identify a certain type of\n",
    "    documentation comment (for which language, documentation style/tool used\n",
    "    etc.).\n",
    "    \"\"\"\n",
    "\n",
    "    @enforce_signature\n",
    "    def __init__(self, language: str, docstyle: str, markers):\n",
    "        \"\"\"\n",
    "        Instantiates a new DocstyleDefinition.\n",
    "\n",
    "        :param language: The case insensitive programming language of the\n",
    "                         documentation comment, e.g. ``\"CPP\"`` for C++ or\n",
    "                         ``\"PYTHON3\"``.\n",
    "        :param docstyle: The case insensitive documentation style/tool used\n",
    "                         to document code, e.g. ``\"default\"`` or ``\"doxygen\"``.\n",
    "        :param markers:  An iterable of marker/delimiter string iterables\n",
    "                         or a single marker/delimiter string iterable that\n",
    "                         identify a documentation comment. See ``markers``\n",
    "                         property for more details on markers.\n",
    "        \"\"\"\n",
    "        self._language = language.lower()\n",
    "        self._docstyle = docstyle.lower()\n",
    "\n",
    "        # Check and modify tuple if only one marker_set exists.\n",
    "        markers = tuple(markers)\n",
    "        if len(markers) == 3 and all(isinstance(x, str) for x in markers):\n",
    "            markers = (markers,)\n",
    "\n",
    "        self._markers = tuple(tuple(marker_set) for marker_set in markers)\n",
    "\n",
    "        # Check marker set dimensions.\n",
    "        for marker_set in self._markers:\n",
    "            length = len(marker_set)\n",
    "            if length != 3:\n",
    "                raise ValueError(\"Length of a given marker set was not 3 (was \"\n",
    "                                 \"actually {}).\".format(length))\n",
    "\n",
    "    @property\n",
    "    def language(self):\n",
    "        \"\"\"\n",
    "        The programming language.\n",
    "\n",
    "        :return: A lower-case string defining the programming language (i.e.\n",
    "                 \"cpp\" or \"python\").\n",
    "        \"\"\"\n",
    "        return self._language\n",
    "\n",
    "    @property\n",
    "    def docstyle(self):\n",
    "        \"\"\"\n",
    "        The documentation style/tool used to document code.\n",
    "\n",
    "        :return: A lower-case string defining the docstyle (i.e. \"default\" or\n",
    "                 \"doxygen\").\n",
    "        \"\"\"\n",
    "        return self._docstyle\n",
    "\n",
    "    @property\n",
    "    def markers(self):\n",
    "        \"\"\"\n",
    "        A tuple of marker sets that identify a documentation comment.\n",
    "\n",
    "        Marker sets consist of 3 entries where the first is the start-marker,\n",
    "        the second one the each-line marker and the last one the end-marker.\n",
    "        For example a marker tuple with a single marker set\n",
    "        ``((\"/**\", \"*\", \"*/\"),)`` would match following documentation comment:\n",
    "\n",
    "        ::\n",
    "\n",
    "            /**\n",
    "             * This is documentation.\n",
    "             */\n",
    "\n",
    "        It's also possible to supply an empty each-line marker\n",
    "        (``(\"/**\", \"\", \"*/\")``):\n",
    "\n",
    "        ::\n",
    "\n",
    "            /**\n",
    "             This is more documentation.\n",
    "             */\n",
    "\n",
    "        Markers are matched \"greedy\", that means it will match as many\n",
    "        each-line markers as possible. I.e. for ``(\"///\", \"///\", \"///\")``):\n",
    "\n",
    "        ::\n",
    "\n",
    "            /// Brief documentation.\n",
    "            ///\n",
    "            /// Detailed documentation.\n",
    "\n",
    "        :return: A tuple of marker/delimiter string tuples that identify a\n",
    "                 documentation comment.\n",
    "        \"\"\"\n",
    "        return self._markers\n",
    "\n",
    "    @classmethod\n",
    "    @enforce_signature\n",
    "    def load(cls, language: str, docstyle: str):\n",
    "        \"\"\"\n",
    "        Loads a ``DocstyleDefinition`` from the coala docstyle definition files.\n",
    "\n",
    "        This function considers all settings inside the according coalang-files\n",
    "        as markers.\n",
    "\n",
    "        :param language:           The case insensitive programming language of\n",
    "                                   the documentation comment as a string.\n",
    "        :param docstyle:           The case insensitive documentation\n",
    "                                   style/tool used to document code, e.g.\n",
    "                                   ``\"default\"`` or ``\"doxygen\"``.\n",
    "        :raises FileNotFoundError: Raised when the given docstyle was not\n",
    "                                   found.\n",
    "        :raises KeyError:          Raised when the given language is not\n",
    "                                   defined for given docstyle.\n",
    "        :return:                   The ``DocstyleDefinition`` for given language\n",
    "                                   and docstyle.\n",
    "        \"\"\"\n",
    "\n",
    "        docstyle = docstyle.lower()\n",
    "\n",
    "        language_config_parser = ConfParser(remove_empty_iter_elements=False)\n",
    "        try:\n",
    "            docstyle_settings = language_config_parser.parse(\n",
    "                os.path.dirname(__file__) + \"/\" + docstyle + \".coalang\")\n",
    "        except FileNotFoundError:\n",
    "            raise FileNotFoundError(\"Docstyle definition \" + repr(docstyle) +\n",
    "                                    \" not found.\")\n",
    "\n",
    "        language = language.lower()\n",
    "\n",
    "        try:\n",
    "            docstyle_settings = docstyle_settings[language]\n",
    "        except KeyError:\n",
    "            raise KeyError(\"Language {!r} is not defined for docstyle {!r}.\"\n",
    "                           .format(language, docstyle))\n",
    "\n",
    "        marker_sets = (tuple(value)\n",
    "                       for key, value in\n",
    "                       filter(lambda kv: not kv[0].startswith(\"comment\"),\n",
    "                              docstyle_settings.contents.items()))\n",
    "\n",
    "        return cls(language, docstyle, marker_sets)\n"
  ],
  "/home/tushar/coala/coalib/bearlib/languages/documentation/DocumentationComment.py": [
    "from coala_decorators.decorators import generate_eq, generate_repr\n",
    "\n",
    "\n",
    "@generate_repr()\n",
    "@generate_eq(\"documentation\", \"marker\", \"range\")\n",
    "class DocumentationComment:\n",
    "    \"\"\"\n",
    "    The DocumentationComment holds information about a documentation comment\n",
    "    inside source-code, like position etc.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, documentation, marker, range):\n",
    "        \"\"\"\n",
    "        Instantiates a new DocumentationComment.\n",
    "\n",
    "        :param documentation: The documentation text.\n",
    "        :param marker:        The three-element tuple with marker strings that\n",
    "                              identified this documentation comment.\n",
    "        :param range:         The position range of type TextRange.\n",
    "        \"\"\"\n",
    "        self.documentation = documentation\n",
    "        self.marker = marker\n",
    "        self.range = range\n",
    "\n",
    "    def __str__(self):\n",
    "        return self.documentation\n"
  ],
  "/home/tushar/coala/coalib/bearlib/languages/documentation/DocumentationExtraction.py": [
    "import re\n",
    "\n",
    "from coalib.bearlib.languages.documentation.DocstyleDefinition import (\n",
    "    DocstyleDefinition)\n",
    "from coalib.bearlib.languages.documentation.DocumentationComment import (\n",
    "    DocumentationComment)\n",
    "from coalib.results.TextRange import TextRange\n",
    "\n",
    "\n",
    "def _extract_doc_comment_simple(content, line, column, markers):\n",
    "    \"\"\"\n",
    "    Extract a documentation that starts at given beginning with simple layout.\n",
    "\n",
    "    The property of the simple layout is that there's no each-line marker. This\n",
    "    applies e.g. for python docstrings.\n",
    "\n",
    "    :param content: Presplitted lines of the source-code-string.\n",
    "    :param line:    Line where the documentation comment starts (behind the\n",
    "                    start marker). Zero-based.\n",
    "    :param column:  Column where the documentation comment starts (behind the\n",
    "                    start marker). Zero-based.\n",
    "    :param markers: The documentation identifying markers.\n",
    "    :return:        If the comment matched layout a triple with end-of-comment\n",
    "                    line, column and the extracted documentation. If not\n",
    "                    matched, returns None.\n",
    "    \"\"\"\n",
    "    align_column = column - len(markers[0])\n",
    "\n",
    "    pos = content[line].find(markers[2], column)\n",
    "    if pos != -1:\n",
    "        return line, pos + len(markers[2]), content[line][column:pos]\n",
    "\n",
    "    doc_comment = content[line][column:]\n",
    "    line += 1\n",
    "\n",
    "    while line < len(content):\n",
    "        pos = content[line].find(markers[2])\n",
    "        if pos == -1:\n",
    "            doc_comment += content[line][align_column:]\n",
    "        else:\n",
    "            doc_comment += content[line][align_column:pos]\n",
    "            return line, pos + len(markers[2]), doc_comment\n",
    "\n",
    "        line += 1\n",
    "\n",
    "    return None\n",
    "\n",
    "\n",
    "def _extract_doc_comment_continuous(content, line, column, markers):\n",
    "    \"\"\"\n",
    "    Extract a documentation that starts at given beginning with continuous\n",
    "    layout.\n",
    "\n",
    "    The property of the continuous layout is that the each-line-marker and the\n",
    "    end-marker do equal. Documentation is extracted until no further marker is\n",
    "    found. Applies e.g. for doxygen style python documentation:\n",
    "\n",
    "    ```\n",
    "    ## main\n",
    "    #\n",
    "    #  detailed\n",
    "    ```\n",
    "\n",
    "    :param content: Presplitted lines of the source-code-string.\n",
    "    :param line:    Line where the documentation comment starts (behind the\n",
    "                    start marker). Zero-based.\n",
    "    :param column:  Column where the documentation comment starts (behind the\n",
    "                    start marker). Zero-based.\n",
    "    :param markers: The documentation identifying markers.\n",
    "    :return:        If the comment matched layout a triple with end-of-comment\n",
    "                    line, column and the extracted documentation. If not\n",
    "                    matched, returns None.\n",
    "    \"\"\"\n",
    "    marker_len = len(markers[1])\n",
    "\n",
    "    doc_comment = content[line][column:]\n",
    "    line += 1\n",
    "    while line < len(content):\n",
    "        pos = content[line].find(markers[1])\n",
    "        if pos == -1:\n",
    "            return line, 0, doc_comment\n",
    "        else:\n",
    "            doc_comment += content[line][pos+marker_len:]\n",
    "\n",
    "        line += 1\n",
    "\n",
    "    if content[line - 1][-1] == \"\\n\":\n",
    "        column = 0\n",
    "    else:\n",
    "        # This case can appear on end-of-document without a ``\\n``.\n",
    "        line -= 1\n",
    "        column = len(content[line])\n",
    "\n",
    "    return line, column, doc_comment\n",
    "\n",
    "\n",
    "def _extract_doc_comment_standard(content, line, column, markers):\n",
    "    \"\"\"\n",
    "    Extract a documentation that starts at given beginning with standard\n",
    "    layout.\n",
    "\n",
    "    The standard layout applies e.g. for C doxygen-style documentation:\n",
    "\n",
    "    ```\n",
    "    /**\n",
    "     * documentation\n",
    "     */\n",
    "    ```\n",
    "\n",
    "    :param content: Presplitted lines of the source-code-string.\n",
    "    :param line:    Line where the documentation comment starts (behind the\n",
    "                    start marker). Zero-based.\n",
    "    :param column:  Column where the documentation comment starts (behind the\n",
    "                    start marker). Zero-based.\n",
    "    :param markers: The documentation identifying markers.\n",
    "    :return:        If the comment matched layout a triple with end-of-comment\n",
    "                    line, column and the extracted documentation. If not\n",
    "                    matched, returns None.\n",
    "    \"\"\"\n",
    "    pos = content[line].find(markers[2], column)\n",
    "    if pos != -1:\n",
    "        return line, pos + len(markers[2]), content[line][column:pos]\n",
    "\n",
    "    doc_comment = content[line][column:]\n",
    "    line += 1\n",
    "\n",
    "    while line < len(content):\n",
    "        pos = content[line].find(markers[2])\n",
    "        each_line_pos = content[line].find(markers[1])\n",
    "\n",
    "        if pos == -1:\n",
    "            if each_line_pos == -1:\n",
    "                # If the first text occurrence is not the each-line marker\n",
    "                # now we violate the doc-comment layout.\n",
    "                return None\n",
    "            doc_comment += content[line][each_line_pos+len(markers[1]):]\n",
    "        else:\n",
    "            # If no each-line marker found or it's located past the end marker:\n",
    "            # extract no further and end the doc-comment.\n",
    "            if each_line_pos != -1 and each_line_pos + 1 < pos:\n",
    "                doc_comment += content[line][each_line_pos+len(markers[1]):pos]\n",
    "\n",
    "            return line, pos + len(markers[2]), doc_comment\n",
    "\n",
    "        line += 1\n",
    "\n",
    "    return None\n",
    "\n",
    "\n",
    "def _extract_doc_comment(content, line, column, markers):\n",
    "    \"\"\"\n",
    "    Delegates depending on the given markers to the right extraction method.\n",
    "\n",
    "    :param content: Presplitted lines of the source-code-string.\n",
    "    :param line:    Line where the documentation comment starts (behind the\n",
    "                    start marker). Zero-based.\n",
    "    :param column:  Column where the documentation comment starts (behind the\n",
    "                    start marker). Zero-based.\n",
    "    :param markers: The documentation identifying markers.\n",
    "    :return:        If the comment matched layout a triple with end-of-comment\n",
    "                    line, column and the extracted documentation. If not\n",
    "                    matched, returns None.\n",
    "    \"\"\"\n",
    "    if markers[1] == \"\":\n",
    "        # Extract and align to start marker.\n",
    "        return _extract_doc_comment_simple(content, line, column, markers)\n",
    "    elif markers[1] == markers[2]:\n",
    "        # Search for the each-line marker until it runs out.\n",
    "        return _extract_doc_comment_continuous(content, line, column, markers)\n",
    "    else:\n",
    "        return _extract_doc_comment_standard(content, line, column, markers)\n",
    "\n",
    "\n",
    "def _compile_multi_match_regex(strings):\n",
    "    \"\"\"\n",
    "    Compiles a regex object that matches each of the given strings.\n",
    "\n",
    "    :param strings: The strings to match.\n",
    "    :return:        A regex object.\n",
    "    \"\"\"\n",
    "    return re.compile(\"|\".join(re.escape(s) for s in strings))\n",
    "\n",
    "\n",
    "def _extract_doc_comment_from_line(content, line, column, regex, marker_dict):\n",
    "    begin_match = regex.search(content[line], column)\n",
    "    if begin_match:\n",
    "        column = begin_match.end()\n",
    "        for marker in marker_dict[begin_match.group()]:\n",
    "            doc_comment = _extract_doc_comment(content, line, column, marker)\n",
    "            if doc_comment is not None:\n",
    "                end_line, end_column, documentation = doc_comment\n",
    "\n",
    "                rng = TextRange.from_values(line + 1,\n",
    "                                            begin_match.start() + 1,\n",
    "                                            end_line + 1,\n",
    "                                            end_column + 1)\n",
    "                doc = DocumentationComment(documentation, marker, rng)\n",
    "\n",
    "                return end_line, end_column, doc\n",
    "\n",
    "    return line + 1, 0, None\n",
    "\n",
    "\n",
    "def extract_documentation_with_markers(content, markers):\n",
    "    \"\"\"\n",
    "    Extracts all documentation texts inside the given source-code-string.\n",
    "\n",
    "    :param content: The source-code-string where to extract documentation from.\n",
    "                    Needs to be a list or tuple where each string item is a\n",
    "                    single line (including ending whitespaces like ``\\\\n``).\n",
    "    :param markers: The list/tuple of marker-sets that identify a\n",
    "                    documentation-comment. Low-index markers have higher\n",
    "                    priority than high-index markers.\n",
    "    :return:        An iterator returning each DocumentationComment found in\n",
    "                    the content.\n",
    "    \"\"\"\n",
    "    # Prepare marker-tuple dict that maps a begin pattern to the corresponding\n",
    "    # marker_set(s). This makes it faster to retrieve a marker-set from a\n",
    "    # begin sequence we initially want to search for in source code. Then\n",
    "    # the possible found documentation match is processed further with the\n",
    "    # rest markers.\n",
    "    marker_dict = {}\n",
    "    for marker_set in markers:\n",
    "        if marker_set[0] not in marker_dict:\n",
    "            marker_dict[marker_set[0]] = [marker_set]\n",
    "        else:\n",
    "            marker_dict[marker_set[0]].append(marker_set)\n",
    "\n",
    "    # Using regexes to perform a variable match is faster than finding each\n",
    "    # substring with ``str.find()`` choosing the lowest match.\n",
    "    begin_regex = _compile_multi_match_regex(\n",
    "        marker_set[0] for marker_set in markers)\n",
    "\n",
    "    line = 0\n",
    "    column = 0\n",
    "    while line < len(content):\n",
    "        line, column, doc = _extract_doc_comment_from_line(content,\n",
    "                                                           line,\n",
    "                                                           column,\n",
    "                                                           begin_regex,\n",
    "                                                           marker_dict)\n",
    "        if doc:\n",
    "            yield doc\n",
    "\n",
    "\n",
    "def extract_documentation(content, language, docstyle):\n",
    "    \"\"\"\n",
    "    Extracts all documentation texts inside the given source-code-string using\n",
    "    the coala docstyle definition files.\n",
    "\n",
    "    The documentation texts are sorted by their order appearing in ``content``.\n",
    "\n",
    "    For more information about how documentation comments are identified and\n",
    "    extracted, see DocstyleDefinition.doctypes enumeration.\n",
    "\n",
    "    :param content:            The source-code-string where to extract\n",
    "                               documentation from. Needs to be a list or tuple\n",
    "                               where each string item is a single line\n",
    "                               (including ending whitespaces like ``\\\\n``).\n",
    "    :param language:           The programming language used.\n",
    "    :param docstyle:           The documentation style/tool used\n",
    "                               (e.g. doxygen).\n",
    "    :raises FileNotFoundError: Raised when the docstyle definition file was not\n",
    "                               found.\n",
    "    :raises KeyError:          Raised when the given language is not defined in\n",
    "                               given docstyle.\n",
    "    :raises ValueError:        Raised when a docstyle definition setting has an\n",
    "                               invalid format.\n",
    "    :return:                   An iterator returning each DocumentationComment\n",
    "                               found in the content.\n",
    "    \"\"\"\n",
    "    docstyle_definition = DocstyleDefinition.load(language, docstyle)\n",
    "    return extract_documentation_with_markers(content,\n",
    "                                              docstyle_definition.markers)\n"
  ],
  "/home/tushar/coala/coalib/bearlib/languages/documentation/__init__.py": [
    "\"\"\"\n",
    "Provides facilities to extract, parse and assemble documentation comments for\n",
    "different languages and documentation tools.\n",
    "\"\"\"\n"
  ],
  "/home/tushar/coala/coalib/bearlib/spacing/SpacingHelper.py": [
    "from coalib.bearlib.abstractions.SectionCreatable import SectionCreatable\n",
    "from coala_decorators.decorators import enforce_signature\n",
    "\n",
    "\n",
    "class SpacingHelper(SectionCreatable):\n",
    "    DEFAULT_TAB_WIDTH = 4\n",
    "\n",
    "    def __init__(self, tab_width: int=DEFAULT_TAB_WIDTH):\n",
    "        \"\"\"\n",
    "        Creates a helper object for spacing operations.\n",
    "\n",
    "        :param tab_width: The number of spaces which visually equals a tab.\n",
    "        \"\"\"\n",
    "        SectionCreatable.__init__(self)\n",
    "        if not isinstance(tab_width, int):\n",
    "            raise TypeError(\"The 'tab_width' parameter should be an integer.\")\n",
    "\n",
    "        self.tab_width = tab_width\n",
    "\n",
    "    @enforce_signature\n",
    "    def get_indentation(self, line: str):\n",
    "        \"\"\"\n",
    "        Checks the lines indentation.\n",
    "\n",
    "        :param line: A string to check for indentation.\n",
    "        :return:     The indentation count in spaces.\n",
    "        \"\"\"\n",
    "        count = 0\n",
    "        for char in line:\n",
    "            if char == ' ':\n",
    "                count += 1\n",
    "                continue\n",
    "\n",
    "            if char == '\\t':\n",
    "                count += self.tab_width - (count % self.tab_width)\n",
    "                continue\n",
    "\n",
    "            break\n",
    "\n",
    "        return count\n",
    "\n",
    "    @enforce_signature\n",
    "    def replace_tabs_with_spaces(self, line: str):\n",
    "        \"\"\"\n",
    "        Replaces tabs in this line with the appropriate number of spaces.\n",
    "\n",
    "        Example: \" \\t\" will be converted to \"    \", assuming the tab_width is\n",
    "        set to 4.\n",
    "\n",
    "        :param line: The string with tabs to replace.\n",
    "        :return:     A string with no tabs.\n",
    "        \"\"\"\n",
    "        for t_position, t_length in sorted(self.yield_tab_lengths(line),\n",
    "                                           reverse=True):\n",
    "            line = line[:t_position] + t_length * ' ' + line[t_position+1:]\n",
    "\n",
    "        return line\n",
    "\n",
    "    @enforce_signature\n",
    "    def yield_tab_lengths(self, input: str):\n",
    "        \"\"\"\n",
    "        Yields position and size of tabs in a input string.\n",
    "\n",
    "        :param input: The string with tabs.\n",
    "        \"\"\"\n",
    "        tabless_position = 0\n",
    "        for index, char in enumerate(input):\n",
    "            if char == '\\t':\n",
    "                space_count = (self.tab_width - tabless_position\n",
    "                               % self.tab_width)\n",
    "                yield index, space_count\n",
    "                tabless_position += space_count\n",
    "                continue\n",
    "\n",
    "            tabless_position += 1\n",
    "\n",
    "    @enforce_signature\n",
    "    def replace_spaces_with_tabs(self, line: str):\n",
    "        \"\"\"\n",
    "        Replaces spaces with tabs where possible. However in no case only one\n",
    "        space will be replaced by a tab.\n",
    "\n",
    "        Example: \" \\t   a_text   another\" will be converted to\n",
    "        \"\\t   a_text\\tanother\", assuming the tab_width is set to 4.\n",
    "\n",
    "        :param line: The string with spaces to replace.\n",
    "        :return:     The converted string.\n",
    "        \"\"\"\n",
    "        currspaces = 0\n",
    "        result = \"\"\n",
    "        # Tracking the index of the string isnt enough because tabs are\n",
    "        # spanning over multiple columns\n",
    "        tabless_position = 0\n",
    "        for char in line:\n",
    "            if char == \" \":\n",
    "                currspaces += 1\n",
    "                tabless_position += 1\n",
    "            elif char == \"\\t\":\n",
    "                space_count = (self.tab_width - tabless_position\n",
    "                               % self.tab_width)\n",
    "                currspaces += space_count\n",
    "                tabless_position += space_count\n",
    "            else:\n",
    "                result += currspaces*\" \" + char\n",
    "                currspaces = 0\n",
    "                tabless_position += 1\n",
    "\n",
    "            # tabless_position is now incremented to point _after_ the current\n",
    "            # char\n",
    "            if tabless_position % self.tab_width == 0:\n",
    "                if currspaces > 1:\n",
    "                    result += \"\\t\"\n",
    "                else:\n",
    "                    result += currspaces*\" \"\n",
    "\n",
    "                currspaces = 0\n",
    "\n",
    "        result += currspaces*\" \"\n",
    "\n",
    "        return result\n"
  ],
  "/home/tushar/coala/coalib/bearlib/spacing/__init__.py": [],
  "/home/tushar/coala/coalib/bears/BEAR_KIND.py": [
    "from coalib.misc.Enum import enum\n",
    "\n",
    "BEAR_KIND = enum(\"LOCAL\", \"GLOBAL\")\n"
  ],
  "/home/tushar/coala/coalib/bears/Bear.py": [
    "import traceback\n",
    "from os import makedirs\n",
    "from os.path import join, abspath, exists\n",
    "from shutil import copyfileobj\n",
    "from urllib.request import urlopen\n",
    "\n",
    "from appdirs import user_data_dir\n",
    "\n",
    "from pyprint.Printer import Printer\n",
    "\n",
    "from coala_decorators.decorators import enforce_signature, classproperty\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "from coalib.settings.FunctionMetadata import FunctionMetadata\n",
    "from coalib.settings.Section import Section\n",
    "from coalib.settings.ConfigurationGathering import get_config_directory\n",
    "\n",
    "\n",
    "class Bear(Printer, LogPrinter):\n",
    "    \"\"\"\n",
    "    A bear contains the actual subroutine that is responsible for checking\n",
    "    source code for certain specifications. However it can actually do\n",
    "    whatever it wants with the files it gets. If you are missing some Result\n",
    "    type, feel free to contact us and/or help us extending the coalib.\n",
    "\n",
    "    This is the base class for every bear. If you want to write an bear, you\n",
    "    will probably want to look at the GlobalBear and LocalBear classes that\n",
    "    inherit from this class. In any case you'll want to overwrite at least the\n",
    "    run method. You can send debug/warning/error messages through the\n",
    "    debug(), warn(), err() functions. These will send the\n",
    "    appropriate messages so that they are outputted. Be aware that if you use\n",
    "    err(), you are expected to also terminate the bear run-through\n",
    "    immediately.\n",
    "\n",
    "    If you need some setup or teardown for your bear, feel free to overwrite\n",
    "    the set_up() and tear_down() functions. They will be invoked\n",
    "    before/after every run invocation.\n",
    "\n",
    "    Settings are available at all times through self.section.\n",
    "\n",
    "    To indicate which languages your bear supports, just give it the\n",
    "    ``LANGUAGES`` value which can either be a string (if the bear supports\n",
    "    only 1 language) or a tuple of strings:\n",
    "\n",
    "    >>> class SomeBear(Bear):\n",
    "    ...     LANGUAGES = ('C', 'CPP','C#', 'D')\n",
    "\n",
    "    >>> class SomeBear(Bear):\n",
    "    ...     LANGUAGES = \"Java\"\n",
    "\n",
    "    Every bear has a data directory which is unique to that particular bear:\n",
    "\n",
    "    >>> class SomeBear(Bear): pass\n",
    "    >>> class SomeOtherBear(Bear): pass\n",
    "    >>> SomeBear.data_dir == SomeOtherBear.data_dir\n",
    "    False\n",
    "    \"\"\"\n",
    "\n",
    "    LANGUAGES = ()\n",
    "\n",
    "    @classproperty\n",
    "    def name(cls):\n",
    "        \"\"\"\n",
    "        :return: The name of the bear\n",
    "        \"\"\"\n",
    "        return cls.__name__\n",
    "\n",
    "    @classproperty\n",
    "    def supported_languages(cls):\n",
    "        \"\"\"\n",
    "        :return: The languages supported by the bear.\n",
    "        \"\"\"\n",
    "        return (cls.LANGUAGES if isinstance(\n",
    "            cls.LANGUAGES, tuple) else (cls.LANGUAGES,))\n",
    "\n",
    "    @enforce_signature\n",
    "    def __init__(self,\n",
    "                 section: Section,\n",
    "                 message_queue,\n",
    "                 timeout=0):\n",
    "        \"\"\"\n",
    "        Constructs a new bear.\n",
    "\n",
    "        :param section:       The section object where bear settings are\n",
    "                              contained.\n",
    "        :param message_queue: The queue object for messages. Can be ``None``.\n",
    "        :param timeout:       The time the bear is allowed to run. To set no\n",
    "                              time limit, use 0.\n",
    "        :raises TypeError:    Raised when ``message_queue`` is no queue.\n",
    "        :raises RuntimeError: Raised when bear requirements are not fulfilled.\n",
    "        \"\"\"\n",
    "        Printer.__init__(self)\n",
    "        LogPrinter.__init__(self, self)\n",
    "\n",
    "        if message_queue is not None and not hasattr(message_queue, \"put\"):\n",
    "            raise TypeError(\"message_queue has to be a Queue or None.\")\n",
    "\n",
    "        self.section = section\n",
    "        self.message_queue = message_queue\n",
    "        self.timeout = timeout\n",
    "\n",
    "        self.setup_dependencies()\n",
    "        cp = type(self).check_prerequisites()\n",
    "        if cp is not True:\n",
    "            error_string = (\"The bear \" + self.name +\n",
    "                            \" does not fulfill all requirements.\")\n",
    "            if cp is not False:\n",
    "                error_string += \" \" + cp\n",
    "\n",
    "            self.warn(error_string)\n",
    "            raise RuntimeError(error_string)\n",
    "\n",
    "    def _print(self, output, **kwargs):\n",
    "        self.debug(output)\n",
    "\n",
    "    def log_message(self, log_message, timestamp=None, **kwargs):\n",
    "        if self.message_queue is not None:\n",
    "            self.message_queue.put(log_message)\n",
    "\n",
    "    def run(self, *args, dependency_results=None, **kwargs):\n",
    "        raise NotImplementedError\n",
    "\n",
    "    def run_bear_from_section(self, args, kwargs):\n",
    "        try:\n",
    "            kwargs.update(\n",
    "                self.get_metadata().create_params_from_section(self.section))\n",
    "        except ValueError as err:\n",
    "            self.warn(\"The bear {} cannot be executed.\".format(\n",
    "                self.name), str(err))\n",
    "            return\n",
    "\n",
    "        return self.run(*args, **kwargs)\n",
    "\n",
    "    def execute(self, *args, **kwargs):\n",
    "        name = self.name\n",
    "        try:\n",
    "            self.debug(\"Running bear {}...\".format(name))\n",
    "            # If it's already a list it won't change it\n",
    "            return list(self.run_bear_from_section(args, kwargs) or [])\n",
    "        except:\n",
    "            self.warn(\n",
    "                \"Bear {} failed to run. Take a look at debug messages for \"\n",
    "                \"further information.\".format(name))\n",
    "            self.debug(\n",
    "                \"The bear {bear} raised an exception. If you are the writer \"\n",
    "                \"of this bear, please make sure to catch all exceptions. If \"\n",
    "                \"not and this error annoys you, you might want to get in \"\n",
    "                \"contact with the writer of this bear.\\n\\nTraceback \"\n",
    "                \"information is provided below:\\n\\n{traceback}\"\n",
    "                \"\\n\".format(bear=name, traceback=traceback.format_exc()))\n",
    "\n",
    "    @staticmethod\n",
    "    def kind():\n",
    "        \"\"\"\n",
    "        :return: The kind of the bear\n",
    "        \"\"\"\n",
    "        raise NotImplementedError\n",
    "\n",
    "    @classmethod\n",
    "    def get_metadata(cls):\n",
    "        \"\"\"\n",
    "        :return: Metadata for the run function. However parameters like\n",
    "                 ``self`` or parameters implicitly used by coala (e.g.\n",
    "                 filename for local bears) are already removed.\n",
    "        \"\"\"\n",
    "        return FunctionMetadata.from_function(\n",
    "            cls.run,\n",
    "            omit={\"self\", \"dependency_results\"})\n",
    "\n",
    "    @classmethod\n",
    "    def missing_dependencies(cls, lst):\n",
    "        \"\"\"\n",
    "        Checks if the given list contains all dependencies.\n",
    "\n",
    "        :param lst: A list of all already resolved bear classes (not\n",
    "                    instances).\n",
    "        :return:    A list of missing dependencies.\n",
    "        \"\"\"\n",
    "        dep_classes = cls.get_dependencies()\n",
    "\n",
    "        for item in lst:\n",
    "            if item in dep_classes:\n",
    "                dep_classes.remove(item)\n",
    "\n",
    "        return dep_classes\n",
    "\n",
    "    @staticmethod\n",
    "    def get_dependencies():\n",
    "        \"\"\"\n",
    "        Retrieves bear classes that are to be executed before this bear gets\n",
    "        executed. The results of these bears will then be passed to the\n",
    "        run method as a dict via the dependency_results argument. The dict\n",
    "        will have the name of the Bear as key and the list of its results as\n",
    "        results.\n",
    "\n",
    "        :return: A list of bear classes.\n",
    "        \"\"\"\n",
    "        return []\n",
    "\n",
    "    @classmethod\n",
    "    def get_non_optional_settings(cls):\n",
    "        \"\"\"\n",
    "        This method has to determine which settings are needed by this bear.\n",
    "        The user will be prompted for needed settings that are not available\n",
    "        in the settings file so don't include settings where a default value\n",
    "        would do.\n",
    "\n",
    "        :return: A dictionary of needed settings as keys and a tuple of help\n",
    "                 text and annotation as values\n",
    "        \"\"\"\n",
    "        return cls.get_metadata().non_optional_params\n",
    "\n",
    "    @staticmethod\n",
    "    def setup_dependencies():\n",
    "        \"\"\"\n",
    "        This is a user defined function that can download and set up\n",
    "        dependencies (via download_cached_file or arbitary other means) in an OS\n",
    "        independent way.\n",
    "        \"\"\"\n",
    "\n",
    "    @classmethod\n",
    "    def check_prerequisites(cls):\n",
    "        \"\"\"\n",
    "        Checks whether needed runtime prerequisites of the bear are satisfied.\n",
    "\n",
    "        This function gets executed at construction and returns True by\n",
    "        default.\n",
    "\n",
    "        Section value requirements shall be checked inside the ``run`` method.\n",
    "\n",
    "        :return: True if prerequisites are satisfied, else False or a string\n",
    "                 that serves a more detailed description of what's missing.\n",
    "        \"\"\"\n",
    "        return True\n",
    "\n",
    "    def get_config_dir(self):\n",
    "        \"\"\"\n",
    "        Gives the directory where the configuration file is\n",
    "\n",
    "        :return: Directory of the config file\n",
    "        \"\"\"\n",
    "        return get_config_directory(self.section)\n",
    "\n",
    "    def download_cached_file(self, url, filename):\n",
    "        \"\"\"\n",
    "        Downloads the file if needed and caches it for the next time. If a\n",
    "        download happens, the user will be informed.\n",
    "\n",
    "        Take a sane simple bear:\n",
    "\n",
    "        >>> from queue import Queue\n",
    "        >>> bear = Bear(Section(\"a section\"), Queue())\n",
    "\n",
    "        We can now carelessly query for a neat file that doesn't exist yet:\n",
    "\n",
    "        >>> from os import remove\n",
    "        >>> if exists(join(bear.data_dir, \"a_file\")):\n",
    "        ...     remove(join(bear.data_dir, \"a_file\"))\n",
    "        >>> file = bear.download_cached_file(\"http://gitmate.com/\", \"a_file\")\n",
    "\n",
    "        If we download it again, it'll be much faster as no download occurs:\n",
    "\n",
    "        >>> newfile = bear.download_cached_file(\"http://gitmate.com/\", \"a_file\")\n",
    "        >>> newfile == file\n",
    "        True\n",
    "\n",
    "        :param url:      The URL to download the file from.\n",
    "        :param filename: The filename it should get, e.g. \"test.txt\".\n",
    "        :return:         A full path to the file ready for you to use!\n",
    "        \"\"\"\n",
    "        filename = join(self.data_dir, filename)\n",
    "        if exists(filename):\n",
    "            return filename\n",
    "\n",
    "        self.info(\"Downloading {filename!r} for bear {bearname} from {url}.\"\n",
    "                  .format(filename=filename, bearname=self.name, url=url))\n",
    "\n",
    "        with urlopen(url) as response, open(filename, 'wb') as out_file:\n",
    "            copyfileobj(response, out_file)\n",
    "        return filename\n",
    "\n",
    "    @classproperty\n",
    "    def data_dir(cls):\n",
    "        \"\"\"\n",
    "        Returns a directory that may be used by the bear to store stuff. Every\n",
    "        bear has an own directory dependent on his name.\n",
    "        \"\"\"\n",
    "        data_dir = abspath(join(user_data_dir('coala-bears'), cls.name))\n",
    "\n",
    "        makedirs(data_dir, exist_ok=True)\n",
    "        return data_dir\n"
  ],
  "/home/tushar/coala/coalib/bears/GlobalBear.py": [
    "from coalib.bears.Bear import Bear\n",
    "from coalib.bears.BEAR_KIND import BEAR_KIND\n",
    "\n",
    "\n",
    "class GlobalBear(Bear):\n",
    "    \"\"\"\n",
    "    A GlobalBear is able to analyze semantic facts across several file.\n",
    "\n",
    "    The results of a GlobalBear will be presented grouped by the origin Bear.\n",
    "    Therefore Results spanning above multiple files are allowed and will be\n",
    "    handled right.\n",
    "\n",
    "    If you only look at one file at once anyway a LocalBear is better for your\n",
    "    needs. (And better for performance and usability for both user and\n",
    "    developer.)\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self,\n",
    "                 file_dict,  # filename : file contents\n",
    "                 section,\n",
    "                 message_queue,\n",
    "                 timeout=0):\n",
    "        Bear.__init__(self, section, message_queue, timeout)\n",
    "        self.file_dict = file_dict\n",
    "\n",
    "    @staticmethod\n",
    "    def kind():\n",
    "        return BEAR_KIND.GLOBAL\n",
    "\n",
    "    def run(self,\n",
    "            *args,\n",
    "            dependency_results=None,\n",
    "            **kwargs):\n",
    "        \"\"\"\n",
    "        Handles all files in file_dict.\n",
    "\n",
    "        :return: A list of Result type.\n",
    "        \"\"\"\n",
    "        raise NotImplementedError(\n",
    "            \"This function has to be implemented for a runnable bear.\")\n"
  ],
  "/home/tushar/coala/coalib/bears/LocalBear.py": [
    "from coalib.bears.Bear import Bear\n",
    "from coalib.bears.BEAR_KIND import BEAR_KIND\n",
    "from coalib.settings.FunctionMetadata import FunctionMetadata\n",
    "\n",
    "\n",
    "class LocalBear(Bear):\n",
    "    \"\"\"\n",
    "    A LocalBear is a Bear that analyzes only one file at once. It therefore can\n",
    "    not analyze semantical facts over multiple files.\n",
    "\n",
    "    This has the advantage that it can be highly parrallelized. In addition,\n",
    "    the results from multiple bears for one file can be shown together for that\n",
    "    file, which is better to grasp for the user. coala takes care of all that.\n",
    "\n",
    "    Examples for LocalBear's could be:\n",
    "\n",
    "    -   A SpaceConsistencyBear that checks every line for trailing whitespaces,\n",
    "        tabs, etc.\n",
    "    -   A VariableNameBear that checks variable names and constant names for\n",
    "        certain conditions\n",
    "    \"\"\"\n",
    "\n",
    "    @staticmethod\n",
    "    def kind():\n",
    "        return BEAR_KIND.LOCAL\n",
    "\n",
    "    def run(self,\n",
    "            filename,\n",
    "            file,\n",
    "            *args,\n",
    "            dependency_results=None,\n",
    "            **kwargs):\n",
    "        \"\"\"\n",
    "        Handles the given file.\n",
    "\n",
    "        :param filename: The filename of the file\n",
    "        :param file:     The file contents as string array\n",
    "        :return:         A list of Result\n",
    "        \"\"\"\n",
    "        raise NotImplementedError(\"This function has to be implemented for a \"\n",
    "                                  \"runnable bear.\")\n",
    "\n",
    "    @classmethod\n",
    "    def get_metadata(cls):\n",
    "        return FunctionMetadata.from_function(\n",
    "            cls.run,\n",
    "            omit={\"self\", \"filename\", \"file\", \"dependency_results\"})\n"
  ],
  "/home/tushar/coala/coalib/bears/__init__.py": [],
  "/home/tushar/coala/coalib/coala.py": [
    "# This program is free software: you can redistribute it and/or modify it\n",
    "# under the terms of the GNU Affero General Public License as published by the\n",
    "# Free Software Foundation, either version 3 of the License, or (at your\n",
    "# option) any later version.\n",
    "#\n",
    "# This program is distributed in the hope that it will be useful, but WITHOUT\n",
    "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n",
    "# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License\n",
    "# for more details.\n",
    "#\n",
    "# You should have received a copy of the GNU Affero General Public License\n",
    "# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n",
    "\n",
    "import functools\n",
    "\n",
    "from pyprint.ConsolePrinter import ConsolePrinter\n",
    "\n",
    "from coalib.coala_main import run_coala\n",
    "from coalib.collecting.Collectors import (\n",
    "    collect_all_bears_from_sections, filter_section_bears_by_languages)\n",
    "from coalib.misc.Exceptions import get_exitcode\n",
    "from coalib.output.ConsoleInteraction import (\n",
    "    acquire_settings, nothing_done, print_results, print_section_beginning,\n",
    "    show_bears)\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "from coalib.parsing.DefaultArgParser import default_arg_parser\n",
    "from coalib.settings.ConfigurationGathering import load_configuration\n",
    "from coalib.settings.SectionFilling import fill_settings\n",
    "\n",
    "\n",
    "def main():\n",
    "    # Note: We parse the args here once to check whether to show bears or not.\n",
    "    arg_parser = default_arg_parser()\n",
    "    args = arg_parser.parse_args()\n",
    "\n",
    "    console_printer = ConsolePrinter()\n",
    "    if args.show_bears or args.show_all_bears or args.show_language_bears:\n",
    "        log_printer = LogPrinter(console_printer)\n",
    "        try:\n",
    "            sections, _ = load_configuration(arg_list=None,\n",
    "                                             log_printer=log_printer)\n",
    "            if args.show_language_bears:\n",
    "                local_bears, global_bears = collect_all_bears_from_sections(\n",
    "                    sections, log_printer)\n",
    "                local_bears = filter_section_bears_by_languages(\n",
    "                    local_bears, args.show_language_bears)\n",
    "                global_bears = filter_section_bears_by_languages(\n",
    "                    global_bears, args.show_language_bears)\n",
    "            elif args.show_all_bears:\n",
    "                local_bears, global_bears = collect_all_bears_from_sections(\n",
    "                    sections, log_printer)\n",
    "            else:\n",
    "                # We ignore missing settings as it's not important.\n",
    "                local_bears, global_bears = fill_settings(\n",
    "                    sections,\n",
    "                    acquire_settings=lambda *args, **kwargs: {},\n",
    "                    log_printer=log_printer)\n",
    "            show_bears(local_bears, global_bears,\n",
    "                       args.show_language_bears or args.show_all_bears,\n",
    "                       console_printer)\n",
    "        except BaseException as exception:  # pylint: disable=broad-except\n",
    "            return get_exitcode(exception, log_printer)\n",
    "        return 0\n",
    "\n",
    "    partial_print_sec_beg = functools.partial(\n",
    "        print_section_beginning,\n",
    "        console_printer)\n",
    "    results, exitcode, _ = run_coala(\n",
    "        print_results=print_results,\n",
    "        acquire_settings=acquire_settings,\n",
    "        print_section_beginning=partial_print_sec_beg,\n",
    "        nothing_done=nothing_done)\n",
    "\n",
    "    return exitcode\n"
  ],
  "/home/tushar/coala/coalib/coala_ci.py": [
    "# This program is free software: you can redistribute it and/or modify it\n",
    "# under the terms of the GNU Affero General Public License as published by the\n",
    "# Free Software Foundation, either version 3 of the License, or (at your\n",
    "# option) any later version.\n",
    "#\n",
    "# This program is distributed in the hope that it will be useful, but WITHOUT\n",
    "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n",
    "# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License\n",
    "# for more details.\n",
    "#\n",
    "# You should have received a copy of the GNU Affero General Public License\n",
    "# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n",
    "\n",
    "import functools\n",
    "\n",
    "from pyprint.ConsolePrinter import ConsolePrinter\n",
    "\n",
    "from coalib.coala_main import run_coala\n",
    "from coalib.output.ConsoleInteraction import (\n",
    "    print_results_no_input, print_section_beginning)\n",
    "\n",
    "\n",
    "def main():\n",
    "    console_printer = ConsolePrinter()\n",
    "    partial_print_sec_beg = functools.partial(\n",
    "        print_section_beginning,\n",
    "        console_printer)\n",
    "    results, exitcode, _ = run_coala(\n",
    "        autoapply=False,\n",
    "        print_results=print_results_no_input,\n",
    "        print_section_beginning=partial_print_sec_beg)\n",
    "\n",
    "    return exitcode\n"
  ],
  "/home/tushar/coala/coalib/coala_dbus.py": [
    "#!/usr/bin/env python3\n",
    "\n",
    "# This program is free software: you can redistribute it and/or modify it\n",
    "# under the terms of the GNU Affero General Public License as published by the\n",
    "# Free Software Foundation, either version 3 of the License, or (at your\n",
    "# option) any later version.\n",
    "#\n",
    "# This program is distributed in the hope that it will be useful, but WITHOUT\n",
    "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n",
    "# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License\n",
    "# for more details.\n",
    "#\n",
    "# You should have received a copy of the GNU Affero General Public License\n",
    "# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n",
    "\n",
    "import sys\n",
    "\n",
    "import dbus\n",
    "import dbus.mainloop.glib\n",
    "from coalib.misc import Constants\n",
    "from coalib.output.dbus.DbusServer import DbusServer\n",
    "from gi.repository import GLib\n",
    "\n",
    "\n",
    "def sys_clean_exit():\n",
    "    sys.exit(0)\n",
    "\n",
    "\n",
    "def on_disconnected():\n",
    "    return GLib.idle_add(sys_clean_exit)\n",
    "\n",
    "\n",
    "def main():\n",
    "    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)\n",
    "\n",
    "    session_bus = dbus.SessionBus()\n",
    "    # The BusName needs to be saved to a variable, if it is not saved - the\n",
    "    # Bus will be closed.\n",
    "    dbus_name = dbus.service.BusName(  # pylint: disable=unused-variable\n",
    "        Constants.BUS_NAME,\n",
    "        session_bus)\n",
    "    DbusServer(session_bus,\n",
    "               '/org/coala_analyzer/v1',\n",
    "               on_disconnected=on_disconnected)\n",
    "\n",
    "    mainloop = GLib.MainLoop()\n",
    "    mainloop.run()\n"
  ],
  "/home/tushar/coala/coalib/coala_delete_orig.py": [
    "import os\n",
    "\n",
    "from pyprint.ConsolePrinter import ConsolePrinter\n",
    "\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "from coalib.parsing import Globbing\n",
    "from coalib.settings.ConfigurationGathering import get_config_directory\n",
    "from coalib.settings.Section import Section\n",
    "from coalib.parsing.Globbing import glob_escape\n",
    "\n",
    "\n",
    "def main(log_printer=None, section: Section=None):\n",
    "    start_path = get_config_directory(section)\n",
    "    log_printer = log_printer or LogPrinter(ConsolePrinter())\n",
    "\n",
    "    if start_path is None:\n",
    "        return 255\n",
    "\n",
    "    # start_path may have unintended glob characters\n",
    "    orig_files = Globbing.glob(os.path.join(\n",
    "        glob_escape(start_path), '**', '*.orig'))\n",
    "\n",
    "    not_deleted = 0\n",
    "    for ofile in orig_files:\n",
    "        log_printer.info(\"Deleting old backup file... \"\n",
    "                         + os.path.relpath(ofile))\n",
    "        try:\n",
    "            os.remove(ofile)\n",
    "        except OSError as oserror:\n",
    "            not_deleted += 1\n",
    "            log_printer.warn(\"Couldn't delete {}. {}\".format(\n",
    "                os.path.relpath(ofile), oserror.strerror))\n",
    "\n",
    "    if not_deleted:\n",
    "        log_printer.warn(str(not_deleted) + \" .orig backup files could not be\"\n",
    "                         \" deleted, possibly because you lack the permission\"\n",
    "                         \" to do so. coala may not be able to create\"\n",
    "                         \" backup files when patches are applied.\")\n",
    "    return 0\n"
  ],
  "/home/tushar/coala/coalib/coala_format.py": [
    "# This program is free software: you can redistribute it and/or modify it\n",
    "# under the terms of the GNU Affero General Public License as published by the\n",
    "# Free Software Foundation, either version 3 of the License, or (at your\n",
    "# option) any later version.\n",
    "#\n",
    "# This program is distributed in the hope that it will be useful, but WITHOUT\n",
    "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n",
    "# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License\n",
    "# for more details.\n",
    "#\n",
    "# You should have received a copy of the GNU Affero General Public License\n",
    "# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n",
    "\n",
    "from coalib.coala_main import run_coala\n",
    "from coalib.output.ConsoleInteraction import print_results_formatted\n",
    "\n",
    "\n",
    "def main():\n",
    "    results, exitcode, _ = run_coala(print_results=print_results_formatted)\n",
    "\n",
    "    return exitcode\n"
  ],
  "/home/tushar/coala/coalib/coala_json.py": [
    "# This program is free software: you can redistribute it and/or modify it\n",
    "# under the terms of the GNU Affero General Public License as published by the\n",
    "# Free Software Foundation, either version 3 of the License, or (at your\n",
    "# option) any later version.\n",
    "#\n",
    "# This program is distributed in the hope that it will be useful, but WITHOUT\n",
    "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n",
    "# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License\n",
    "# for more details.\n",
    "#\n",
    "# You should have received a copy of the GNU Affero General Public License\n",
    "# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n",
    "\n",
    "import json\n",
    "\n",
    "from coalib.coala_main import run_coala\n",
    "from coalib.output.JSONEncoder import create_json_encoder\n",
    "from coalib.output.printers.ListLogPrinter import ListLogPrinter\n",
    "from coalib.parsing.DefaultArgParser import default_arg_parser\n",
    "\n",
    "\n",
    "def main():\n",
    "    # Note: We parse the args here once to find the log printer to use.\n",
    "    #       Also, commands like -h (help) and -v (version) are executed here.\n",
    "    #       The args are again parsed later to find the settings and configs\n",
    "    #       to use during analysis.\n",
    "    arg_parser = default_arg_parser()\n",
    "    args = arg_parser.parse_args()\n",
    "\n",
    "    log_printer = None if args.text_logs else ListLogPrinter()\n",
    "    results, exitcode, _ = run_coala(log_printer=log_printer, autoapply=False)\n",
    "\n",
    "    retval = {\"results\": results}\n",
    "    if not args.text_logs:\n",
    "        retval[\"logs\"] = log_printer.logs\n",
    "    JSONEncoder = create_json_encoder(use_relpath=args.relpath)\n",
    "    if args.output:\n",
    "        filename = str(args.output)\n",
    "        with open(filename, 'w+') as fp:\n",
    "            json.dump(retval, fp,\n",
    "                      cls=JSONEncoder,\n",
    "                      sort_keys=True,\n",
    "                      indent=2,\n",
    "                      separators=(',', ': '))\n",
    "    else:\n",
    "        print(json.dumps(retval,\n",
    "                         cls=JSONEncoder,\n",
    "                         sort_keys=True,\n",
    "                         indent=2,\n",
    "                         separators=(',', ': ')))\n",
    "\n",
    "    return exitcode\n"
  ],
  "/home/tushar/coala/coalib/coala_main.py": [
    "import os\n",
    "import platform\n",
    "\n",
    "import pip\n",
    "from pyprint.ConsolePrinter import ConsolePrinter\n",
    "\n",
    "from coalib import coala_delete_orig, VERSION\n",
    "from coalib.misc.Exceptions import get_exitcode\n",
    "from coalib.output.Interactions import fail_acquire_settings\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "from coalib.output.Tagging import delete_tagged_results, tag_results\n",
    "from coalib.processes.Processing import execute_section, simplify_section_result\n",
    "from coalib.settings.ConfigurationGathering import gather_configuration\n",
    "\n",
    "do_nothing = lambda *args: True\n",
    "\n",
    "\n",
    "def run_coala(log_printer=None,\n",
    "              print_results=do_nothing,\n",
    "              acquire_settings=fail_acquire_settings,\n",
    "              print_section_beginning=do_nothing,\n",
    "              nothing_done=do_nothing,\n",
    "              autoapply=True,\n",
    "              arg_parser=None):\n",
    "    \"\"\"\n",
    "    This is a main method that should be usable for almost all purposes and\n",
    "    reduces executing coala to one function call.\n",
    "\n",
    "    :param log_printer:             A LogPrinter object to use for logging.\n",
    "    :param print_results:           A callback that takes a LogPrinter, a\n",
    "                                    section, a list of results to be printed,\n",
    "                                    the file dict and the mutable file diff\n",
    "                                    dict.\n",
    "    :param acquire_settings:        The method to use for requesting settings.\n",
    "                                    It will get a parameter which is a\n",
    "                                    dictionary with the settings name as key\n",
    "                                    and a list containing a description in [0]\n",
    "                                    and the names of the bears who need this\n",
    "                                    setting in all following indexes.\n",
    "    :param print_section_beginning: A callback that will be called with a\n",
    "                                    section name string whenever analysis of a\n",
    "                                    new section is started.\n",
    "    :param nothing_done:            A callback that will be called with only a\n",
    "                                    log printer that shall indicate that\n",
    "                                    nothing was done.\n",
    "    :param autoapply:               Set to False to autoapply nothing by\n",
    "                                    default; this is overridable via any\n",
    "                                    configuration file/CLI.\n",
    "    :return:                        A dictionary containing a list of results\n",
    "                                    for all analyzed sections as key.\n",
    "    \"\"\"\n",
    "    log_printer = log_printer or LogPrinter(ConsolePrinter())\n",
    "\n",
    "    exitcode = 0\n",
    "    results = {}\n",
    "    file_dicts = {}\n",
    "    try:\n",
    "        yielded_results = yielded_unfixed_results = False\n",
    "        did_nothing = True\n",
    "        sections, local_bears, global_bears, targets = gather_configuration(\n",
    "            acquire_settings,\n",
    "            log_printer,\n",
    "            autoapply=autoapply,\n",
    "            arg_parser=arg_parser)\n",
    "\n",
    "        log_printer.debug(\"Platform {} -- Python {}, pip {}, coalib {}\"\n",
    "                          .format(platform.system(), platform.python_version(),\n",
    "                                  pip.__version__, VERSION))\n",
    "\n",
    "        tag = str(sections['default'].get('tag', None))\n",
    "        dtag = str(sections['default'].get('dtag', None))\n",
    "        config_file = os.path.abspath(str(sections[\"default\"].get(\"config\")))\n",
    "\n",
    "        # Deleting all .orig files, so the latest files are up to date!\n",
    "        coala_delete_orig.main(log_printer, sections[\"default\"])\n",
    "\n",
    "        delete_tagged_results(dtag, config_file, log_printer)\n",
    "\n",
    "        for section_name, section in sections.items():\n",
    "            if not section.is_enabled(targets):\n",
    "                continue\n",
    "\n",
    "            print_section_beginning(section)\n",
    "            section_result = execute_section(\n",
    "                section=section,\n",
    "                global_bear_list=global_bears[section_name],\n",
    "                local_bear_list=local_bears[section_name],\n",
    "                print_results=print_results,\n",
    "                log_printer=log_printer)\n",
    "            yielded, yielded_unfixed, results[section_name] = (\n",
    "                simplify_section_result(section_result))\n",
    "\n",
    "            yielded_results = yielded_results or yielded\n",
    "            yielded_unfixed_results = (\n",
    "                yielded_unfixed_results or yielded_unfixed)\n",
    "            did_nothing = False\n",
    "\n",
    "            file_dicts[section_name] = section_result[3]\n",
    "\n",
    "        tag_results(tag, config_file, results, log_printer)\n",
    "\n",
    "        if did_nothing:\n",
    "            nothing_done(log_printer)\n",
    "        elif yielded_unfixed_results:\n",
    "            exitcode = 1\n",
    "        elif yielded_results:\n",
    "            exitcode = 5\n",
    "    except BaseException as exception:  # pylint: disable=broad-except\n",
    "        exitcode = exitcode or get_exitcode(exception, log_printer)\n",
    "\n",
    "    return results, exitcode, file_dicts\n"
  ],
  "/home/tushar/coala/coalib/collecting/Collectors.py": [
    "import functools\n",
    "import os\n",
    "import pkg_resources\n",
    "import itertools\n",
    "from pyprint.NullPrinter import NullPrinter\n",
    "\n",
    "from coalib.bears.BEAR_KIND import BEAR_KIND\n",
    "from coalib.collecting.Importers import iimport_objects\n",
    "from coala_decorators.decorators import yield_once\n",
    "from coalib.output.printers.LOG_LEVEL import LOG_LEVEL\n",
    "from coalib.parsing.Globbing import fnmatch, iglob, glob_escape\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "\n",
    "\n",
    "def _get_kind(bear_class):\n",
    "    try:\n",
    "        return bear_class.kind()\n",
    "    except NotImplementedError:\n",
    "        return None\n",
    "\n",
    "\n",
    "def _import_bears(file_path, kinds):\n",
    "    # recursive imports:\n",
    "    for bear_list in iimport_objects(file_path,\n",
    "                                     names='__additional_bears__',\n",
    "                                     types=list):\n",
    "        for bear_class in bear_list:\n",
    "            if _get_kind(bear_class) in kinds:\n",
    "                yield bear_class\n",
    "    # normal import\n",
    "    for bear_class in iimport_objects(file_path,\n",
    "                                      attributes='kind',\n",
    "                                      local=True):\n",
    "        if _get_kind(bear_class) in kinds:\n",
    "            yield bear_class\n",
    "\n",
    "\n",
    "@yield_once\n",
    "def icollect(file_paths, ignored_globs=None):\n",
    "    \"\"\"\n",
    "    Evaluate globs in file paths and return all matching files.\n",
    "\n",
    "    :param file_paths:    file path or list of such that can include globs\n",
    "    :param ignored_globs: list of globs to ignore when matching files\n",
    "    :return:              iterator that yields tuple of path of a matching\n",
    "                          file, the glob where it was found\n",
    "    \"\"\"\n",
    "    if isinstance(file_paths, str):\n",
    "        file_paths = [file_paths]\n",
    "\n",
    "    for file_path in file_paths:\n",
    "        for match in iglob(file_path):\n",
    "            if not ignored_globs or not fnmatch(match, ignored_globs):\n",
    "                yield match, file_path\n",
    "\n",
    "\n",
    "def collect_files(file_paths, log_printer, ignored_file_paths=None,\n",
    "                  limit_file_paths=None):\n",
    "    \"\"\"\n",
    "    Evaluate globs in file paths and return all matching files\n",
    "\n",
    "    :param file_paths:         file path or list of such that can include globs\n",
    "    :param ignored_file_paths: list of globs that match to-be-ignored files\n",
    "    :param limit_file_paths:   list of globs that the files are limited to\n",
    "    :return:                   list of paths of all matching files\n",
    "    \"\"\"\n",
    "    limit_fnmatch = (functools.partial(fnmatch, patterns=limit_file_paths)\n",
    "                     if limit_file_paths else lambda fname: True)\n",
    "\n",
    "    valid_files = list(filter(lambda fname: os.path.isfile(fname[0]),\n",
    "                              icollect(file_paths, ignored_file_paths)))\n",
    "\n",
    "    # Find globs that gave no files and warn the user\n",
    "    if valid_files:\n",
    "        collected_files, file_globs_with_files = zip(*valid_files)\n",
    "    else:\n",
    "        collected_files, file_globs_with_files = [], []\n",
    "\n",
    "    _warn_if_unused_glob(log_printer, file_paths, file_globs_with_files,\n",
    "                         \"No files matching '{}' were found.\")\n",
    "    limited_files = list(filter(limit_fnmatch, collected_files))\n",
    "    return limited_files\n",
    "\n",
    "\n",
    "def collect_dirs(dir_paths, ignored_dir_paths=None):\n",
    "    \"\"\"\n",
    "    Evaluate globs in directory paths and return all matching directories\n",
    "\n",
    "    :param dir_paths:         file path or list of such that can include globs\n",
    "    :param ignored_dir_paths: list of globs that match to-be-ignored dirs\n",
    "    :return:                  list of paths of all matching directories\n",
    "    \"\"\"\n",
    "    valid_dirs = list(filter(lambda fname: os.path.isdir(fname[0]),\n",
    "                             icollect(dir_paths, ignored_dir_paths)))\n",
    "    if valid_dirs:\n",
    "        collected_dirs, _ = zip(*valid_dirs)\n",
    "        return list(collected_dirs)\n",
    "    else:\n",
    "        return []\n",
    "\n",
    "\n",
    "@yield_once\n",
    "def icollect_bears(bear_dirs, bear_globs, kinds, log_printer):\n",
    "    \"\"\"\n",
    "    Collect all bears from bear directories that have a matching kind.\n",
    "\n",
    "    :param bear_dirs:   directory name or list of such that can contain bears\n",
    "    :param bear_globs:  globs of bears to collect\n",
    "    :param kinds:       list of bear kinds to be collected\n",
    "    :param log_printer: log_printer to handle logging\n",
    "    :return:            iterator that yields a tuple with bear class and\n",
    "                        which bear_glob was used to find that bear class.\n",
    "    \"\"\"\n",
    "    for bear_dir, dir_glob in filter(lambda x: os.path.isdir(x[0]),\n",
    "                                     icollect(bear_dirs)):\n",
    "        # Since we get a real directory here and since we\n",
    "        # pass this later to iglob, we need to escape this.\n",
    "        bear_dir = glob_escape(bear_dir)\n",
    "        for bear_glob in bear_globs:\n",
    "            for matching_file in iglob(\n",
    "                    os.path.join(bear_dir, bear_glob + '.py')):\n",
    "\n",
    "                try:\n",
    "                    for bear in _import_bears(matching_file, kinds):\n",
    "                        yield bear, bear_glob\n",
    "                except pkg_resources.VersionConflict as exception:\n",
    "                    log_printer.log_exception(\n",
    "                        (\"Unable to collect bears from {file} because there \"\n",
    "                         \"is a conflict with the version of a dependency \"\n",
    "                         \"you have installed. This may be resolved by \"\n",
    "                         \"creating a separate virtual environment for coala \"\n",
    "                         \"or running `pip install {pkg}`. Be aware that the \"\n",
    "                         \"latter solution might break other python packages \"\n",
    "                         \"that depend on the currently installed \"\n",
    "                         \"version.\").format(file=matching_file,\n",
    "                                            pkg=exception.req),\n",
    "                        exception, log_level=LOG_LEVEL.WARNING)\n",
    "                except BaseException as exception:\n",
    "                    log_printer.log_exception(\n",
    "                        \"Unable to collect bears from {file}. Probably the \"\n",
    "                        \"file is malformed or the module code raises an \"\n",
    "                        \"exception.\".format(file=matching_file),\n",
    "                        exception,\n",
    "                        log_level=LOG_LEVEL.WARNING)\n",
    "\n",
    "\n",
    "def collect_bears(bear_dirs, bear_globs, kinds, log_printer,\n",
    "                  warn_if_unused_glob=True):\n",
    "    \"\"\"\n",
    "    Collect all bears from bear directories that have a matching kind\n",
    "    matching the given globs.\n",
    "\n",
    "    :param bear_dirs:           Directory name or list of such that can contain\n",
    "                                bears.\n",
    "    :param bear_globs:          Globs of bears to collect.\n",
    "    :param kinds:               List of bear kinds to be collected.\n",
    "    :param log_printer:         LogPrinter to handle logging.\n",
    "    :param warn_if_unused_glob: True if warning message should be shown if a\n",
    "                                glob didn't give any bears.\n",
    "    :return:                    Tuple of list of matching bear classes based on\n",
    "                                kind. The lists are in the same order as kinds.\n",
    "    \"\"\"\n",
    "    bears_found = tuple([] for i in range(len(kinds)))\n",
    "    bear_globs_with_bears = set()\n",
    "    for bear, glob in icollect_bears(bear_dirs, bear_globs, kinds, log_printer):\n",
    "        index = kinds.index(_get_kind(bear))\n",
    "        bears_found[index].append(bear)\n",
    "        bear_globs_with_bears.add(glob)\n",
    "\n",
    "    if warn_if_unused_glob:\n",
    "        _warn_if_unused_glob(log_printer, bear_globs, bear_globs_with_bears,\n",
    "                             \"No bears were found matching '{}'.\")\n",
    "    return bears_found\n",
    "\n",
    "\n",
    "def filter_section_bears_by_languages(bears, languages):\n",
    "    \"\"\"\n",
    "    Filters the bears by languages.\n",
    "\n",
    "    :param bears:       the dictionary of the sections as keys and list of\n",
    "                        bears as values.\n",
    "    :param languages:   languages that bears are being filtered on.\n",
    "    :return:            new dictionary with filtered out bears that don't match\n",
    "                        any language from languages.\n",
    "    \"\"\"\n",
    "    new_bears = {}\n",
    "    languages = set(x.lower() for x in languages)\n",
    "    for section in bears.keys():\n",
    "        filtered = []\n",
    "        for bear in bears[section]:\n",
    "            bear_languages = getattr(bear, 'LANGUAGES', tuple())\n",
    "            if isinstance(bear_languages, str):\n",
    "                bear_languages = (bear_languages,)\n",
    "            supported_languages = set(x.lower() for x in bear_languages)\n",
    "            if supported_languages & languages or 'all' in supported_languages:\n",
    "                filtered.append(bear)\n",
    "        new_bears[section] = filtered\n",
    "    return new_bears\n",
    "\n",
    "\n",
    "def get_all_bears_names():\n",
    "    from coalib.settings.Section import Section\n",
    "    printer = LogPrinter(NullPrinter())\n",
    "    local_bears, global_bears = collect_bears(\n",
    "        Section(\"\").bear_dirs(),\n",
    "        [\"**\"],\n",
    "        [BEAR_KIND.LOCAL, BEAR_KIND.GLOBAL],\n",
    "        printer,\n",
    "        warn_if_unused_glob=False)\n",
    "    return [bear.name for bear in itertools.chain(local_bears, global_bears)]\n",
    "\n",
    "\n",
    "def collect_all_bears_from_sections(sections, log_printer):\n",
    "    \"\"\"\n",
    "    Collect all kinds of bears from bear directories given in the sections.\n",
    "\n",
    "    :param bear_dirs:   directory name or list of such that can contain bears\n",
    "    :param log_printer: log_printer to handle logging\n",
    "    :return:            tuple of dictionaries of local and global bears\n",
    "                        The dictionary key is section class and\n",
    "                        dictionary value is a list of Bear classes\n",
    "    \"\"\"\n",
    "    local_bears = {}\n",
    "    global_bears = {}\n",
    "    for section in sections:\n",
    "        bear_dirs = sections[section].bear_dirs()\n",
    "        local_bears[section], global_bears[section] = collect_bears(\n",
    "            bear_dirs,\n",
    "            [\"**\"],\n",
    "            [BEAR_KIND.LOCAL, BEAR_KIND.GLOBAL],\n",
    "            log_printer,\n",
    "            warn_if_unused_glob=False)\n",
    "    return local_bears, global_bears\n",
    "\n",
    "\n",
    "def _warn_if_unused_glob(log_printer, globs, used_globs, message):\n",
    "    \"\"\"\n",
    "    Warn if a glob has not been used.\n",
    "\n",
    "    :param log_printer: The log_printer to handle logging.\n",
    "    :param globs:       List of globs that were expected to be used.\n",
    "    :param used_globs:  List of globs that were actually used.\n",
    "    :param message:     Warning message to display if a glob is unused.\n",
    "                        The glob which was unused will be added using\n",
    "                        .format()\n",
    "    \"\"\"\n",
    "    unused_globs = set(globs) - set(used_globs)\n",
    "    for glob in unused_globs:\n",
    "        log_printer.warn(message.format(glob))\n",
    "\n",
    "\n",
    "def collect_registered_bears_dirs(entrypoint):\n",
    "    \"\"\"\n",
    "    Searches setuptools for the entrypoint and returns the bear\n",
    "    directories given by the module.\n",
    "\n",
    "    :param entrypoint: The endpoint to find packages with.\n",
    "    :return:           List of bear directories.\n",
    "    \"\"\"\n",
    "    collected_dirs = []\n",
    "    for ep in pkg_resources.iter_entry_points(entrypoint):\n",
    "        registered_package = None\n",
    "        try:\n",
    "            registered_package = ep.load()\n",
    "        except pkg_resources.DistributionNotFound:\n",
    "            continue\n",
    "        collected_dirs.append(os.path.abspath(\n",
    "            os.path.dirname(registered_package.__file__)))\n",
    "    return collected_dirs\n"
  ],
  "/home/tushar/coala/coalib/collecting/Dependencies.py": [
    "class CircularDependencyError(Exception):\n",
    "\n",
    "    @classmethod\n",
    "    def for_bears(cls, bears):\n",
    "        \"\"\"\n",
    "        Creates the CircularDependencyError with a helpful message about the\n",
    "        dependency.\n",
    "        \"\"\"\n",
    "        bear_names = [bear.name for bear in bears]\n",
    "\n",
    "        return cls(\"Circular dependency detected: \" + \" -> \".join(bear_names))\n",
    "\n",
    "\n",
    "def _resolve(bears, resolved_bears, seen):\n",
    "    for bear in bears:\n",
    "        if bear in resolved_bears:\n",
    "            continue\n",
    "\n",
    "        missing = bear.missing_dependencies(resolved_bears)\n",
    "        if missing == []:\n",
    "            resolved_bears.append(bear)\n",
    "            continue\n",
    "\n",
    "        if bear in seen:\n",
    "            seen.append(bear)\n",
    "            raise CircularDependencyError.for_bears(seen)\n",
    "\n",
    "        seen.append(bear)\n",
    "        resolved_bears = _resolve(missing, resolved_bears, seen)\n",
    "        resolved_bears.append(bear)\n",
    "        seen.remove(bear)  # Already resolved, no candidate for circular dep\n",
    "\n",
    "    return resolved_bears\n",
    "\n",
    "\n",
    "def resolve(bears):\n",
    "    \"\"\"\n",
    "    Collects all dependencies of the given bears. This will also remove\n",
    "    duplicates.\n",
    "\n",
    "    :param bears: The given bears. Will not be modified.\n",
    "    :return:      The new list of bears, sorted so that it can be executed\n",
    "                  sequentially without dependency issues.\n",
    "    \"\"\"\n",
    "    return _resolve(bears, [], [])\n"
  ],
  "/home/tushar/coala/coalib/collecting/Importers.py": [
    "import inspect\n",
    "import os\n",
    "import platform\n",
    "import sys\n",
    "\n",
    "from coalib.misc.ContextManagers import suppress_stdout\n",
    "from coala_decorators.decorators import arguments_to_lists, yield_once\n",
    "\n",
    "\n",
    "def _import_module(file_path):\n",
    "    if not os.path.exists(file_path):\n",
    "        raise ImportError\n",
    "\n",
    "    module_name = os.path.splitext(os.path.basename(file_path))[0]\n",
    "    module_dir = os.path.dirname(file_path)\n",
    "\n",
    "    if module_dir not in sys.path:\n",
    "        sys.path.insert(0, module_dir)\n",
    "\n",
    "    # Ugly inconsistency: Python will insist on correctly cased module names\n",
    "    # independent of whether the OS is case-sensitive or not.\n",
    "    # We want all cases to match though.\n",
    "    if platform.system() == 'Windows':  # pragma: nocover\n",
    "        for cased_file_path in os.listdir(module_dir):\n",
    "            cased_module_name = os.path.splitext(cased_file_path)[0]\n",
    "            if cased_module_name.lower() == module_name.lower():\n",
    "                module_name = cased_module_name\n",
    "                break\n",
    "\n",
    "    return __import__(module_name)\n",
    "\n",
    "\n",
    "def _is_subclass(test_class, superclasses):\n",
    "    for superclass in superclasses:\n",
    "        try:\n",
    "            if issubclass(test_class, superclass):\n",
    "                return True\n",
    "        except TypeError:\n",
    "            pass\n",
    "    return False\n",
    "\n",
    "\n",
    "def _has_all(obj, attribute_names):\n",
    "    for attribute_name in attribute_names:\n",
    "        if not hasattr(obj, attribute_name):\n",
    "            return False\n",
    "    return True\n",
    "\n",
    "\n",
    "def object_defined_in(obj, file_path):\n",
    "    \"\"\"\n",
    "    Check if the object is defined in the given file.\n",
    "\n",
    "    >>> object_defined_in(object_defined_in, __file__)\n",
    "    True\n",
    "    >>> object_defined_in(object_defined_in, \"somewhere else\")\n",
    "    False\n",
    "\n",
    "    Builtins are always defined outside any given file:\n",
    "\n",
    "    >>> object_defined_in(False, __file__)\n",
    "    False\n",
    "\n",
    "    :param obj:       The object to check.\n",
    "    :param file_path: The path it might be defined in.\n",
    "    :return:          True if the object is defined in the file.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        source = inspect.getfile(obj)\n",
    "        if (platform.system() == 'Windows' and\n",
    "                source.lower() == file_path.lower() or\n",
    "                source == file_path):\n",
    "            return True\n",
    "    except TypeError:  # Builtin values don't have a source location\n",
    "        pass\n",
    "\n",
    "    return False\n",
    "\n",
    "\n",
    "def _is_defined_in(obj, file_path):\n",
    "    \"\"\"\n",
    "    Check if a class is defined in the given file.\n",
    "\n",
    "    Any class is considered to be defined in the given file if any of it's\n",
    "    parent classes or the class itself is defined in it.\n",
    "    \"\"\"\n",
    "    if not inspect.isclass(obj):\n",
    "        return object_defined_in(obj, file_path)\n",
    "\n",
    "    for base in inspect.getmro(obj):\n",
    "        if object_defined_in(base, file_path):\n",
    "            return True\n",
    "\n",
    "    return False\n",
    "\n",
    "\n",
    "@arguments_to_lists\n",
    "@yield_once\n",
    "def _iimport_objects(file_paths, names, types, supers, attributes, local):\n",
    "    \"\"\"\n",
    "    Import all objects from the given modules that fulfill the requirements\n",
    "\n",
    "    :param file_paths: File path(s) from which objects will be imported\n",
    "    :param names:      Name(s) an objects need to have one of\n",
    "    :param types:      Type(s) an objects need to be out of\n",
    "    :param supers:     Class(es) objects need to be a subclass of\n",
    "    :param attributes: Attribute(s) an object needs to (all) have\n",
    "    :param local:      if True: Objects need to be defined in the file they\n",
    "                       appear in to be collected\n",
    "    :return:           iterator that yields all matching python objects\n",
    "    :raises Exception: Any exception that is thrown in module code or an\n",
    "                       ImportError if paths are erroneous.\n",
    "    \"\"\"\n",
    "    if (file_paths == [] or\n",
    "            (names == [] and\n",
    "             types == [] and\n",
    "             supers == [] and\n",
    "             attributes == [])):\n",
    "        raise StopIteration\n",
    "\n",
    "    for file_path in file_paths:\n",
    "        module = _import_module(file_path)\n",
    "        for obj_name, obj in inspect.getmembers(module):\n",
    "            if ((names == [] or obj_name in names) and\n",
    "                    (types == [] or isinstance(obj, tuple(types))) and\n",
    "                    (supers == [] or _is_subclass(obj, supers)) and\n",
    "                    (attributes == [] or _has_all(obj, attributes)) and\n",
    "                    (local[0] is False or _is_defined_in(obj, file_path))):\n",
    "                yield obj\n",
    "\n",
    "\n",
    "def iimport_objects(file_paths, names=None, types=None, supers=None,\n",
    "                    attributes=None, local=False, verbose=False):\n",
    "    \"\"\"\n",
    "    Import all objects from the given modules that fulfill the requirements\n",
    "\n",
    "    :param file_paths: File path(s) from which objects will be imported\n",
    "    :param names:      Name(s) an objects need to have one of\n",
    "    :param types:      Type(s) an objects need to be out of\n",
    "    :param supers:     Class(es) objects need to be a subclass of\n",
    "    :param attributes: Attribute(s) an object needs to (all) have\n",
    "    :param local:      if True: Objects need to be defined in the file they\n",
    "                       appear in to be collected\n",
    "    :return:           iterator that yields all matching python objects\n",
    "    :raises Exception: Any exception that is thrown in module code or an\n",
    "                       ImportError if paths are erroneous.\n",
    "    \"\"\"\n",
    "    if not verbose:\n",
    "        with suppress_stdout():\n",
    "            for obj in _iimport_objects(file_paths, names, types, supers,\n",
    "                                        attributes, local):\n",
    "                yield obj\n",
    "    else:\n",
    "        for obj in _iimport_objects(file_paths, names, types, supers,\n",
    "                                    attributes, local):\n",
    "            yield obj\n",
    "\n",
    "\n",
    "def import_objects(file_paths, names=None, types=None, supers=None,\n",
    "                   attributes=None, local=False, verbose=False):\n",
    "    \"\"\"\n",
    "    Import all objects from the given modules that fulfill the requirements\n",
    "\n",
    "    :param file_paths: File path(s) from which objects will be imported\n",
    "    :param names:      Name(s) an objects need to have one of\n",
    "    :param types:      Type(s) an objects need to be out of\n",
    "    :param supers:     Class(es) objects need to be a subclass of\n",
    "    :param attributes: Attribute(s) an object needs to (all) have\n",
    "    :param local:      if True: Objects need to be defined in the file they\n",
    "                       appear in to be collected\n",
    "    :return:           list of all matching python objects\n",
    "    :raises Exception: Any exception that is thrown in module code or an\n",
    "                       ImportError if paths are erroneous.\n",
    "    \"\"\"\n",
    "    return list(iimport_objects(file_paths, names, types, supers, attributes,\n",
    "                                local, verbose))\n"
  ],
  "/home/tushar/coala/coalib/collecting/__init__.py": [],
  "/home/tushar/coala/coalib/misc/Annotations.py": [
    "def typechain(*args):\n",
    "    \"\"\"\n",
    "    Returns function which applies the first transformation it can from args\n",
    "    and returns transformed value, or the value itself if it is in args.\n",
    "\n",
    "    >>> function = typechain(int, 'a', ord, None)\n",
    "    >>> function(\"10\")\n",
    "    10\n",
    "    >>> function(\"b\")\n",
    "    98\n",
    "    >>> function(\"a\")\n",
    "    'a'\n",
    "    >>> function(int)\n",
    "    <class 'int'>\n",
    "    >>> function(None) is None\n",
    "    True\n",
    "    >>> function(\"str\")\n",
    "    Traceback (most recent call last):\n",
    "        ...\n",
    "    ValueError: Couldn't convert value 'str' to any specified type or find it \\\n",
    "in specified values.\n",
    "\n",
    "    :raises TypeError:  Raises when either no functions are specified for\n",
    "                        checking.\n",
    "    \"\"\"\n",
    "    if len(args) == 0:\n",
    "        raise TypeError(\"No arguments were provided.\")\n",
    "\n",
    "    def annotation(value):\n",
    "        \"\"\"\n",
    "        Returns value either transformed with one of the function in args, or\n",
    "        casted to one of types in args, or the value itself if it is in the\n",
    "        args.\n",
    "\n",
    "        :raises ValueError: Raises when cannot transform value in any one of\n",
    "                            specified ways.\n",
    "        \"\"\"\n",
    "        for arg in args:\n",
    "            if value == arg:\n",
    "                return value\n",
    "            if isinstance(arg, type) and isinstance(value, arg):\n",
    "                return value\n",
    "            try:\n",
    "                return arg(value)\n",
    "            except (ValueError, TypeError):\n",
    "                pass\n",
    "        raise ValueError(\n",
    "            \"Couldn't convert value {!r} to any specified type \"\n",
    "            \"or find it in specified values.\".format(value))\n",
    "    return annotation\n"
  ],
  "/home/tushar/coala/coalib/misc/BuildManPage.py": [
    "import argparse\n",
    "import datetime\n",
    "from distutils.core import Command\n",
    "from distutils.errors import DistutilsOptionError\n",
    "\n",
    "\n",
    "class BuildManPage(Command):\n",
    "    \"\"\"\n",
    "    Add a ``build_manpage`` command  to your setup.py.\n",
    "    To use this Command class add a command to call this class::\n",
    "\n",
    "        # For setuptools\n",
    "        setup(\n",
    "              entry_points={\n",
    "                \"distutils.commands\": [\n",
    "                    \"build_manpage = coalib.misc.BuildManPage:BuildManPage\"\n",
    "                ]\n",
    "              }\n",
    "        )\n",
    "\n",
    "        # For distutils\n",
    "        from coalib.misc.BuildManPage import BuildManPage\n",
    "        setup(\n",
    "              cmdclass={'build_manpage': BuildManPage}\n",
    "        )\n",
    "\n",
    "    You can then use the following setup command to produce a man page::\n",
    "\n",
    "        $ python setup.py build_manpage --output=coala.1 \\\n",
    "            --parser=coalib.parsing.DefaultArgParser:default_arg_parser\n",
    "\n",
    "    If automatically want to build the man page every time you invoke\n",
    "    your build, add to your ```setup.cfg``` the following::\n",
    "\n",
    "        [build_manpage]\n",
    "        output = <appname>.1\n",
    "        parser = <path_to_your_parser>\n",
    "    \"\"\"\n",
    "    user_options = [\n",
    "        ('output=', 'O', 'output file'),\n",
    "        ('parser=', None, 'module path to an ArgumentParser instance'\n",
    "         '(e.g. mymod:func, where func is a method or function which return'\n",
    "         'an arparse.ArgumentParser instance.'),\n",
    "    ]\n",
    "\n",
    "    def initialize_options(self):\n",
    "        self.output = None\n",
    "        self.parser = None\n",
    "\n",
    "    def finalize_options(self):\n",
    "        if self.output is None:\n",
    "            raise DistutilsOptionError('\\'output\\' option is required')\n",
    "        if self.parser is None:\n",
    "            raise DistutilsOptionError('\\'parser\\' option is required')\n",
    "        mod_name, func_name = self.parser.split(':')\n",
    "        fromlist = mod_name.split('.')\n",
    "        mod = __import__(mod_name, fromlist=fromlist)\n",
    "        self._parser = (\n",
    "            getattr(mod, func_name)(formatter_class=ManPageFormatter))\n",
    "\n",
    "        self.announce('Writing man page %s' % self.output)\n",
    "        self._today = datetime.date.today()\n",
    "\n",
    "    def run(self):\n",
    "        dist = self.distribution\n",
    "        homepage = dist.get_url()\n",
    "        maintainer = dist.get_maintainer()\n",
    "        _license = dist.get_license()\n",
    "        appname = self._parser.prog\n",
    "\n",
    "        sections = {\"see also\": (\"Online documentation: {}\".format(homepage)),\n",
    "                    \"maintainer(s)\": maintainer,\n",
    "                    \"license\": _license}\n",
    "\n",
    "        dist = self.distribution\n",
    "        mpf = ManPageFormatter(appname,\n",
    "                               desc=dist.get_description(),\n",
    "                               long_desc=dist.get_long_description(),\n",
    "                               ext_sections=sections,\n",
    "                               parser=self._parser)\n",
    "\n",
    "        formatted_man_page = mpf.format_man_page()\n",
    "\n",
    "        with open(self.output, 'w') as man_file:\n",
    "            man_file.write(formatted_man_page)\n",
    "\n",
    "\n",
    "class ManPageFormatter(argparse.HelpFormatter):\n",
    "\n",
    "    def __init__(self,\n",
    "                 prog,\n",
    "                 indent_increment=2,\n",
    "                 max_help_position=24,\n",
    "                 width=None,\n",
    "                 desc=None,\n",
    "                 long_desc=None,\n",
    "                 ext_sections=None,\n",
    "                 parser=None):\n",
    "        argparse.HelpFormatter.__init__(self, prog)\n",
    "\n",
    "        self._prog = prog\n",
    "        self._section = 1\n",
    "        self._today = datetime.date.today().strftime('%Y\\\\-%m\\\\-%d')\n",
    "        self._desc = desc\n",
    "        self._long_desc = long_desc\n",
    "        self._ext_sections = ext_sections\n",
    "        self._parser = parser\n",
    "\n",
    "    def _format_action_invocation(self, action):\n",
    "        if not action.option_strings:\n",
    "            metavar, = self._metavar_formatter(action, action.dest)(1)\n",
    "            return metavar\n",
    "\n",
    "        else:\n",
    "            # if the Optional doesn't take a value, format is:\n",
    "            #    -s, --long\n",
    "            if action.nargs == 0:\n",
    "                parts = [ManPageFormatter._bold(action_str)\n",
    "                         for action_str in action.option_strings]\n",
    "\n",
    "            # if the Optional takes a value, format is:\n",
    "            #    -s ARGS, --long ARGS\n",
    "            else:\n",
    "                default = ManPageFormatter._underline(action.dest.upper())\n",
    "                args_string = self._format_args(action, default)\n",
    "                parts = ['%s %s' % (self._bold(option_string), args_string)\n",
    "                         for option_string in action.option_strings]\n",
    "\n",
    "            return ', '.join(parts)\n",
    "\n",
    "    @staticmethod\n",
    "    def _markup(string):\n",
    "        return string.replace('-', '\\\\-')\n",
    "\n",
    "    @staticmethod\n",
    "    def _add_format(string, front, back):\n",
    "        if not string.strip().startswith(front):\n",
    "            string = front + string\n",
    "        if not string.strip().endswith(back):\n",
    "            string = string + back\n",
    "        return string\n",
    "\n",
    "    @staticmethod\n",
    "    def _underline(string):\n",
    "        return ManPageFormatter._add_format(string, \"\\\\fI\", \"\\\\fR\")\n",
    "\n",
    "    @staticmethod\n",
    "    def _bold(string):\n",
    "        return ManPageFormatter._add_format(string, \"\\\\fB\", \"\\\\fR\")\n",
    "\n",
    "    def _mk_title(self):\n",
    "        return '.TH {0} {1} {2}\\n'.format(self._prog,\n",
    "                                          self._section,\n",
    "                                          self._today)\n",
    "\n",
    "    def _mk_name(self):\n",
    "        return '.SH NAME\\n%s\\n' % (self._parser.prog)\n",
    "\n",
    "    def _mk_synopsis(self):\n",
    "        self.add_usage(self._parser.usage,\n",
    "                       self._parser._actions,\n",
    "                       self._parser._mutually_exclusive_groups,\n",
    "                       prefix='')\n",
    "        usage = self._format_usage(None,\n",
    "                                   self._parser._actions,\n",
    "                                   self._parser._mutually_exclusive_groups,\n",
    "                                   '')\n",
    "\n",
    "        usage = usage.replace('%s ' % self._prog, '')\n",
    "        usage = ('.SH SYNOPSIS\\n \\\\fB%s\\\\fR %s\\n'\n",
    "                 % (ManPageFormatter._markup(self._prog), usage))\n",
    "        return usage\n",
    "\n",
    "    def _mk_description(self):\n",
    "        if self._long_desc:\n",
    "            long_desc = self._long_desc.replace('\\n', '\\n.br\\n')\n",
    "            return '.SH DESCRIPTION\\n%s\\n' % self._markup(long_desc)\n",
    "        else:\n",
    "            return ''\n",
    "\n",
    "    def _mk_options(self):\n",
    "        formatter = self._parser._get_formatter()\n",
    "\n",
    "        # positionals, optionals and user-defined groups\n",
    "        for action_group in self._parser._action_groups:\n",
    "            formatter.start_section(None)\n",
    "            formatter.add_text(None)\n",
    "            formatter.add_arguments(action_group._group_actions)\n",
    "            formatter.end_section()\n",
    "\n",
    "        # epilog\n",
    "        formatter.add_text(self._parser.epilog)\n",
    "\n",
    "        # determine help from format above\n",
    "        return '.SH OPTIONS\\n' + formatter.format_help()\n",
    "\n",
    "    def _mk_footer(self):\n",
    "        sections = self._ext_sections\n",
    "        if not hasattr(sections, '__iter__'):\n",
    "            return ''\n",
    "\n",
    "        footer = []\n",
    "\n",
    "        for section in sorted(sections.keys()):\n",
    "            part = \".SH {}\\n {}\".format(section.upper(), sections[section])\n",
    "            footer.append(part)\n",
    "\n",
    "        return '\\n'.join(footer)\n",
    "\n",
    "    def format_man_page(self):\n",
    "        page = []\n",
    "        page.append(self._mk_title())\n",
    "        page.append(self._mk_name())\n",
    "        page.append(self._mk_synopsis())\n",
    "        page.append(self._mk_description())\n",
    "        page.append(self._mk_options())\n",
    "        page.append(self._mk_footer())\n",
    "\n",
    "        return ''.join(page)\n"
  ],
  "/home/tushar/coala/coalib/misc/Constants.py": [
    "# -*- coding: utf-8 -*-\n",
    "\n",
    "import appdirs\n",
    "import os\n",
    "import re\n",
    "\n",
    "# Start ignoring PyImportSortBear, PyLintBear as BUS_NAME is imported as a\n",
    "# constant from other files.\n",
    "from coalib import BUS_NAME\n",
    "from coalib import VERSION\n",
    "# Stop ignoring\n",
    "\n",
    "\n",
    "THIS_IS_A_BUG = (\"This is a bug. We are sorry for the inconvenience. \"\n",
    "                 \"Please contact the developers for assistance.\")\n",
    "\n",
    "CRASH_MESSAGE = (\"An unknown error occurred. This is a bug. We are \"\n",
    "                 \"sorry for the inconvenience. Please contact the \"\n",
    "                 \"developers for assistance. During execution of \"\n",
    "                 \"coala an exception was raised. This should never \"\n",
    "                 \"happen. When asked for, the following information \"\n",
    "                 \"may help investigating:\")\n",
    "\n",
    "VERSION_CONFLICT_MESSAGE = (\"There is a conflict in the version of a \"\n",
    "                            \"dependency you have installed and the \"\n",
    "                            \"requirements of coala. This may be resolved by \"\n",
    "                            \"creating a separate virtual environment for \"\n",
    "                            \"coala or running `pip install %s`. Be aware \"\n",
    "                            \"that the latter solution might break other \"\n",
    "                            \"python packages that depend on the currently \"\n",
    "                            \"installed version.\")\n",
    "\n",
    "OBJ_NOT_ACCESSIBLE = \"{} is not accessible and will be ignored!\"\n",
    "\n",
    "TRUE_STRINGS = ['1',\n",
    "                \"on\",\n",
    "                'y',\n",
    "                'yes',\n",
    "                \"yeah\",\n",
    "                \"sure\",\n",
    "                'true',\n",
    "                'definitely',\n",
    "                'yup',\n",
    "                \"right\"]\n",
    "\n",
    "FALSE_STRINGS = ['0',\n",
    "                 'off',\n",
    "                 'n',\n",
    "                 'no',\n",
    "                 'nope',\n",
    "                 'nah',\n",
    "                 'false',\n",
    "                 \"wrong\"]\n",
    "\n",
    "# This string contains many unicode characters to challenge tests.\n",
    "COMPLEX_TEST_STRING = (\"4 r34l ch4ll3n63: 123 \u00c4\u00d6\u00fc ABc @\u20ac\u00a5 \u00a7&% {[( \u2190\u2193\u2192\u2191 \"\n",
    "                       \"\u0126\u014a\u0127 \u00df\u00b0^ \\\\\\n\\u2192\")\n",
    "\n",
    "# Path to the coalib directory\n",
    "coalib_root = os.path.join(os.path.dirname(__file__),\n",
    "                           os.path.pardir)\n",
    "\n",
    "# Path to the language definition files\n",
    "language_definitions = os.path.join(coalib_root,\n",
    "                                    \"bearlib\",\n",
    "                                    \"languages\",\n",
    "                                    \"definitions\")\n",
    "\n",
    "system_coafile = os.path.join(coalib_root, \"default_coafile\")\n",
    "\n",
    "user_coafile = os.path.join(os.path.expanduser(\"~\"), \".coarc\")\n",
    "\n",
    "default_coafile = \".coafile\"\n",
    "\n",
    "TAGS_DIR = appdirs.user_data_dir('coala', version=VERSION)\n",
    "\n",
    "GLOBBING_SPECIAL_CHARS = \"()[]|?*\"\n",
    "\n",
    "URL_REGEX = re.compile(\n",
    "    r'^(?:(?:http|ftp)[s]?://)?'  # scheme\n",
    "    r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+'  # domain name\n",
    "    r'(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'\n",
    "    r'localhost|'  # OR localhost\n",
    "    r'(?:\\d{1,3}\\.){3}\\d{1,3})'  # OR an ip\n",
    "    r'(?::\\d+)?'  # optional port number\n",
    "    r'(?:/?|[/?]\\S+)$',  # path\n",
    "    re.IGNORECASE)\n"
  ],
  "/home/tushar/coala/coalib/misc/ContextManagers.py": [
    "import builtins\n",
    "import os\n",
    "import platform\n",
    "import signal\n",
    "import sys\n",
    "import tempfile\n",
    "import threading\n",
    "from contextlib import closing, contextmanager\n",
    "from io import StringIO\n",
    "\n",
    "from coalib.misc.MutableValue import MutableValue\n",
    "\n",
    "\n",
    "@contextmanager\n",
    "def subprocess_timeout(sub_process, seconds, kill_pg=False):\n",
    "    \"\"\"\n",
    "    Kill subprocess if the sub process takes more the than the timeout.\n",
    "\n",
    "    :param sub_process: The sub process to run.\n",
    "    :param seconds:     The number of seconds to allow the test to run for. If\n",
    "                        set to 0 or a negative value, it waits indefinitely.\n",
    "                        Floats can be used to specify units smaller than\n",
    "                        seconds.\n",
    "    :param kill_pg:     Boolean whether to kill the process group or only this\n",
    "                        process. (not applicable for windows)\n",
    "    \"\"\"\n",
    "    timedout = MutableValue(False)\n",
    "\n",
    "    if seconds <= 0:\n",
    "        yield timedout\n",
    "        return\n",
    "\n",
    "    finished = threading.Event()\n",
    "\n",
    "    if platform.system() == \"Windows\":  # pragma: no cover\n",
    "        kill_pg = False\n",
    "\n",
    "    def kill_it():\n",
    "        finished.wait(seconds)\n",
    "        if not finished.is_set():\n",
    "            timedout.value = True\n",
    "            if kill_pg:\n",
    "                pgid = os.getpgid(sub_process.pid)\n",
    "            os.kill(sub_process.pid, signal.SIGINT)\n",
    "            if kill_pg:\n",
    "                os.killpg(pgid, signal.SIGINT)\n",
    "\n",
    "    thread = threading.Thread(name='timeout-killer', target=kill_it)\n",
    "    try:\n",
    "        thread.start()\n",
    "        yield timedout\n",
    "    finally:\n",
    "        finished.set()\n",
    "        thread.join()\n",
    "\n",
    "\n",
    "@contextmanager\n",
    "def replace_stdout(replacement):\n",
    "    \"\"\"\n",
    "    Replaces stdout with the replacement, yields back to the caller and then\n",
    "    reverts everything back.\n",
    "    \"\"\"\n",
    "    _stdout = sys.stdout\n",
    "    sys.stdout = replacement\n",
    "    try:\n",
    "        yield\n",
    "    finally:\n",
    "        sys.stdout = _stdout\n",
    "\n",
    "\n",
    "@contextmanager\n",
    "def replace_stderr(replacement):\n",
    "    \"\"\"\n",
    "    Replaces stderr with the replacement, yields back to the caller and then\n",
    "    reverts everything back.\n",
    "    \"\"\"\n",
    "    _stderr = sys.stderr\n",
    "    sys.stderr = replacement\n",
    "    try:\n",
    "        yield\n",
    "    finally:\n",
    "        sys.stderr = _stderr\n",
    "\n",
    "\n",
    "@contextmanager\n",
    "def suppress_stdout():\n",
    "    \"\"\"\n",
    "    Suppresses everything going to stdout.\n",
    "    \"\"\"\n",
    "    with open(os.devnull, \"w\") as devnull, replace_stdout(devnull):\n",
    "        yield\n",
    "\n",
    "\n",
    "@contextmanager\n",
    "def retrieve_stdout():\n",
    "    \"\"\"\n",
    "    Yields a StringIO object from which one can read everything that was\n",
    "    printed to stdout. (It won't be printed to the real stdout!)\n",
    "\n",
    "    Example usage:\n",
    "\n",
    "    with retrieve_stdout() as stdout:\n",
    "        print(\"something\")  # Won't print to the console\n",
    "        what_was_printed = stdout.getvalue()  # Save the value\n",
    "    \"\"\"\n",
    "    with closing(StringIO()) as sio, replace_stdout(sio):\n",
    "        oldprint = builtins.print\n",
    "        try:\n",
    "            # Overriding stdout doesn't work with libraries, this ensures even\n",
    "            # cached variables take this up. Well... it works.\n",
    "            def newprint(*args, **kwargs):\n",
    "                kwargs['file'] = sio\n",
    "                oldprint(*args, **kwargs)\n",
    "\n",
    "            builtins.print = newprint\n",
    "            yield sio\n",
    "        finally:\n",
    "            builtins.print = oldprint\n",
    "\n",
    "\n",
    "@contextmanager\n",
    "def retrieve_stderr():\n",
    "    \"\"\"\n",
    "    Yields a StringIO object from which one can read everything that was\n",
    "    printed to stderr. (It won't be printed to the real stderr!)\n",
    "\n",
    "    Example usage:\n",
    "\n",
    "    with retrieve_stderr() as stderr:\n",
    "        print(\"something\")  # Won't print to the console\n",
    "        what_was_printed = stderr.getvalue()  # Save the value\n",
    "    \"\"\"\n",
    "    with closing(StringIO()) as sio, replace_stderr(sio):\n",
    "        oldprint = builtins.print\n",
    "        try:\n",
    "            # Overriding stderr doesn't work with libraries, this ensures even\n",
    "            # cached variables take this up. Well... it works.\n",
    "            def newprint(*args, **kwargs):\n",
    "                kwargs['file'] = sio\n",
    "                oldprint(*args, **kwargs)\n",
    "\n",
    "            builtins.print = newprint\n",
    "            yield sio\n",
    "        finally:\n",
    "            builtins.print = oldprint\n",
    "\n",
    "\n",
    "@contextmanager\n",
    "def simulate_console_inputs(*inputs):\n",
    "    \"\"\"\n",
    "    Does some magic to simulate the given inputs to any calls to the ``input``\n",
    "    builtin. This yields back an InputGenerator object so you can check\n",
    "    which input was already used and append any additional inputs you want.\n",
    "    Example:\n",
    "\n",
    "        with simulate_console_inputs(0, 1, 2) as generator:\n",
    "            assert(input() == 0)\n",
    "            assert(generator.last_input == 0)\n",
    "            generator.inputs.append(3)\n",
    "            assert(input() == 1)\n",
    "            assert(input() == 2)\n",
    "            assert(input() == 3)\n",
    "            assert(generator.last_input == 3)\n",
    "\n",
    "    :param inputs:      Any inputs to simulate.\n",
    "    :raises ValueError: Raised when was asked for more input but there's no\n",
    "                        more provided.\n",
    "    \"\"\"\n",
    "    class InputGenerator:\n",
    "\n",
    "        def __init__(self, inputs):\n",
    "            self.last_input = -1\n",
    "            self.inputs = inputs\n",
    "\n",
    "        def generate_input(self, prompt=''):\n",
    "            print(prompt, end=\"\")\n",
    "            self.last_input += 1\n",
    "            try:\n",
    "                return self.inputs[self.last_input]\n",
    "            except IndexError:\n",
    "                raise ValueError(\"Asked for more input, but no more was \"\n",
    "                                 \"provided from `simulate_console_inputs`.\")\n",
    "\n",
    "    input_generator = InputGenerator(list(inputs))\n",
    "    _input = builtins.input\n",
    "    builtins.input = input_generator.generate_input\n",
    "    try:\n",
    "        yield input_generator\n",
    "    finally:\n",
    "        builtins.input = _input\n",
    "\n",
    "\n",
    "@contextmanager\n",
    "def make_temp(suffix=\"\", prefix=\"tmp\", dir=None):\n",
    "    \"\"\"\n",
    "    Creates a temporary file with a closed stream and deletes it when done.\n",
    "\n",
    "    :return: A contextmanager retrieving the file path.\n",
    "    \"\"\"\n",
    "    temporary = tempfile.mkstemp(suffix=suffix, prefix=prefix, dir=dir)\n",
    "    os.close(temporary[0])\n",
    "    try:\n",
    "        yield temporary[1]\n",
    "    finally:\n",
    "        os.remove(temporary[1])\n",
    "\n",
    "\n",
    "@contextmanager\n",
    "def prepare_file(lines,\n",
    "                 filename,\n",
    "                 force_linebreaks=True,\n",
    "                 create_tempfile=True,\n",
    "                 tempfile_kwargs={}):\n",
    "    \"\"\"\n",
    "    Can create a temporary file (if filename is None) with the lines.\n",
    "    Can also add a trailing newline to each line specified if needed.\n",
    "\n",
    "    :param lines:            The lines from the file. (list or tuple of strings)\n",
    "    :param filename:         The filename to be prepared.\n",
    "    :param force_linebreaks: Whether to append newlines at each line if needed.\n",
    "    :param create_tempfile:  Whether to save lines in tempfile if needed.\n",
    "    :param tempfile_kwargs:  Kwargs passed to tempfile.mkstemp().\n",
    "    \"\"\"\n",
    "    if force_linebreaks:\n",
    "        lines = type(lines)(line if line.endswith('\\n') else line+'\\n'\n",
    "                            for line in lines)\n",
    "\n",
    "    if not create_tempfile and filename is None:\n",
    "        filename = \"dummy_file_name\"\n",
    "\n",
    "    if not isinstance(filename, str) and create_tempfile:\n",
    "        with make_temp(**tempfile_kwargs) as filename:\n",
    "            with open(filename, 'w', encoding='utf-8') as file:\n",
    "                file.writelines(lines)\n",
    "            yield lines, filename\n",
    "    else:\n",
    "        yield lines, filename\n",
    "\n",
    "\n",
    "@contextmanager\n",
    "def change_directory(path):\n",
    "    old_dir = os.getcwd()\n",
    "    os.chdir(path)\n",
    "    try:\n",
    "        yield\n",
    "    finally:\n",
    "        os.chdir(old_dir)\n"
  ],
  "/home/tushar/coala/coalib/misc/DictUtilities.py": [
    "from collections import Iterable, OrderedDict\n",
    "\n",
    "\n",
    "def inverse_dicts(*dicts):\n",
    "    \"\"\"\n",
    "    Inverts the dicts, e.g. {1: 2, 3: 4} and {2: 3, 4: 4} will be inverted\n",
    "    {2: [1, 2], 4: [3, 4]}. This also handles dictionaries with Iterable items\n",
    "    as values e.g. {1: [1, 2, 3], 2: [3, 4, 5]} and\n",
    "    {2: [1], 3: [2], 4: [3, 4]} will be inverted to\n",
    "    {1: [1, 2], 2: [1, 3], 3: [1, 2, 4], 4: [2, 4], 5: [2]}.\n",
    "    No order is preserved.\n",
    "\n",
    "    :param dicts: The dictionaries to invert.\n",
    "    :return:      The inversed dictionary which merges all dictionaries into\n",
    "                  one.\n",
    "    \"\"\"\n",
    "    inverse = {}\n",
    "\n",
    "    for dictionary in dicts:\n",
    "        for key, value in dictionary.items():\n",
    "            if isinstance(value, Iterable):\n",
    "                for item in value:\n",
    "                    add_pair_to_dict(item, key, inverse)\n",
    "            else:\n",
    "                add_pair_to_dict(value, key, inverse)\n",
    "\n",
    "    return inverse\n",
    "\n",
    "\n",
    "def add_pair_to_dict(key, value, dictionary):\n",
    "    \"\"\"\n",
    "    Add (key, value) pair to the dictionary. The value is added to a list of\n",
    "    values for the key.\n",
    "    \"\"\"\n",
    "    if key in dictionary:\n",
    "        dictionary[key].append(value)\n",
    "    else:\n",
    "        dictionary[key] = [value]\n",
    "\n",
    "\n",
    "def update_ordered_dict_key(dictionary, old_key, new_key):\n",
    "    return OrderedDict(((new_key if k == old_key else k), v)\n",
    "                       for k, v in dictionary.items())\n"
  ],
  "/home/tushar/coala/coalib/misc/Enum.py": [
    "def enum(*sequential, **named):\n",
    "    enums = dict(zip(sequential, range(len(sequential))), **named)\n",
    "    str_dict = enums.copy()\n",
    "    enums['reverse'] = dict((value, key) for key, value in enums.items())\n",
    "    enums['str_dict'] = str_dict\n",
    "\n",
    "    return type('Enum', (), enums)\n"
  ],
  "/home/tushar/coala/coalib/misc/Exceptions.py": [
    "from pyprint.NullPrinter import NullPrinter\n",
    "\n",
    "from coalib.misc import Constants\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "\n",
    "from pkg_resources import VersionConflict\n",
    "\n",
    "\n",
    "def get_exitcode(exception, log_printer=None):\n",
    "    log_printer = log_printer or LogPrinter(NullPrinter())\n",
    "\n",
    "    if isinstance(exception, KeyboardInterrupt):  # Ctrl+C\n",
    "        print(\"Program terminated by user.\")\n",
    "        exitcode = 130\n",
    "    elif isinstance(exception, EOFError):  # Ctrl+D\n",
    "        print(\"Found EOF. Exiting gracefully.\")\n",
    "        exitcode = 0\n",
    "    elif isinstance(exception, SystemExit):\n",
    "        exitcode = exception.code\n",
    "    elif isinstance(exception, VersionConflict):\n",
    "        log_message = Constants.VERSION_CONFLICT_MESSAGE % str(exception.req)\n",
    "        log_printer.log_exception(log_message, exception)\n",
    "        exitcode = 13\n",
    "    elif isinstance(exception, BaseException):\n",
    "        log_printer.log_exception(Constants.CRASH_MESSAGE, exception)\n",
    "        exitcode = 255\n",
    "    else:\n",
    "        exitcode = 0\n",
    "\n",
    "    return exitcode\n"
  ],
  "/home/tushar/coala/coalib/misc/Future.py": [
    "from functools import partial\n",
    "import sys\n",
    "\n",
    "if sys.version_info < (3, 4):\n",
    "    # FIXME: Remove `partialmethod` when dropping Python 3.3 support.\n",
    "    # Copied from Python 3.4.3 (/Lib/functools.py)\n",
    "    class partialmethod(object):  # pragma: no cover\n",
    "        \"\"\"\n",
    "        Method descriptor with partial application of the given arguments\n",
    "        and keywords.\n",
    "\n",
    "        Supports wrapping existing descriptors and handles non-descriptor\n",
    "        callables as instance methods.\n",
    "        \"\"\"\n",
    "\n",
    "        def __init__(self, func, *args, **keywords):\n",
    "            if not callable(func) and not hasattr(func, \"__get__\"):\n",
    "                raise TypeError(\"{!r} is not callable or a descriptor\"\n",
    "                                .format(func))\n",
    "\n",
    "            # func could be a descriptor like classmethod which isn't callable,\n",
    "            # so we can't inherit from partial (it verifies func is callable)\n",
    "            if isinstance(func, partialmethod):\n",
    "                # flattening is mandatory in order to place cls/self before all\n",
    "                # other arguments\n",
    "                # it's also more efficient since only one function will be\n",
    "                # called\n",
    "                self.func = func.func\n",
    "                self.args = func.args + args\n",
    "                self.keywords = func.keywords.copy()\n",
    "                self.keywords.update(keywords)\n",
    "            else:\n",
    "                self.func = func\n",
    "                self.args = args\n",
    "                self.keywords = keywords\n",
    "\n",
    "        def __repr__(self):\n",
    "            args = \", \".join(map(repr, self.args))\n",
    "            keywords = \", \".join(\"{}={!r}\".format(k, v)\n",
    "                                 for k, v in self.keywords.items())\n",
    "            format_string = \"{module}.{cls}({func}, {args}, {keywords})\"\n",
    "            return format_string.format(module=self.__class__.__module__,\n",
    "                                        cls=self.__class__.__name__,\n",
    "                                        func=self.func,\n",
    "                                        args=args,\n",
    "                                        keywords=keywords)\n",
    "\n",
    "        def _make_unbound_method(self):\n",
    "            def _method(*args, **keywords):\n",
    "                call_keywords = self.keywords.copy()\n",
    "                call_keywords.update(keywords)\n",
    "                cls_or_self, *rest = args\n",
    "                call_args = (cls_or_self,) + self.args + tuple(rest)\n",
    "                return self.func(*call_args, **call_keywords)\n",
    "\n",
    "            _method.__isabstractmethod__ = self.__isabstractmethod__\n",
    "            _method._partialmethod = self\n",
    "            return _method\n",
    "\n",
    "        def __get__(self, obj, cls):\n",
    "            get = getattr(self.func, \"__get__\", None)\n",
    "            result = None\n",
    "            if get is not None:\n",
    "                new_func = get(obj, cls)\n",
    "                if new_func is not self.func:\n",
    "                    # Assume __get__ returning something new indicates the\n",
    "                    # creation of an appropriate callable\n",
    "                    result = partial(new_func, *self.args, **self.keywords)\n",
    "                    try:\n",
    "                        result.__self__ = new_func.__self__\n",
    "                    except AttributeError:\n",
    "                        pass\n",
    "            if result is None:\n",
    "                # If the underlying descriptor didn't do anything, treat this\n",
    "                # like an instance method\n",
    "                result = self._make_unbound_method().__get__(obj, cls)\n",
    "            return result\n",
    "\n",
    "        @property\n",
    "        def __isabstractmethod__(self):\n",
    "            return getattr(self.func, \"__isabstractmethod__\", False)\n",
    "else:\n",
    "    from functools import partialmethod\n"
  ],
  "/home/tushar/coala/coalib/misc/MutableValue.py": [
    "class MutableValue:\n",
    "\n",
    "    def __init__(self, val=None):\n",
    "        self.value = val\n"
  ],
  "/home/tushar/coala/coalib/misc/Shell.py": [
    "from contextlib import contextmanager\n",
    "import shlex\n",
    "from subprocess import PIPE, Popen\n",
    "\n",
    "\n",
    "@contextmanager\n",
    "def run_interactive_shell_command(command, **kwargs):\n",
    "    \"\"\"\n",
    "    Runs a single command in shell and provides stdout, stderr and stdin\n",
    "    streams.\n",
    "\n",
    "    This function creates a context manager that sets up the process (using\n",
    "    ``subprocess.Popen()``), returns to caller and waits for process to exit on\n",
    "    leaving.\n",
    "\n",
    "    By default the process is opened in ``universal_newlines`` mode and creates\n",
    "    pipes for all streams (stdout, stderr and stdin) using ``subprocess.PIPE``\n",
    "    special value. These pipes are closed automatically, so if you want to get\n",
    "    the contents of the streams you should retrieve them before the context\n",
    "    manager exits.\n",
    "\n",
    "    >>> with run_interactive_shell_command([\"echo\", \"TEXT\"]) as p:\n",
    "    ...     stdout = p.stdout\n",
    "    ...     stdout_text = stdout.read()\n",
    "    >>> stdout_text\n",
    "    'TEXT\\\\n'\n",
    "    >>> stdout.closed\n",
    "    True\n",
    "\n",
    "    Custom streams provided are not closed except of ``subprocess.PIPE``.\n",
    "\n",
    "    >>> from tempfile import TemporaryFile\n",
    "    >>> stream = TemporaryFile()\n",
    "    >>> with run_interactive_shell_command([\"echo\", \"TEXT\"],\n",
    "    ...                                    stdout=stream) as p:\n",
    "    ...     stderr = p.stderr\n",
    "    >>> stderr.closed\n",
    "    True\n",
    "    >>> stream.closed\n",
    "    False\n",
    "\n",
    "    :param command: The command to run on shell. This parameter can either\n",
    "                    be a sequence of arguments that are directly passed to\n",
    "                    the process or a string. A string gets splitted beforehand\n",
    "                    using ``shlex.split()``. If providing ``shell=True`` as a\n",
    "                    keyword-argument, no ``shlex.split()`` is performed and the\n",
    "                    command string goes directly to ``subprocess.Popen()``.\n",
    "    :param kwargs:  Additional keyword arguments to pass to\n",
    "                    ``subprocess.Popen`` that are used to spawn the process.\n",
    "    :return:        A context manager yielding the process started from the\n",
    "                    command.\n",
    "    \"\"\"\n",
    "    if not kwargs.get(\"shell\", False) and isinstance(command, str):\n",
    "        command = shlex.split(command)\n",
    "\n",
    "    args = {\"stdout\": PIPE,\n",
    "            \"stderr\": PIPE,\n",
    "            \"stdin\": PIPE,\n",
    "            \"universal_newlines\": True}\n",
    "    args.update(kwargs)\n",
    "\n",
    "    process = Popen(command, **args)\n",
    "    try:\n",
    "        yield process\n",
    "    finally:\n",
    "        if args[\"stdout\"] is PIPE:\n",
    "            process.stdout.close()\n",
    "        if args[\"stderr\"] is PIPE:\n",
    "            process.stderr.close()\n",
    "        if args[\"stdin\"] is PIPE:\n",
    "            process.stdin.close()\n",
    "\n",
    "        process.wait()\n",
    "\n",
    "\n",
    "def run_shell_command(command, stdin=None, **kwargs):\n",
    "    \"\"\"\n",
    "    Runs a single command in shell and returns the read stdout and stderr data.\n",
    "\n",
    "    This function waits for the process (created using ``subprocess.Popen()``)\n",
    "    to exit. Effectively it wraps ``run_interactive_shell_command()`` and uses\n",
    "    ``communicate()`` on the process.\n",
    "\n",
    "    See also ``run_interactive_shell_command()``.\n",
    "\n",
    "    :param command: The command to run on shell. This parameter can either\n",
    "                    be a sequence of arguments that are directly passed to\n",
    "                    the process or a string. A string gets splitted beforehand\n",
    "                    using ``shlex.split()``.\n",
    "    :param stdin:   Initial input to send to the process.\n",
    "    :param kwargs:  Additional keyword arguments to pass to\n",
    "                    ``subprocess.Popen`` that is used to spawn the process.\n",
    "    :return:        A tuple with ``(stdoutstring, stderrstring)``.\n",
    "    \"\"\"\n",
    "    with run_interactive_shell_command(command, **kwargs) as p:\n",
    "        ret = p.communicate(stdin)\n",
    "    return ret\n",
    "\n",
    "\n",
    "def get_shell_type():  # pragma: no cover\n",
    "    \"\"\"\n",
    "    Finds the current shell type based on the outputs of common pre-defined\n",
    "    variables in them. This is useful to identify which sort of escaping\n",
    "    is required for strings.\n",
    "\n",
    "    :return: The shell type. This can be either \"powershell\" if Windows\n",
    "             Powershell is detected, \"cmd\" if command prompt is been\n",
    "             detected or \"sh\" if it's neither of these.\n",
    "    \"\"\"\n",
    "    out = run_shell_command(\"echo $host.name\", shell=True)[0]\n",
    "    if out.strip() == \"ConsoleHost\":\n",
    "        return \"powershell\"\n",
    "    out = run_shell_command(\"echo $0\", shell=True)[0]\n",
    "    if out.strip() == \"$0\":\n",
    "        return \"cmd\"\n",
    "    return \"sh\"\n"
  ],
  "/home/tushar/coala/coalib/misc/StringConverter.py": [
    "import re\n",
    "from collections import Iterable, OrderedDict\n",
    "\n",
    "from coalib.misc import Constants\n",
    "from coalib.parsing.StringProcessing import (\n",
    "    unescape, unescaped_split, unescaped_strip)\n",
    "\n",
    "\n",
    "class StringConverter:\n",
    "    \"\"\"\n",
    "    Converts strings to other things as needed. If you need some kind of string\n",
    "    conversion that is not implemented here, consider adding it so everyone\n",
    "    gets something out of it.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self,\n",
    "                 value,\n",
    "                 strip_whitespaces=True,\n",
    "                 list_delimiters=None,\n",
    "                 dict_delimiter=\":\",\n",
    "                 remove_empty_iter_elements=True):\n",
    "        if list_delimiters is None:\n",
    "            list_delimiters = [\",\", \";\"]\n",
    "\n",
    "        if not isinstance(list_delimiters, Iterable):\n",
    "            raise TypeError(\"list_delimiters has to be an Iterable.\")\n",
    "        if not isinstance(strip_whitespaces, bool):\n",
    "            raise TypeError(\"strip_whitespaces has to be a bool parameter\")\n",
    "\n",
    "        self.__strip_whitespaces = strip_whitespaces\n",
    "        self.__list_delimiters = list_delimiters\n",
    "        self.__dict_delimiter = dict_delimiter\n",
    "        self.__remove_empty_iter_elements = remove_empty_iter_elements\n",
    "\n",
    "        self.__escaped_list = None\n",
    "        self.__unescaped_list = None\n",
    "        self.__dict = None\n",
    "        self.value = value\n",
    "\n",
    "    def __str__(self):\n",
    "        return unescape(self.value)\n",
    "\n",
    "    def __bool__(self):\n",
    "        if str(self).lower() in Constants.TRUE_STRINGS:\n",
    "            return True\n",
    "        if str(self).lower() in Constants.FALSE_STRINGS:\n",
    "            return False\n",
    "        raise ValueError\n",
    "\n",
    "    def __len__(self):\n",
    "        return len(str(self))\n",
    "\n",
    "    def __int__(self):\n",
    "        return int(str(self))\n",
    "\n",
    "    def __float__(self):\n",
    "        return float(str(self))\n",
    "\n",
    "    def __url__(self):\n",
    "        \"\"\"\n",
    "        Determines the url validity of this setting.\n",
    "\n",
    "        :return:            url string\n",
    "        :raises ValueError: If the url is not valid.\n",
    "        \"\"\"\n",
    "        strrep = str(self).strip()\n",
    "        if Constants.URL_REGEX.match(strrep):\n",
    "            return strrep\n",
    "\n",
    "        raise ValueError(repr(strrep) + \" is not a valid url.\")\n",
    "\n",
    "    def __iter__(self, remove_backslashes=True):\n",
    "        \"\"\"\n",
    "        Converts the value to a list using the delimiters given at construction\n",
    "        time.\n",
    "\n",
    "        Note that escaped values will be unescaped and escaped list delimiters\n",
    "        will be allowed in values. If you need the escapes you should not\n",
    "        use this routine.\n",
    "\n",
    "        :param remove_backslashes: Whether or not to remove the backslashes\n",
    "                                   after conversion.\n",
    "        :return:                   An iterator over all values.\n",
    "        \"\"\"\n",
    "        if remove_backslashes:\n",
    "            return iter(self.__unescaped_list)\n",
    "        else:\n",
    "            return iter(self.__escaped_list)\n",
    "\n",
    "    def __getitem__(self, item):\n",
    "        return self.__dict.__getitem__(item)\n",
    "\n",
    "    def keys(self):\n",
    "        return self.__dict.keys()\n",
    "\n",
    "    def __get_raw_list(self):\n",
    "        pattern = (\"(?:\" +\n",
    "                   \"|\".join(re.escape(v) for v in self.__list_delimiters) +\n",
    "                   \")\")\n",
    "\n",
    "        return list(unescaped_split(pattern,\n",
    "                                    self.value,\n",
    "                                    use_regex=True))\n",
    "\n",
    "    def __prepare_list(self):\n",
    "        self.__escaped_list = self.__get_raw_list()\n",
    "\n",
    "        if self.__strip_whitespaces:\n",
    "            self.__escaped_list = [unescaped_strip(elem)\n",
    "                                   for elem in self.__escaped_list]\n",
    "\n",
    "        self.__unescaped_list = [unescape(elem)\n",
    "                                 for elem in self.__escaped_list]\n",
    "\n",
    "        if self.__remove_empty_iter_elements:\n",
    "            # Need to do after stripping, cant use builtin functionality of\n",
    "            # split.\n",
    "            while \"\" in self.__unescaped_list:\n",
    "                self.__unescaped_list.remove(\"\")\n",
    "            while \"\" in self.__escaped_list:\n",
    "                self.__escaped_list.remove(\"\")\n",
    "\n",
    "    def __prepare_dict(self):\n",
    "        # We must keep order here, user can drop it later.\n",
    "        self.__dict = OrderedDict()\n",
    "        for elem in self.__get_raw_list():\n",
    "            key_val = unescaped_split(self.__dict_delimiter, elem, max_split=1)\n",
    "\n",
    "            if self.__strip_whitespaces:\n",
    "                key_val = [unescaped_strip(item) for item in key_val]\n",
    "\n",
    "            key_val = [unescape(item) for item in key_val]\n",
    "\n",
    "            if not any(item != \"\" for item in key_val):\n",
    "                continue\n",
    "\n",
    "            if len(key_val) < 2:\n",
    "                self.__dict[key_val[0]] = \"\"\n",
    "            else:\n",
    "                self.__dict[key_val[0]] = key_val[1]\n",
    "\n",
    "    @property\n",
    "    def value(self):\n",
    "        return self.__value\n",
    "\n",
    "    @value.setter\n",
    "    def value(self, newval):\n",
    "        self.__value = str(newval)\n",
    "        if self.__strip_whitespaces:\n",
    "            self.__value = unescaped_strip(self.__value)\n",
    "\n",
    "        self.__prepare_list()\n",
    "        self.__prepare_dict()\n",
    "\n",
    "    def __eq__(self, other):\n",
    "        return isinstance(other, StringConverter) and self.value == other.value\n",
    "\n",
    "    def __ne__(self, other):\n",
    "        return not self.__eq__(other)\n"
  ],
  "/home/tushar/coala/coalib/misc/__init__.py": [],
  "/home/tushar/coala/coalib/output/ConfWriter.py": [
    "from itertools import chain\n",
    "\n",
    "from pyprint.ClosableObject import ClosableObject\n",
    "\n",
    "from coalib.parsing.StringProcessing import escape\n",
    "from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "class ConfWriter(ClosableObject):\n",
    "\n",
    "    def __init__(self,\n",
    "                 file_name,\n",
    "                 key_value_delimiters=('=',),\n",
    "                 comment_seperators=('#',),\n",
    "                 key_delimiters=(',', ' '),\n",
    "                 section_name_surroundings=None,\n",
    "                 section_override_delimiters=(\".\",),\n",
    "                 unsavable_keys=(\"save\",)):\n",
    "        section_name_surroundings = section_name_surroundings or {\"[\": \"]\"}\n",
    "        ClosableObject.__init__(self)\n",
    "        self.__file_name = file_name\n",
    "        self.__file = open(self.__file_name, \"w\")\n",
    "        self.__key_value_delimiters = key_value_delimiters\n",
    "        self.__comment_seperators = comment_seperators\n",
    "        self.__key_delimiters = key_delimiters\n",
    "        self.__section_name_surroundings = section_name_surroundings\n",
    "        self.__section_override_delimiters = section_override_delimiters\n",
    "        self.__unsavable_keys = unsavable_keys\n",
    "        self.__wrote_newline = True\n",
    "        self.__closed = False\n",
    "\n",
    "        self.__key_delimiter = self.__key_delimiters[0]\n",
    "        self.__key_value_delimiter = self.__key_value_delimiters[0]\n",
    "        (self.__section_name_surrounding_beg,\n",
    "         self.__section_name_surrounding_end) = (\n",
    "            tuple(self.__section_name_surroundings.items())[0])\n",
    "\n",
    "    def _close(self):\n",
    "        self.__file.close()\n",
    "\n",
    "    def write_sections(self, sections):\n",
    "        assert not self.__closed\n",
    "\n",
    "        self.__wrote_newline = True\n",
    "        for section in sections:\n",
    "            self.write_section(sections[section])\n",
    "\n",
    "    def write_section(self, section):\n",
    "        assert not self.__closed\n",
    "\n",
    "        if not isinstance(section, Section):\n",
    "            raise TypeError\n",
    "\n",
    "        self.__write_section_name(section.name)\n",
    "\n",
    "        keys = []\n",
    "        val = None\n",
    "        section_iter = section.__iter__(ignore_defaults=True)\n",
    "        try:\n",
    "            while True:\n",
    "                setting = section[next(section_iter)]\n",
    "                if (str(setting) == val and\n",
    "                    not self.is_comment(setting.key) and\n",
    "                    (\n",
    "                        (setting.key not in self.__unsavable_keys) or\n",
    "                        (not setting.from_cli))):\n",
    "                    keys.append(setting.key)\n",
    "                elif ((setting.key not in self.__unsavable_keys) or\n",
    "                      (not setting.from_cli)):\n",
    "                    self.__write_key_val(keys, val)\n",
    "                    keys = [setting.key]\n",
    "                    val = str(setting)\n",
    "        except StopIteration:\n",
    "            self.__write_key_val(keys, val)\n",
    "\n",
    "    def __write_section_name(self, name):\n",
    "        assert not self.__closed\n",
    "\n",
    "        if not self.__wrote_newline:\n",
    "            self.__file.write(\"\\n\")\n",
    "\n",
    "        self.__file.write(self.__section_name_surrounding_beg + name +\n",
    "                          self.__section_name_surrounding_end + '\\n')\n",
    "        self.__wrote_newline = False\n",
    "\n",
    "    def __write_key_val(self, keys, val):\n",
    "        assert not self.__closed\n",
    "\n",
    "        if keys == []:\n",
    "            return\n",
    "\n",
    "        if all(self.is_comment(key) for key in keys):\n",
    "            self.__file.write(val + \"\\n\")\n",
    "            self.__wrote_newline = val == \"\"\n",
    "            return\n",
    "\n",
    "        # Add escape characters as appropriate\n",
    "        keys = [escape(key, chain(['\\\\'],\n",
    "                                  self.__key_value_delimiters,\n",
    "                                  self.__comment_seperators,\n",
    "                                  self.__key_delimiters,\n",
    "                                  self.__section_override_delimiters))\n",
    "                for key in keys]\n",
    "        val = escape(val, chain(['\\\\'], self.__comment_seperators))\n",
    "\n",
    "        self.__file.write((self.__key_delimiter + \" \").join(keys) + \" \" +\n",
    "                          self.__key_value_delimiter + \" \" + val + \"\\n\")\n",
    "        self.__wrote_newline = False\n",
    "\n",
    "    @staticmethod\n",
    "    def is_comment(key):\n",
    "        return key.lower().startswith(\"comment\")\n"
  ],
  "/home/tushar/coala/coalib/output/ConsoleInteraction.py": [
    "try:\n",
    "    # This import has side effects and is needed to make input() behave nicely\n",
    "    import readline  # pylint: disable=unused-import\n",
    "except ImportError:  # pragma: no cover\n",
    "    pass\n",
    "import os.path\n",
    "\n",
    "from pyprint.ConsolePrinter import ConsolePrinter\n",
    "\n",
    "from coalib.misc.DictUtilities import inverse_dicts\n",
    "from coalib.bearlib.spacing.SpacingHelper import SpacingHelper\n",
    "from coalib.output.printers.LOG_LEVEL import LOG_LEVEL\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.result_actions.ApplyPatchAction import ApplyPatchAction\n",
    "from coalib.results.result_actions.OpenEditorAction import OpenEditorAction\n",
    "from coalib.results.result_actions.PrintDebugMessageAction import (\n",
    "    PrintDebugMessageAction)\n",
    "from coalib.results.result_actions.PrintMoreInfoAction import (\n",
    "    PrintMoreInfoAction)\n",
    "from coalib.results.result_actions.ShowPatchAction import ShowPatchAction\n",
    "from coalib.results.RESULT_SEVERITY import (\n",
    "    RESULT_SEVERITY, RESULT_SEVERITY_COLORS)\n",
    "from coalib.settings.Setting import Setting\n",
    "\n",
    "STR_GET_VAL_FOR_SETTING = (\"Please enter a value for the setting \\\"{}\\\" ({}) \"\n",
    "                           \"needed by {}: \")\n",
    "STR_LINE_DOESNT_EXIST = (\"The line belonging to the following result \"\n",
    "                         \"cannot be printed because it refers to a line \"\n",
    "                         \"that doesn't seem to exist in the given file.\")\n",
    "STR_PROJECT_WIDE = \"Project wide:\"\n",
    "FILE_NAME_COLOR = \"blue\"\n",
    "FILE_LINES_COLOR = \"blue\"\n",
    "HIGHLIGHTED_CODE_COLOR = 'red'\n",
    "SUCCESS_COLOR = 'green'\n",
    "CLI_ACTIONS = (OpenEditorAction(),\n",
    "               ApplyPatchAction(),\n",
    "               PrintDebugMessageAction(),\n",
    "               PrintMoreInfoAction(),\n",
    "               ShowPatchAction())\n",
    "DIFF_EXCERPT_MAX_SIZE = 4\n",
    "\n",
    "\n",
    "def format_lines(lines, line_nr=\"\"):\n",
    "    return '\\n'.join(\"|{:>4}| {}\".format(line_nr, line)\n",
    "                     for line in lines.rstrip(\"\\n\").split('\\n'))\n",
    "\n",
    "\n",
    "def print_section_beginning(console_printer, section):\n",
    "    \"\"\"\n",
    "    Will be called after initialization current_section in\n",
    "    begin_section()\n",
    "\n",
    "    :param console_printer: Object to print messages on the console.\n",
    "    :param section:         The section that will get executed now.\n",
    "    \"\"\"\n",
    "    console_printer.print(\"Executing section {name}...\".format(\n",
    "        name=section.name))\n",
    "\n",
    "\n",
    "def nothing_done(log_printer):\n",
    "    \"\"\"\n",
    "    Will be called after processing a coafile when nothing had to be done,\n",
    "    i.e. no section was enabled/targeted.\n",
    "\n",
    "    :param log_printer: A LogPrinter object.\n",
    "    \"\"\"\n",
    "    log_printer.warn(\"No existent section was targeted or enabled. \"\n",
    "                     \"Nothing to do.\")\n",
    "\n",
    "\n",
    "def acquire_actions_and_apply(console_printer,\n",
    "                              log_printer,\n",
    "                              section,\n",
    "                              file_diff_dict,\n",
    "                              result,\n",
    "                              file_dict,\n",
    "                              cli_actions=None):\n",
    "    \"\"\"\n",
    "    Acquires applicable actions and applies them.\n",
    "\n",
    "    :param console_printer: Object to print messages on the console.\n",
    "    :param log_printer:     Printer responsible for logging the messages.\n",
    "    :param section:         Name of section to which the result belongs.\n",
    "    :param file_diff_dict:  Dictionary containing filenames as keys and Diff\n",
    "                            objects as values.\n",
    "    :param result:          A derivative of Result.\n",
    "    :param file_dict:       A dictionary containing all files with filename as\n",
    "                            key.\n",
    "    :param cli_actions:     The list of cli actions available.\n",
    "    \"\"\"\n",
    "    cli_actions = cli_actions or CLI_ACTIONS\n",
    "    failed_actions = set()\n",
    "    while True:\n",
    "        actions = []\n",
    "        for action in cli_actions:\n",
    "            if action.is_applicable(result, file_dict, file_diff_dict):\n",
    "                actions.append(action)\n",
    "\n",
    "        if actions == []:\n",
    "            return\n",
    "\n",
    "        action_dict = {}\n",
    "        metadata_list = []\n",
    "        for action in actions:\n",
    "            metadata = action.get_metadata()\n",
    "            action_dict[metadata.name] = action\n",
    "            metadata_list.append(metadata)\n",
    "\n",
    "        # User can always choose no action which is guaranteed to succeed\n",
    "        if not ask_for_action_and_apply(log_printer,\n",
    "                                        console_printer,\n",
    "                                        section,\n",
    "                                        metadata_list,\n",
    "                                        action_dict,\n",
    "                                        failed_actions,\n",
    "                                        result,\n",
    "                                        file_diff_dict,\n",
    "                                        file_dict):\n",
    "            break\n",
    "\n",
    "\n",
    "def print_spaces_tabs_in_unicode(console_printer, line, tab_dict,\n",
    "                                 color, index=0):\n",
    "    \"\"\"\n",
    "    Prints the lines with tabs and spaces replaced by unicode symbols.\n",
    "\n",
    "    :param console_printer: The ``Printer`` object to print to.\n",
    "    :param line:            The line-text to print to ``console_printer``.\n",
    "    :param tab_dict:        A dictionary containing the indices of tabs inside\n",
    "                            ``line`` as keys and the tab-length as values.\n",
    "    :param color:           The color to print the line with (except for spaces\n",
    "                            and tabs.\n",
    "    :param index:           The index from where to start the printing.\n",
    "    \"\"\"\n",
    "    for char in line:\n",
    "        if char == \" \":\n",
    "            try:\n",
    "                console_printer.print(\"\u2022\", color='cyan', end='')\n",
    "            except UnicodeEncodeError:\n",
    "                console_printer.print(\".\", color='cyan', end='')\n",
    "        elif char == '\\t' and tab_dict:\n",
    "            tab_count = tab_dict[index]\n",
    "            console_printer.print(\n",
    "                '-'*(tab_count-1) + '>', color='cyan', end='')\n",
    "        else:\n",
    "            console_printer.print(char, color=color, end='')\n",
    "        index += 1\n",
    "\n",
    "\n",
    "def print_lines(console_printer,\n",
    "                file_dict,\n",
    "                section,\n",
    "                sourcerange):\n",
    "    \"\"\"\n",
    "    Prints the lines between the current and the result line. If needed\n",
    "    they will be shortened.\n",
    "\n",
    "    :param console_printer: Object to print messages on the console.\n",
    "    :param file_dict:       A dictionary containing all files as values with\n",
    "                            filenames as key.\n",
    "    :param sourcerange:     The SourceRange object referring to the related\n",
    "                            lines to print.\n",
    "    \"\"\"\n",
    "    for i in range(sourcerange.start.line, sourcerange.end.line + 1):\n",
    "        console_printer.print(format_lines(lines='', line_nr=i),\n",
    "                              color=FILE_LINES_COLOR,\n",
    "                              end='')\n",
    "        line = file_dict[sourcerange.file][i - 1].rstrip(\"\\n\")\n",
    "        tab_width = int(section.get('tab_width', 4))\n",
    "        s = SpacingHelper(tab_width)\n",
    "        tab_dict = dict(s.yield_tab_lengths(line))\n",
    "        printed_chars = 0\n",
    "        if i == sourcerange.start.line and sourcerange.start.column:\n",
    "            print_spaces_tabs_in_unicode(\n",
    "                console_printer, line[:sourcerange.start.column-1],\n",
    "                tab_dict, FILE_LINES_COLOR)\n",
    "\n",
    "            printed_chars = sourcerange.start.column-1\n",
    "\n",
    "        if i == sourcerange.end.line and sourcerange.end.column:\n",
    "            print_spaces_tabs_in_unicode(\n",
    "                console_printer, line[printed_chars:sourcerange.end.column-1],\n",
    "                tab_dict, HIGHLIGHTED_CODE_COLOR, printed_chars)\n",
    "\n",
    "            print_spaces_tabs_in_unicode(\n",
    "                console_printer, line[sourcerange.end.column-1:],\n",
    "                tab_dict, FILE_LINES_COLOR, sourcerange.end.column)\n",
    "            console_printer.print(\"\")\n",
    "        else:\n",
    "            print_spaces_tabs_in_unicode(\n",
    "                console_printer, line[printed_chars:], tab_dict,\n",
    "                HIGHLIGHTED_CODE_COLOR, printed_chars)\n",
    "            console_printer.print(\"\")\n",
    "\n",
    "\n",
    "def print_result(console_printer,\n",
    "                 log_printer,\n",
    "                 section,\n",
    "                 file_diff_dict,\n",
    "                 result,\n",
    "                 file_dict,\n",
    "                 interactive=True):\n",
    "    \"\"\"\n",
    "    Prints the result to console.\n",
    "\n",
    "    :param console_printer: Object to print messages on the console.\n",
    "    :param log_printer:     Printer responsible for logging the messages.\n",
    "    :param section:         Name of section to which the result belongs.\n",
    "    :param file_diff_dict:  Dictionary containing filenames as keys and Diff\n",
    "                            objects as values.\n",
    "    :param result:          A derivative of Result.\n",
    "    :param file_dict:       A dictionary containing all files with filename as\n",
    "                            key.\n",
    "    :interactive:           Variable to check wether or not to\n",
    "                            offer the user actions interactively.\n",
    "    \"\"\"\n",
    "    if not isinstance(result, Result):\n",
    "        log_printer.warn(\"One of the results can not be printed since it is \"\n",
    "                         \"not a valid derivative of the coala result \"\n",
    "                         \"class.\")\n",
    "        return\n",
    "\n",
    "    console_printer.print(format_lines(\"[{sev}] {bear}:\".format(\n",
    "        sev=RESULT_SEVERITY.__str__(result.severity), bear=result.origin)),\n",
    "        color=RESULT_SEVERITY_COLORS[result.severity])\n",
    "    console_printer.print(format_lines(result.message), delimiter=\"\\n\")\n",
    "\n",
    "    if interactive:\n",
    "        cli_actions = CLI_ACTIONS\n",
    "        show_patch_action = ShowPatchAction()\n",
    "        if show_patch_action.is_applicable(result, file_dict, file_diff_dict):\n",
    "            diff_size = sum(len(diff) for diff in result.diffs.values())\n",
    "            if diff_size <= DIFF_EXCERPT_MAX_SIZE:\n",
    "                show_patch_action.apply_from_section(result,\n",
    "                                                     file_dict,\n",
    "                                                     file_diff_dict,\n",
    "                                                     section)\n",
    "                cli_actions = tuple(action for action in cli_actions\n",
    "                                    if not isinstance(action, ShowPatchAction))\n",
    "            else:\n",
    "                print_diffs_info(result.diffs, console_printer)\n",
    "        acquire_actions_and_apply(console_printer,\n",
    "                                  log_printer,\n",
    "                                  section,\n",
    "                                  file_diff_dict,\n",
    "                                  result,\n",
    "                                  file_dict,\n",
    "                                  cli_actions)\n",
    "\n",
    "\n",
    "def print_diffs_info(diffs, printer):\n",
    "    for filename, diff in sorted(diffs.items()):\n",
    "        additions, deletions = diff.stats()\n",
    "        printer.print(\n",
    "            format_lines(\"+{additions} -{deletions} in {file}\".format(\n",
    "                file=filename,\n",
    "                additions=additions,\n",
    "                deletions=deletions)),\n",
    "            color='green')\n",
    "\n",
    "\n",
    "def print_results_formatted(log_printer,\n",
    "                            section,\n",
    "                            result_list,\n",
    "                            *args):\n",
    "    format_str = str(section.get(\n",
    "        \"format_str\",\n",
    "        \"id:{id}:origin:{origin}:file:{file}:line:{line}:column:\"\n",
    "        \"{column}:end_line:{end_line}:end_column:{end_column}:severity:\"\n",
    "        \"{severity}:severity_str:{severity_str}:message:{message}\"))\n",
    "    for result in result_list:\n",
    "        severity_str = RESULT_SEVERITY.__str__(result.severity)\n",
    "        try:\n",
    "            if len(result.affected_code) == 0:\n",
    "                print(format_str.format(file=None,\n",
    "                                        line=None,\n",
    "                                        end_line=None,\n",
    "                                        column=None,\n",
    "                                        end_column=None,\n",
    "                                        severity_str=severity_str,\n",
    "                                        **result.__dict__))\n",
    "                continue\n",
    "\n",
    "            for range in result.affected_code:\n",
    "                print(format_str.format(file=range.start.file,\n",
    "                                        line=range.start.line,\n",
    "                                        end_line=range.end.line,\n",
    "                                        column=range.start.column,\n",
    "                                        end_column=range.end.column,\n",
    "                                        severity_str=severity_str,\n",
    "                                        **result.__dict__))\n",
    "        except KeyError as exception:\n",
    "            log_printer.log_exception(\n",
    "                \"Unable to print the result with the given format string.\",\n",
    "                exception)\n",
    "\n",
    "\n",
    "def print_affected_files(console_printer,\n",
    "                         log_printer,\n",
    "                         section,\n",
    "                         result,\n",
    "                         file_dict,\n",
    "                         color=True):\n",
    "    \"\"\"\n",
    "    Print all the afected files and affected lines within them.\n",
    "\n",
    "    :param console_printer: Object to print messages on the console.\n",
    "    :param log_printer:     Printer responsible for logging the messages.\n",
    "    :param section:         The section to which the results belong to.\n",
    "    :param result_list:     List containing the results\n",
    "    :param file_dict:       A dictionary containing all files with filename as\n",
    "                            key.\n",
    "    :param color:           Boolean variable to print the results in color or\n",
    "                            not. Can be used for testing.\n",
    "    \"\"\"\n",
    "    if len(result.affected_code) == 0:\n",
    "        console_printer.print(\"\\n\" + STR_PROJECT_WIDE,\n",
    "                              color=FILE_NAME_COLOR)\n",
    "    else:\n",
    "        for sourcerange in result.affected_code:\n",
    "            if (\n",
    "                    sourcerange.file is not None and\n",
    "                    sourcerange.file not in file_dict):\n",
    "                log_printer.warn(\"The context for the result ({}) cannot \"\n",
    "                                 \"be printed because it refers to a file \"\n",
    "                                 \"that doesn't seem to exist ({})\"\n",
    "                                 \".\".format(result, sourcerange.file))\n",
    "            else:\n",
    "                print_affected_lines(console_printer,\n",
    "                                     file_dict,\n",
    "                                     section,\n",
    "                                     sourcerange)\n",
    "\n",
    "\n",
    "def print_results_no_input(log_printer,\n",
    "                           section,\n",
    "                           result_list,\n",
    "                           file_dict,\n",
    "                           file_diff_dict,\n",
    "                           color=True):\n",
    "    \"\"\"\n",
    "    Print all non interactive results in a section\n",
    "\n",
    "    :param log_printer:    Printer responsible for logging the messages.\n",
    "    :param section:        The section to which the results belong to.\n",
    "    :param result_list:    List containing the results\n",
    "    :param file_dict:      A dictionary containing all files with filename as\n",
    "                           key.\n",
    "    :param file_diff_dict: A dictionary that contains filenames as keys and\n",
    "                           diff objects as values.\n",
    "    :param color:          Boolean variable to print the results in color or\n",
    "                           not. Can be used for testing.\n",
    "    \"\"\"\n",
    "    console_printer = ConsolePrinter(print_colored=color)\n",
    "    for result in result_list:\n",
    "\n",
    "        print_affected_files(console_printer,\n",
    "                             log_printer,\n",
    "                             section,\n",
    "                             result,\n",
    "                             file_dict,\n",
    "                             color=color)\n",
    "\n",
    "        print_result(console_printer,\n",
    "                     log_printer,\n",
    "                     section,\n",
    "                     file_diff_dict,\n",
    "                     result,\n",
    "                     file_dict,\n",
    "                     interactive=False)\n",
    "\n",
    "\n",
    "def print_results(log_printer,\n",
    "                  section,\n",
    "                  result_list,\n",
    "                  file_dict,\n",
    "                  file_diff_dict,\n",
    "                  color=True):\n",
    "    \"\"\"\n",
    "    Print all the results in a section.\n",
    "\n",
    "    :param log_printer:    Printer responsible for logging the messages.\n",
    "    :param section:        The section to which the results belong to.\n",
    "    :param result_list:    List containing the results\n",
    "    :param file_dict:      A dictionary containing all files with filename as\n",
    "                           key.\n",
    "    :param file_diff_dict: A dictionary that contains filenames as keys and\n",
    "                           diff objects as values.\n",
    "    :param color:          Boolean variable to print the results in color or\n",
    "                           not. Can be used for testing.\n",
    "    \"\"\"\n",
    "    console_printer = ConsolePrinter(print_colored=color)\n",
    "\n",
    "    for result in sorted(result_list):\n",
    "\n",
    "        print_affected_files(console_printer,\n",
    "                             log_printer,\n",
    "                             section,\n",
    "                             result,\n",
    "                             file_dict,\n",
    "                             color=color)\n",
    "\n",
    "        print_result(console_printer,\n",
    "                     log_printer,\n",
    "                     section,\n",
    "                     file_diff_dict,\n",
    "                     result,\n",
    "                     file_dict)\n",
    "\n",
    "\n",
    "def print_affected_lines(console_printer, file_dict, section, sourcerange):\n",
    "    console_printer.print(\"\\n\" + os.path.relpath(sourcerange.file),\n",
    "                          color=FILE_NAME_COLOR)\n",
    "\n",
    "    if sourcerange.start.line is not None:\n",
    "        if len(file_dict[sourcerange.file]) < sourcerange.end.line:\n",
    "            console_printer.print(format_lines(lines=STR_LINE_DOESNT_EXIST))\n",
    "        else:\n",
    "            print_lines(console_printer,\n",
    "                        file_dict,\n",
    "                        section,\n",
    "                        sourcerange)\n",
    "\n",
    "\n",
    "def require_setting(log_printer, setting_name, arr):\n",
    "    \"\"\"\n",
    "    This method is responsible for prompting a user about a missing setting and\n",
    "    taking its value as input from the user.\n",
    "\n",
    "    :param log_printer:  Printer responsible for logging the messages.\n",
    "    :param setting_name: Name od the setting missing\n",
    "    :param arr:          a list containing a description in [0] and the name\n",
    "                         of the bears who need this setting in [1] and\n",
    "                         following.\n",
    "    \"\"\"\n",
    "    if not isinstance(arr, list) or len(arr) < 2:\n",
    "        log_printer.log(LOG_LEVEL.WARNING,\n",
    "                        \"One of the given settings ({}) is not properly \"\n",
    "                        \"described.\".format(setting_name))\n",
    "\n",
    "        return None\n",
    "\n",
    "    if len(arr) == 2:\n",
    "        needed = arr[1]\n",
    "    else:\n",
    "        needed = \", \".join(arr[1:-1]) + \" and \" + arr[-1]\n",
    "\n",
    "    return input(STR_GET_VAL_FOR_SETTING.format(setting_name, arr[0], needed))\n",
    "\n",
    "\n",
    "def acquire_settings(log_printer, settings_names_dict):\n",
    "    \"\"\"\n",
    "    This method prompts the user for the given settings.\n",
    "\n",
    "    :param log_printer: Printer responsible for logging the messages.\n",
    "    :param settings:    a dictionary with the settings name as key and a list\n",
    "                        containing a description in [0] and the name of the\n",
    "                        bears who need this setting in [1] and following.\n",
    "\n",
    "                        Example:\n",
    "\n",
    "    ::\n",
    "\n",
    "        {\"UseTabs\": [\"describes whether tabs should be used instead of spaces\",\n",
    "                     \"SpaceConsistencyBear\",\n",
    "                     \"SomeOtherBear\"]}\n",
    "\n",
    "    :return:            a dictionary with the settings name as key and the\n",
    "                        given value as value.\n",
    "    \"\"\"\n",
    "    if not isinstance(settings_names_dict, dict):\n",
    "        raise TypeError(\"The settings_names_dict parameter has to be a \"\n",
    "                        \"dictionary.\")\n",
    "\n",
    "    result = {}\n",
    "    for setting_name, arr in settings_names_dict.items():\n",
    "        value = require_setting(log_printer, setting_name, arr)\n",
    "        if value is not None:\n",
    "            result[setting_name] = value\n",
    "\n",
    "    return result\n",
    "\n",
    "\n",
    "def get_action_info(section, action, failed_actions):\n",
    "    \"\"\"\n",
    "    Get all the required Settings for an action. It updates the section with\n",
    "    the Settings.\n",
    "\n",
    "    :param section:         The section the action corresponds to.\n",
    "    :param action:          The action to get the info for.\n",
    "    :param failed_actions:  A set of all actions that have failed. A failed\n",
    "                            action remains in the list until it is successfully\n",
    "                            executed.\n",
    "    :return:                Action name and the updated section.\n",
    "    \"\"\"\n",
    "    params = action.non_optional_params\n",
    "\n",
    "    for param_name in params:\n",
    "        if param_name not in section or action.name in failed_actions:\n",
    "            question = format_lines(\n",
    "                \"Please enter a value for the parameter '{}' ({}): \"\n",
    "                .format(param_name, params[param_name][0]))\n",
    "            section.append(Setting(param_name, input(question)))\n",
    "\n",
    "    return action.name, section\n",
    "\n",
    "\n",
    "def choose_action(console_printer, actions):\n",
    "    \"\"\"\n",
    "    Presents the actions available to the user and takes as input the action\n",
    "    the user wants to choose.\n",
    "\n",
    "    :param console_printer: Object to print messages on the console.\n",
    "    :param actions:         Actions available to the user.\n",
    "    :return:                Return choice of action of user.\n",
    "    \"\"\"\n",
    "    console_printer.print(format_lines(\n",
    "        \"The following actions are applicable to this result:\"))\n",
    "\n",
    "    while True:\n",
    "        console_printer.print(format_lines(\" 0: \" +\n",
    "                                           \"Apply no further actions.\"))\n",
    "        for i, action in enumerate(actions, 1):\n",
    "            console_printer.print(format_lines(\"{:>2}: {}\".format(\n",
    "                i,\n",
    "                action.desc)))\n",
    "\n",
    "        try:\n",
    "            line = format_lines(\"Please enter the number of the action \"\n",
    "                                \"you want to execute (Ctrl-D to exit). \")\n",
    "            choice = int(input(line))\n",
    "            if 0 <= choice <= len(actions):\n",
    "                return choice\n",
    "        except ValueError:\n",
    "            pass\n",
    "\n",
    "        console_printer.print(format_lines(\"Please enter a valid number.\"))\n",
    "\n",
    "\n",
    "def print_actions(console_printer, section, actions, failed_actions):\n",
    "    \"\"\"\n",
    "    Prints the given actions and lets the user choose.\n",
    "\n",
    "    :param console_printer: Object to print messages on the console.\n",
    "    :param actions:         A list of FunctionMetadata objects.\n",
    "    :param failed_actions:  A set of all actions that have failed. A failed\n",
    "                            action remains in the list until it is\n",
    "                            successfully executed.\n",
    "    :return:                A touple with the name member of the\n",
    "                            FunctionMetadata object chosen by the user\n",
    "                            and a Section containing at least all needed\n",
    "                            values for the action. If the user did\n",
    "                            choose to do nothing, return (None, None).\n",
    "    \"\"\"\n",
    "    choice = choose_action(console_printer, actions)\n",
    "\n",
    "    if choice == 0:\n",
    "        return None, None\n",
    "\n",
    "    return get_action_info(section, actions[choice - 1], failed_actions)\n",
    "\n",
    "\n",
    "def ask_for_action_and_apply(log_printer,\n",
    "                             console_printer,\n",
    "                             section,\n",
    "                             metadata_list,\n",
    "                             action_dict,\n",
    "                             failed_actions,\n",
    "                             result,\n",
    "                             file_diff_dict,\n",
    "                             file_dict):\n",
    "    \"\"\"\n",
    "    Asks the user for an action and applies it.\n",
    "\n",
    "    :param log_printer:     Printer responsible for logging the messages.\n",
    "    :param console_printer: Object to print messages on the console.\n",
    "    :param section:         Currently active section.\n",
    "    :param metadata_list:   Contains metadata for all the actions.\n",
    "    :param action_dict:     Contains the action names as keys and their\n",
    "                            references as values.\n",
    "    :param failed_actions:  A set of all actions that have failed. A failed\n",
    "                            action remains in the list until it is successfully\n",
    "                            executed.\n",
    "    :param result:          Result corresponding to the actions.\n",
    "    :param file_diff_dict:  If its an action which applies a patch, this\n",
    "                            contains the diff of the patch to be applied to\n",
    "                            the file with filename as keys.\n",
    "    :param file_dict:       Dictionary with filename as keys and its contents\n",
    "                            as values.\n",
    "    :return:                Returns a boolean value. True will be returned, if\n",
    "                            it makes sense that the user may choose to execute\n",
    "                            another action, False otherwise.\n",
    "    \"\"\"\n",
    "    action_name, section = print_actions(console_printer, section,\n",
    "                                         metadata_list, failed_actions)\n",
    "    if action_name is None:\n",
    "        return False\n",
    "\n",
    "    chosen_action = action_dict[action_name]\n",
    "    try:\n",
    "        chosen_action.apply_from_section(result,\n",
    "                                         file_dict,\n",
    "                                         file_diff_dict,\n",
    "                                         section)\n",
    "        console_printer.print(\n",
    "            format_lines(chosen_action.SUCCESS_MESSAGE),\n",
    "            color=SUCCESS_COLOR)\n",
    "        failed_actions.discard(action_name)\n",
    "    except Exception as exception:  # pylint: disable=broad-except\n",
    "        log_printer.log_exception(\"Failed to execute the action \"\n",
    "                                  \"{} with error: {}.\".format(action_name,\n",
    "                                                              exception),\n",
    "                                  exception)\n",
    "        failed_actions.add(action_name)\n",
    "    return True\n",
    "\n",
    "\n",
    "def show_enumeration(console_printer,\n",
    "                     title,\n",
    "                     items,\n",
    "                     indentation,\n",
    "                     no_items_text):\n",
    "    \"\"\"\n",
    "    This function takes as input an iterable object (preferably a list or\n",
    "    a dict). And prints in a stylized format. If the iterable object is\n",
    "    empty, it prints a specific statement give by the user. An e.g :\n",
    "\n",
    "    <indentation>Title:\n",
    "    <indentation> * Item 1\n",
    "    <indentation> * Item 2\n",
    "\n",
    "    :param console_printer: Object to print messages on the console.\n",
    "    :param title:           Title of the text to be printed\n",
    "    :param items:           The iterable object.\n",
    "    :param indentation:     Number of spaces to indent every line by.\n",
    "    :param no_items_text:   Text printed when iterable object is empty.\n",
    "    \"\"\"\n",
    "    if not items:\n",
    "        console_printer.print(indentation + no_items_text)\n",
    "    else:\n",
    "        console_printer.print(indentation + title)\n",
    "        if isinstance(items, dict):\n",
    "            for key, value in items.items():\n",
    "                console_printer.print(indentation + \" * \" + key + \": \" +\n",
    "                                      value[0])\n",
    "        else:\n",
    "            for item in items:\n",
    "                console_printer.print(indentation + \" * \" + item)\n",
    "    console_printer.print()\n",
    "\n",
    "\n",
    "def show_bear(console_printer, bear, sections, metadata):\n",
    "    \"\"\"\n",
    "    Display all information about a bear.\n",
    "\n",
    "    :param console_printer: Object to print messages on the console.\n",
    "    :param bear:            The bear to be displayed.\n",
    "    :param sections:        The sections to which the bear belongs.\n",
    "    :param metadata:        Metadata about the bear.\n",
    "    \"\"\"\n",
    "    console_printer.print(bear.name + \":\")\n",
    "    console_printer.print(\"  \" + metadata.desc + \"\\n\")\n",
    "\n",
    "    show_enumeration(\n",
    "        console_printer, \"Supported languages:\",\n",
    "        bear.supported_languages,\n",
    "        \"  \",\n",
    "        \"The bear does not provide information about which languages \"\n",
    "        \"it can analyze.\")\n",
    "    show_enumeration(console_printer,\n",
    "                     \"Used in:\",\n",
    "                     sections,\n",
    "                     \"  \",\n",
    "                     \"No sections.\")\n",
    "\n",
    "    show_enumeration(console_printer,\n",
    "                     \"Needed Settings:\",\n",
    "                     metadata.non_optional_params,\n",
    "                     \"  \",\n",
    "                     \"No needed settings.\")\n",
    "    show_enumeration(console_printer,\n",
    "                     \"Optional Settings:\",\n",
    "                     metadata.optional_params,\n",
    "                     \"  \",\n",
    "                     \"No optional settings.\")\n",
    "\n",
    "\n",
    "def print_bears(console_printer, bears, compress):\n",
    "    \"\"\"\n",
    "    Presents all bears being used in a stylized manner.\n",
    "\n",
    "    :param console_printer: Object to print messages on the console.\n",
    "    :param bears:           Its a dictionary with bears as keys and list of\n",
    "                            sections containing those bears as values.\n",
    "    :param compress:            If set to true, output will be compressed (just\n",
    "                                show bear names as a list)\n",
    "    \"\"\"\n",
    "    if not bears:\n",
    "        console_printer.print(\"No bears to show.\")\n",
    "    elif compress:\n",
    "        bear_list = sorted(bears.keys(), key=lambda bear: bear.name)\n",
    "        for bear in bear_list:\n",
    "            console_printer.print(bear.name)\n",
    "            console_printer.print(\"=\" * len(bear.name))\n",
    "\n",
    "            console_printer.print(bear.get_metadata().desc + \"\\n\")\n",
    "    else:\n",
    "        for bear in sorted(bears.keys(),\n",
    "                           key=lambda bear: bear.name):\n",
    "            show_bear(console_printer,\n",
    "                      bear,\n",
    "                      bears[bear],\n",
    "                      bear.get_metadata())\n",
    "\n",
    "\n",
    "def show_bears(local_bears, global_bears, compress, console_printer):\n",
    "    \"\"\"\n",
    "    Extracts all the bears from each enabled section or the sections in the\n",
    "    targets and passes a dictionary to the show_bears_callback method.\n",
    "\n",
    "    :param local_bears:         Dictionary of local bears with section names\n",
    "                                as keys and bear list as values.\n",
    "    :param global_bears:        Dictionary of global bears with section\n",
    "                                names as keys and bear list as values.\n",
    "    :param compress:            If set to true, output will be compressed (just\n",
    "                                show bear names as a list)\n",
    "    :param show_bears_callback: The callback that is used to print these\n",
    "                                bears. It will get one parameter holding\n",
    "                                bears as key and the list of section names\n",
    "                                where it's used as values.\n",
    "    \"\"\"\n",
    "    bears = inverse_dicts(local_bears, global_bears)\n",
    "\n",
    "    print_bears(console_printer, bears, compress)\n"
  ],
  "/home/tushar/coala/coalib/output/Interactions.py": [
    "def fail_acquire_settings(log_printer, settings_names_dict):\n",
    "    \"\"\"\n",
    "    This method throws an exception if any setting needs to be acquired.\n",
    "\n",
    "    :param log_printer:     Printer responsible for logging the messages.\n",
    "    :param settings:        A dictionary with the settings name as key and\n",
    "                            a list containing a description in [0] and the\n",
    "                            name of the bears who need this setting in [1]\n",
    "                            and following.\n",
    "    :raises AssertionError: If any setting is required.\n",
    "    :raises TypeError:      If ``settings_names_dict`` is not a dictionary.\n",
    "    \"\"\"\n",
    "    if not isinstance(settings_names_dict, dict):\n",
    "        raise TypeError(\"The settings_names_dict parameter has to be a \"\n",
    "                        \"dictionary.\")\n",
    "\n",
    "    required_settings = settings_names_dict.keys()\n",
    "    if len(required_settings) != 0:\n",
    "        msg = (\"During execution, we found that some required \"\n",
    "               \"settings were not provided. They are:\\n\")\n",
    "\n",
    "        for name, setting in settings_names_dict.items():\n",
    "            msg += \"{} (from {}) - {}\".format(name, setting[1], setting[0])\n",
    "\n",
    "        log_printer.err(msg)\n",
    "        raise AssertionError\n"
  ],
  "/home/tushar/coala/coalib/output/JSONEncoder.py": [
    "import collections\n",
    "import json\n",
    "from datetime import datetime\n",
    "\n",
    "from coala_decorators.decorators import get_public_members\n",
    "from coalib.settings.FunctionMetadata import FunctionMetadata\n",
    "\n",
    "\n",
    "def create_json_encoder(**kwargs):\n",
    "    class JSONEncoder(json.JSONEncoder):\n",
    "\n",
    "        @classmethod\n",
    "        def _filter_params(cls, op, nop):\n",
    "            params = set(op) | set(nop)\n",
    "            return {key: kwargs[key] for key in set(kwargs) & (params)}\n",
    "\n",
    "        def default(self, obj):\n",
    "            if hasattr(obj, \"__json__\"):\n",
    "                fdata = FunctionMetadata.from_function(obj.__json__)\n",
    "                params = self._filter_params(\n",
    "                    fdata.optional_params, fdata.non_optional_params)\n",
    "                return obj.__json__(**params)\n",
    "            elif isinstance(obj, collections.Iterable):\n",
    "                return list(obj)\n",
    "            elif isinstance(obj, datetime):\n",
    "                return obj.isoformat()\n",
    "            elif hasattr(obj, \"__getitem__\") and hasattr(obj, \"keys\"):\n",
    "                return dict(obj)\n",
    "            elif hasattr(obj, \"__dict__\"):\n",
    "                return {member: getattr(obj, member)\n",
    "                        for member in get_public_members(obj)}\n",
    "\n",
    "            return json.JSONEncoder.default(self, obj)\n",
    "    return JSONEncoder\n"
  ],
  "/home/tushar/coala/coalib/output/Tagging.py": [
    "import hashlib\n",
    "import os\n",
    "import pickle\n",
    "\n",
    "from coalib.misc import Constants\n",
    "\n",
    "\n",
    "def get_tags_dir(log_printer):\n",
    "    try:\n",
    "        os.makedirs(Constants.TAGS_DIR, exist_ok=True)\n",
    "        return Constants.TAGS_DIR\n",
    "    except PermissionError:\n",
    "        log_printer.err(\"Unable to create tags directory '{}'. Continuing \"\n",
    "                        \"without tagging.\".format(Constants.TAGS_DIR))\n",
    "    return None\n",
    "\n",
    "\n",
    "def get_tag_path(tag, project, log_printer):\n",
    "    \"\"\"\n",
    "    Creates a hash value that is used for tagging and creates a path for it.\n",
    "\n",
    "    :param tag:         The name for the tag.\n",
    "    :param project:     The related coafile.\n",
    "    :param log_printer: The logger which logs errors.\n",
    "    :return:            A path containing a hash as filename that identifies the\n",
    "                        given parameters.\n",
    "    \"\"\"\n",
    "    path = os.path.join(project, tag)\n",
    "    hash = hashlib.sha224(path.encode()).hexdigest()\n",
    "    tags_dir = get_tags_dir(log_printer)\n",
    "    if tags_dir is not None:\n",
    "        return os.path.join(tags_dir, hash)\n",
    "    return None\n",
    "\n",
    "\n",
    "def tag_results(tag, project, results, log_printer):\n",
    "    \"\"\"\n",
    "    This method takes a tag provided from the user and saves the results\n",
    "    dictionary output by coala to a file. That file is uniquely identified by\n",
    "    the combined hash of the project (i.e. coafile) and the provided tag.\n",
    "\n",
    "    :param tag:         Tag provided by user.\n",
    "    :param project:     Path to the coafile the results belong to.\n",
    "    :param log_printer: The logger which logs errors.\n",
    "    :param results:     Results dictionary generated by coala.\n",
    "    \"\"\"\n",
    "    if tag == \"None\":\n",
    "        return\n",
    "    tag_path = get_tag_path(tag, project, log_printer)\n",
    "    if tag_path is not None:\n",
    "        with open(tag_path, 'wb+') as file:\n",
    "            pickle.dump(results, file)\n",
    "\n",
    "\n",
    "def load_tagged_results(tag, project, log_printer):\n",
    "    \"\"\"\n",
    "    Retrieves results previously stored with tag_results.\n",
    "\n",
    "    :param tag:         The tag name.\n",
    "    :param project:     Path to the coafile the results belong to.\n",
    "    :param log_printer: The logger which logs errors.\n",
    "    :return:            A results dictionary, as generated by coala.\n",
    "    \"\"\"\n",
    "    if tag == \"None\":\n",
    "        return None\n",
    "    tag_path = get_tag_path(tag, project, log_printer)\n",
    "    if tag_path is not None:\n",
    "        with open(tag_path, 'rb') as file:\n",
    "            return pickle.load(file)\n",
    "    return None\n",
    "\n",
    "\n",
    "def delete_tagged_results(tag, project, log_printer):\n",
    "    \"\"\"\n",
    "    Deletes previously tagged results.\n",
    "\n",
    "    :param tag:         The tag name.\n",
    "    :param project:     Path to the coafile the results belong to.\n",
    "    :param log_printer: The logger which logs errors.\n",
    "    \"\"\"\n",
    "    if tag == \"None\":\n",
    "        return\n",
    "    tag_path = get_tag_path(tag, project, log_printer)\n",
    "    if tag_path is not None and os.path.exists(tag_path):\n",
    "        os.remove(tag_path)\n"
  ],
  "/home/tushar/coala/coalib/output/__init__.py": [],
  "/home/tushar/coala/coalib/output/dbus/BuildDbusService.py": [
    "from distutils.core import Command\n",
    "from distutils.errors import DistutilsOptionError\n",
    "\n",
    "from coalib import BUS_NAME\n",
    "\n",
    "\n",
    "class BuildDbusService(Command):\n",
    "    \"\"\"\n",
    "    Add a ``build_dbus`` command  to your setup.py.\n",
    "    To use this Command class add a command to call this class::\n",
    "\n",
    "        # For setuptools\n",
    "        setup(\n",
    "              entry_points={\n",
    "                \"distutils.commands\": [\n",
    "                    \"build_dbus = \"\n",
    "                    \"coalib.misc.BuildDbusService:BuildDbusService\"\n",
    "                ]\n",
    "              }\n",
    "        )\n",
    "\n",
    "        # For distutils\n",
    "        from coalib.misc.BuildDbusService import BuildDbusService\n",
    "        setup(\n",
    "              cmdclass={'build_dbus': BuildDbusService}\n",
    "        )\n",
    "\n",
    "    You can then use the following setup command to produce a dbus service::\n",
    "\n",
    "        $ python setup.py build_dbus\n",
    "    \"\"\"\n",
    "    user_options = [('output=', 'O', 'output file')]\n",
    "\n",
    "    def initialize_options(self):\n",
    "        self.output = None\n",
    "\n",
    "    def finalize_options(self):\n",
    "        if self.output is None:\n",
    "            raise DistutilsOptionError('\\'output\\' option is required')\n",
    "        self.announce('Writing dbus service %s' % self.output)\n",
    "\n",
    "    def run(self):\n",
    "        dist = self.distribution\n",
    "        dbus_service = (\"[D-BUS Service]\\n\"\n",
    "                        \"Names=\" + BUS_NAME + \"\\n\"\n",
    "                        \"Exec=coala-dbus\")\n",
    "\n",
    "        with open(self.output, 'w') as f:\n",
    "            f.write(dbus_service)\n"
  ],
  "/home/tushar/coala/coalib/output/dbus/DbusApp.py": [
    "import os\n",
    "\n",
    "from coalib.output.dbus.DbusDocument import DbusDocument\n",
    "\n",
    "\n",
    "class DbusApp:\n",
    "    \"\"\"\n",
    "    Stores data about each client that connects to the DbusServer\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, app_id, name=\"\"):\n",
    "        self.app_id = app_id\n",
    "        self.name = name\n",
    "\n",
    "        self.docs = {}\n",
    "        self.__next_doc_id = 0\n",
    "\n",
    "    def _next_doc_id(self):\n",
    "        self.__next_doc_id += 1\n",
    "        return self.__next_doc_id\n",
    "\n",
    "    def create_document(self, path):\n",
    "        \"\"\"\n",
    "        Create a new dbus document.\n",
    "\n",
    "        :param path:        The path to the document to be created.\n",
    "        :param object_path: The dbus object path to use as the base for the\n",
    "                            document object path.\n",
    "        :param object_path: The connection to which the new ddocument object\n",
    "                            path should be added.\n",
    "        :return:            a DbusDocument object.\n",
    "        \"\"\"\n",
    "        path = os.path.abspath(os.path.expanduser(path))\n",
    "        doc = DbusDocument(doc_id=self._next_doc_id(), path=path)\n",
    "        self.docs[path] = doc\n",
    "\n",
    "        return doc\n",
    "\n",
    "    def dispose_document(self, path):\n",
    "        \"\"\"\n",
    "        Dispose of the document with the given path. It fails silently if the\n",
    "        document does not exist. If there are no more documents in the app,\n",
    "        the app is disposed.\n",
    "\n",
    "        :param path: The path to the document.\n",
    "        \"\"\"\n",
    "        path = os.path.abspath(os.path.expanduser(path))\n",
    "        try:\n",
    "            return self.docs.pop(path)\n",
    "        except KeyError:\n",
    "            return None\n"
  ],
  "/home/tushar/coala/coalib/output/dbus/DbusDocument.py": [
    "import os\n",
    "\n",
    "import dbus.service  # Ignore PyImportSortBear\n",
    "\n",
    "from coalib.misc.Exceptions import get_exitcode\n",
    "from coalib.output.Interactions import fail_acquire_settings\n",
    "from coalib.output.printers.ListLogPrinter import ListLogPrinter\n",
    "from coalib.parsing.Globbing import fnmatch\n",
    "from coalib.processes.Processing import execute_section\n",
    "from coalib.results.HiddenResult import HiddenResult\n",
    "from coalib.settings.ConfigurationGathering import (\n",
    "    find_user_config, gather_configuration)\n",
    "from coalib.settings.Setting import glob_list\n",
    "\n",
    "\n",
    "class DbusDocument(dbus.service.Object):\n",
    "    interface = \"org.coala_analyzer.v1\"\n",
    "\n",
    "    def __init__(self, doc_id, path=\"\"):\n",
    "        \"\"\"\n",
    "        Creates a new dbus object-path for every document that a\n",
    "        DbusApplication wants coala to analyze. It stores the information\n",
    "        (path) of the document and the config file to use when analyzing the\n",
    "        given document.\n",
    "\n",
    "        :param doc_id: An id for the document.\n",
    "        :param path:   The path to the document.\n",
    "        \"\"\"\n",
    "        dbus.service.Object.__init__(self)\n",
    "\n",
    "        self.config_file = \"\"\n",
    "        self.path = path\n",
    "        self.doc_id = doc_id\n",
    "\n",
    "    @dbus.service.method(interface,\n",
    "                         in_signature=\"\",\n",
    "                         out_signature=\"s\")\n",
    "    def FindConfigFile(self):\n",
    "        \"\"\"\n",
    "        This method uses the path of the document to identify a user config\n",
    "        file for it\n",
    "\n",
    "        :return: The config file path\n",
    "        \"\"\"\n",
    "        if self.path == \"\":\n",
    "            return \"\"\n",
    "\n",
    "        self.config_file = find_user_config(self.path)\n",
    "        return self.config_file\n",
    "\n",
    "    @dbus.service.method(interface,\n",
    "                         in_signature=\"s\",\n",
    "                         out_signature=\"s\")\n",
    "    def SetConfigFile(self, config_file):\n",
    "        \"\"\"\n",
    "        This method sets the config file to use. It has to be an absolute path,\n",
    "        as otherwise it is difficult to find it.\n",
    "\n",
    "        :param config_file: The path fo the config file to use. This has to be\n",
    "                            an absolute path\n",
    "        :return:            The config path which has been used\n",
    "        \"\"\"\n",
    "        self.config_file = config_file\n",
    "        return self.config_file\n",
    "\n",
    "    @dbus.service.method(interface,\n",
    "                         in_signature=\"\",\n",
    "                         out_signature=\"s\")\n",
    "    def GetConfigFile(self):\n",
    "        \"\"\"\n",
    "        This method gets the config file which is being used\n",
    "\n",
    "        :return: The config path which is being used\n",
    "        \"\"\"\n",
    "        return self.config_file\n",
    "\n",
    "    # Signature explanation:\n",
    "    # s -> string\n",
    "    # b -> boolean\n",
    "    # i -> integer (32bit)\n",
    "    # a -> array (list of tuple in python)\n",
    "    # () -> structure (or tuple in python)\n",
    "    # a{ss} -> dictionary with string keys and string values\n",
    "    @dbus.service.method(interface,\n",
    "                         in_signature=\"\",\n",
    "                         out_signature=\"(iaa{ss}a(sbaa{ss}))\")\n",
    "    def Analyze(self):\n",
    "        \"\"\"\n",
    "        This method analyzes the document and sends back the result\n",
    "\n",
    "        :return: The output is structure which has 3 items:\n",
    "                 -  The exitcode from the analysis.\n",
    "                 -  List of logs from the analysis.\n",
    "                 -  List of information about each section that contains:\n",
    "\n",
    "                    -  The name of the section.\n",
    "                    -  Boolean which is true if all bears in the section\n",
    "                       executed successfully.\n",
    "                    -  List of results where each result is a string\n",
    "                       dictionary which contains:\n",
    "                       id, origin, message, file, line_nr, severity\n",
    "        \"\"\"\n",
    "        retval = []\n",
    "        if self.path == \"\" or self.config_file == \"\":\n",
    "            return retval\n",
    "\n",
    "        args = [\"--config=\" + self.config_file]\n",
    "\n",
    "        log_printer = ListLogPrinter()\n",
    "        exitcode = 0\n",
    "        try:\n",
    "            yielded_results = False\n",
    "            (sections,\n",
    "             local_bears,\n",
    "             global_bears,\n",
    "             targets) = gather_configuration(fail_acquire_settings,\n",
    "                                             log_printer,\n",
    "                                             arg_list=args)\n",
    "\n",
    "            for section_name in sections:\n",
    "                section = sections[section_name]\n",
    "\n",
    "                if not section.is_enabled(targets):\n",
    "                    continue\n",
    "\n",
    "                if any([fnmatch(self.path, file_pattern)\n",
    "                        for file_pattern in glob_list(section[\"files\"])]):\n",
    "\n",
    "                    section[\"files\"].value = self.path\n",
    "                    section_result = execute_section(\n",
    "                        section=section,\n",
    "                        global_bear_list=global_bears[section_name],\n",
    "                        local_bear_list=local_bears[section_name],\n",
    "                        print_results=lambda *args: True,\n",
    "                        log_printer=log_printer)\n",
    "                    yielded_results = yielded_results or section_result[0]\n",
    "\n",
    "                    retval.append(\n",
    "                        DbusDocument.results_to_dbus_struct(section_result,\n",
    "                                                            section_name))\n",
    "\n",
    "            if yielded_results:\n",
    "                exitcode = 1\n",
    "        except BaseException as exception:  # pylint: disable=broad-except\n",
    "            exitcode = exitcode or get_exitcode(exception, log_printer)\n",
    "\n",
    "        logs = [log.to_string_dict() for log in log_printer.logs]\n",
    "        return (exitcode, logs, retval)\n",
    "\n",
    "    @staticmethod\n",
    "    def results_to_dbus_struct(section_result, section_name):\n",
    "        \"\"\"\n",
    "        Converts the result tuple given by execute_section() - which has\n",
    "        dictionaries and classes inside it - into a purely array based format\n",
    "        as dbus protocol only allows arrays.\n",
    "\n",
    "        :param section_result: The result tuple given by execute_section()\n",
    "                               for a section\n",
    "        :param section_name:   The name of the section\n",
    "        :return:               The result for a section in the form of an\n",
    "                               array which is sendable through dbus.\n",
    "        \"\"\"\n",
    "        results_for_section = []\n",
    "        for i in range(1, 3):  # Loop over bear types - local, global\n",
    "\n",
    "            # Loop over every file affected for local bears\n",
    "            # and every bear for global bears\n",
    "            for key, value in section_result[i].items():\n",
    "\n",
    "                # Loop over every result for a file\n",
    "                results_for_section += [result.to_string_dict()\n",
    "                                        for result in filter(\n",
    "                        lambda x: not isinstance(x, HiddenResult),\n",
    "                        value)]\n",
    "\n",
    "        return [section_name, section_result[0], results_for_section]\n",
    "\n",
    "    @property\n",
    "    def path(self):\n",
    "        return self._path\n",
    "\n",
    "    @path.setter\n",
    "    def path(self, new_path):\n",
    "        if new_path:\n",
    "            new_path = os.path.abspath(os.path.expanduser(new_path))\n",
    "        self._path = new_path\n"
  ],
  "/home/tushar/coala/coalib/output/dbus/DbusServer.py": [
    "import os\n",
    "\n",
    "import dbus.service  # Ignore PyImportSortBear\n",
    "\n",
    "from coalib.output.dbus.DbusApp import DbusApp\n",
    "\n",
    "\n",
    "class DbusServer(dbus.service.Object):\n",
    "    interface = \"org.coala_analyzer.v1\"\n",
    "\n",
    "    def __init__(self, bus, path, on_disconnected=None):\n",
    "        \"\"\"\n",
    "        Creates a new DbusServer class which handles the dynamic creation and\n",
    "        disposal of dbus object-paths for documents and also handles\n",
    "        information about DbusApplication.\n",
    "\n",
    "        :param bus:             The dbus bus to which to connect this object\n",
    "                                path to.\n",
    "        :param path:            The path in the dbus bus using which apps can\n",
    "                                communicate.\n",
    "        :param on_disconnected: This function will be called when the\n",
    "                                DbusServer has no more applications connected\n",
    "                                to it.\n",
    "        \"\"\"\n",
    "        dbus.service.Object.__init__(self, bus, path)\n",
    "\n",
    "        self.apps = {}\n",
    "        self.__next_app_id = 0\n",
    "        self.on_disconnected = on_disconnected\n",
    "\n",
    "        bus.add_signal_receiver(self._on_name_lost,\n",
    "                                signal_name='NameOwnerChanged',\n",
    "                                dbus_interface=None,\n",
    "                                path=None)\n",
    "\n",
    "    @dbus.service.method(interface,\n",
    "                         in_signature=\"s\",\n",
    "                         out_signature=\"o\",\n",
    "                         sender_keyword=\"sender\")\n",
    "    def CreateDocument(self, path, sender=None):\n",
    "        \"\"\"\n",
    "        Creates a DbusDocument if it doesn't exist.\n",
    "\n",
    "        :param path:   The path to the document.\n",
    "        :param sender: The client who created the dbus request - this is used\n",
    "                       as the DbusApp's name.\n",
    "        :return:       a DbusDocument object.\n",
    "        \"\"\"\n",
    "        app = self.get_or_create_app(sender)\n",
    "        doc = self.get_or_create_document(app, path)\n",
    "        return doc._object_path\n",
    "\n",
    "    @dbus.service.method(interface,\n",
    "                         in_signature=\"s\",\n",
    "                         out_signature=\"\",\n",
    "                         sender_keyword=\"sender\")\n",
    "    def DisposeDocument(self, path, sender=None):\n",
    "        \"\"\"\n",
    "        Disposes a DbusDocument if it exists. Fails silently if it does not\n",
    "        exist.\n",
    "\n",
    "        :param path:   The path to the document.\n",
    "        :param sender: The client who created the dbus request - this is used\n",
    "                       as the DbusApp's name to search for the document in.\n",
    "        \"\"\"\n",
    "        path = os.path.normpath(path)\n",
    "\n",
    "        try:\n",
    "            app = self.apps[sender]\n",
    "        except KeyError:\n",
    "            return\n",
    "\n",
    "        self.dispose_document(app, path)\n",
    "\n",
    "    def _on_name_lost(self, name, oldowner, newowner):\n",
    "        if newowner != '':\n",
    "            return\n",
    "\n",
    "        self.dispose_app(oldowner)\n",
    "\n",
    "    def _next_app_id(self):\n",
    "        self.__next_app_id += 1\n",
    "        return self.__next_app_id\n",
    "\n",
    "    def create_app(self, appname):\n",
    "        \"\"\"\n",
    "        Create a new dbus app with the given appname.\n",
    "\n",
    "        :param appname: The name of the app to be created.\n",
    "        :return:        a DbusApp object.\n",
    "        \"\"\"\n",
    "        self.apps[appname] = DbusApp(self._next_app_id(), appname)\n",
    "        return self.apps[appname]\n",
    "\n",
    "    def get_or_create_app(self, appname):\n",
    "        \"\"\"\n",
    "        Get the dbus app with the given appname. If there does not exist any\n",
    "        app with the given name, a new app is created and returned.\n",
    "\n",
    "        :param appname: The name of the app to be created.\n",
    "        :return:        A DbusApp object.\n",
    "        \"\"\"\n",
    "        try:\n",
    "            return self.apps[appname]\n",
    "        except KeyError:\n",
    "            return self.create_app(appname)\n",
    "\n",
    "    def dispose_app(self, appname):\n",
    "        \"\"\"\n",
    "        Dispose of the app with the given name. It fails silently if the app\n",
    "        does not exist. If there are no more apps connected to the server, it\n",
    "        calls the on_disconnected callback.\n",
    "\n",
    "        :param appname: The name of the app to dispose of.\n",
    "        \"\"\"\n",
    "        try:\n",
    "            self.apps.pop(appname)\n",
    "            if len(self.apps) == 0 and self.on_disconnected:\n",
    "                self.on_disconnected()\n",
    "        except KeyError:\n",
    "            pass\n",
    "\n",
    "    def create_document(self, app, path):\n",
    "        \"\"\"\n",
    "        Create a new dbus document.\n",
    "\n",
    "        :param app:  The DbusApp the document is related to.\n",
    "        :param path: The path to the document to be created.\n",
    "        :return:     a DbusDocument object.\n",
    "        \"\"\"\n",
    "        doc = app.create_document(path)\n",
    "        objpath = (self._object_path + \"/\" + str(app.app_id) +\n",
    "                   \"/documents/\" + str(doc.doc_id))\n",
    "        doc.add_to_connection(self._connection, objpath)\n",
    "\n",
    "        return doc\n",
    "\n",
    "    def get_or_create_document(self, app, path):\n",
    "        \"\"\"\n",
    "        Get the dbus document with the given path. If there does not exist any\n",
    "        document under the DbusApp with the given path, a new document is\n",
    "        created and returned.\n",
    "\n",
    "        :param app:  The DbusApp the document is under.\n",
    "        :param path: The path to the document to be created.\n",
    "        :return:     A DbusApp object.\n",
    "        \"\"\"\n",
    "        path = os.path.abspath(os.path.expanduser(path))\n",
    "        try:\n",
    "            doc = app.docs[path]\n",
    "        except KeyError:\n",
    "            doc = self.create_document(app, path)\n",
    "\n",
    "        return doc\n",
    "\n",
    "    def dispose_document(self, app, path):\n",
    "        \"\"\"\n",
    "        Dispose of the document with the given path. It fails silently if the\n",
    "        document does not exist. If there are no more documents in the app,\n",
    "        the app is disposed.\n",
    "\n",
    "        :param app:  The DbusApp the document is under.\n",
    "        :param path: The path to the document.\n",
    "        \"\"\"\n",
    "        doc = app.dispose_document(path)\n",
    "        if doc != None:\n",
    "            doc.remove_from_connection()\n",
    "            if len(app.docs) == 0:\n",
    "                self.dispose_app(app.name)\n"
  ],
  "/home/tushar/coala/coalib/output/dbus/__init__.py": [
    "\"\"\"\n",
    "This package holds dbus related objects. Dbus objects are used to communicate\n",
    "between coala and other applications using dbus.\n",
    "\n",
    "All dbus clients will first connect to the DbusServer, and request the\n",
    "DbusServer to create documents which can be analyzed. The DbusServer internally\n",
    "handles different clients separately so that it is possible for multiple\n",
    "clients to connect simultaneously.\n",
    "Once the client creates a document, the object path of the document is returned\n",
    "and the client can use it to analyze the document (which happens in the\n",
    "DbusDocument.\n",
    "\"\"\"\n"
  ],
  "/home/tushar/coala/coalib/output/printers/LOG_LEVEL.py": [
    "from coalib.misc.Enum import enum\n",
    "\n",
    "LOG_LEVEL = enum(\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\")\n",
    "LOG_LEVEL_COLORS = {LOG_LEVEL.ERROR: \"red\",\n",
    "                    LOG_LEVEL.WARNING: \"yellow\",\n",
    "                    LOG_LEVEL.INFO: \"blue\",\n",
    "                    LOG_LEVEL.DEBUG: \"green\"}\n"
  ],
  "/home/tushar/coala/coalib/output/printers/ListLogPrinter.py": [
    "from pyprint.Printer import Printer\n",
    "\n",
    "from coalib.output.printers.LOG_LEVEL import LOG_LEVEL\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "from coalib.processes.communication.LogMessage import LogMessage\n",
    "\n",
    "\n",
    "class ListLogPrinter(Printer, LogPrinter):\n",
    "    \"\"\"\n",
    "    A ListLogPrinter is a log printer which collects all LogMessages to a list\n",
    "    so that the logs can be used at a later time.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self,\n",
    "                 log_level=LOG_LEVEL.WARNING,\n",
    "                 timestamp_format=\"%X\"):\n",
    "        Printer.__init__(self)\n",
    "        LogPrinter.__init__(self, self, log_level, timestamp_format)\n",
    "\n",
    "        self.logs = []\n",
    "\n",
    "    def log_message(self, log_message, **kwargs):\n",
    "        if not isinstance(log_message, LogMessage):\n",
    "            raise TypeError(\"log_message should be of type LogMessage.\")\n",
    "\n",
    "        if log_message.log_level < self.log_level:\n",
    "            return\n",
    "\n",
    "        self.logs.append(log_message)\n",
    "\n",
    "    def _print(self, output, **kwargs):\n",
    "        self.info(output, **kwargs)\n"
  ],
  "/home/tushar/coala/coalib/output/printers/LogPrinter.py": [
    "import traceback\n",
    "\n",
    "from pyprint.ColorPrinter import ColorPrinter\n",
    "\n",
    "from coalib.output.printers.LOG_LEVEL import LOG_LEVEL, LOG_LEVEL_COLORS\n",
    "from coalib.processes.communication.LogMessage import LogMessage\n",
    "\n",
    "\n",
    "class LogPrinter:\n",
    "    \"\"\"\n",
    "    The LogPrinter class allows to print log messages to an underlying Printer.\n",
    "\n",
    "    This class is an adapter, means you can create a LogPrinter from every\n",
    "    existing Printer instance.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self,\n",
    "                 printer,\n",
    "                 log_level=LOG_LEVEL.INFO,\n",
    "                 timestamp_format=\"%X\"):\n",
    "        \"\"\"\n",
    "        Creates a new log printer from an existing Printer.\n",
    "\n",
    "        :param printer:          The underlying Printer where log messages\n",
    "                                 shall be written to. If you inherit from\n",
    "                                 LogPrinter, set it to self.\n",
    "        :param log_level:        The minimum log level, everything below will\n",
    "                                 not be logged.\n",
    "        :param timestamp_format: The format string for the\n",
    "                                 datetime.today().strftime(format) method.\n",
    "        \"\"\"\n",
    "        self._printer = printer\n",
    "        self.log_level = log_level\n",
    "        self.timestamp_format = timestamp_format\n",
    "\n",
    "    @property\n",
    "    def printer(self):\n",
    "        \"\"\"\n",
    "        Returns the underlying printer where logs are printed to.\n",
    "        \"\"\"\n",
    "        return self._printer\n",
    "\n",
    "    def _get_log_prefix(self, log_level, timestamp):\n",
    "        datetime_string = timestamp.strftime(self.timestamp_format)\n",
    "\n",
    "        if datetime_string != \"\":\n",
    "            datetime_string = \"[\" + datetime_string + \"]\"\n",
    "\n",
    "        return '[{}]{}'.format(LOG_LEVEL.reverse.get(log_level, \"ERROR\"),\n",
    "                               datetime_string)\n",
    "\n",
    "    def debug(self, *messages, delimiter=\" \", timestamp=None, **kwargs):\n",
    "        self.log_message(LogMessage(LOG_LEVEL.DEBUG,\n",
    "                                    *messages,\n",
    "                                    delimiter=delimiter,\n",
    "                                    timestamp=timestamp),\n",
    "                         **kwargs)\n",
    "\n",
    "    def info(self, *messages, delimiter=\" \", timestamp=None, **kwargs):\n",
    "        self.log_message(LogMessage(LOG_LEVEL.INFO,\n",
    "                                    *messages,\n",
    "                                    delimiter=delimiter,\n",
    "                                    timestamp=timestamp),\n",
    "                         **kwargs)\n",
    "\n",
    "    def warn(self, *messages, delimiter=\" \", timestamp=None, **kwargs):\n",
    "        self.log_message(LogMessage(LOG_LEVEL.WARNING,\n",
    "                                    *messages,\n",
    "                                    delimiter=delimiter,\n",
    "                                    timestamp=timestamp),\n",
    "                         **kwargs)\n",
    "\n",
    "    def err(self, *messages, delimiter=\" \", timestamp=None, **kwargs):\n",
    "        self.log_message(LogMessage(LOG_LEVEL.ERROR,\n",
    "                                    *messages,\n",
    "                                    delimiter=delimiter,\n",
    "                                    timestamp=timestamp),\n",
    "                         **kwargs)\n",
    "\n",
    "    def log(self, log_level, message, timestamp=None, **kwargs):\n",
    "        self.log_message(LogMessage(log_level,\n",
    "                                    message,\n",
    "                                    timestamp=timestamp),\n",
    "                         **kwargs)\n",
    "\n",
    "    def log_exception(self,\n",
    "                      message,\n",
    "                      exception,\n",
    "                      log_level=LOG_LEVEL.ERROR,\n",
    "                      timestamp=None,\n",
    "                      **kwargs):\n",
    "        \"\"\"\n",
    "        If the log_level of the printer is greater than DEBUG, it prints\n",
    "        only the message. If it is DEBUG or lower, it shows the message\n",
    "        along with the traceback of the exception.\n",
    "\n",
    "        :param message:   The message to print.\n",
    "        :param exception: The exception to print.\n",
    "        :param log_level: The log_level of this message (not used when\n",
    "                          logging the traceback. Tracebacks always have\n",
    "                          a level of DEBUG).\n",
    "        :param timestamp: The time at which this log occured. Defaults to\n",
    "                          the current time.\n",
    "        :param kwargs:    Keyword arguments to be passed when logging the\n",
    "                          message (not used when logging the traceback).\n",
    "        \"\"\"\n",
    "        if not isinstance(exception, BaseException):\n",
    "            raise TypeError(\"log_exception can only log derivatives of \"\n",
    "                            \"BaseException.\")\n",
    "\n",
    "        traceback_str = \"\\n\".join(\n",
    "            traceback.format_exception(type(exception),\n",
    "                                       exception,\n",
    "                                       exception.__traceback__))\n",
    "\n",
    "        self.log(log_level, message, timestamp=timestamp, **kwargs)\n",
    "        self.log_message(\n",
    "            LogMessage(LOG_LEVEL.DEBUG,\n",
    "                       \"Exception was:\" + \"\\n\" + traceback_str,\n",
    "                       timestamp=timestamp),\n",
    "            **kwargs)\n",
    "\n",
    "    def log_message(self, log_message, **kwargs):\n",
    "        if not isinstance(log_message, LogMessage):\n",
    "            raise TypeError(\"log_message should be of type LogMessage.\")\n",
    "\n",
    "        if log_message.log_level < self.log_level:\n",
    "            return\n",
    "\n",
    "        self._print_log_message(\n",
    "            self._get_log_prefix(log_message.log_level, log_message.timestamp),\n",
    "            log_message,\n",
    "            **kwargs)\n",
    "\n",
    "    def _print_log_message(self, prefix, log_message, **kwargs):\n",
    "        \"\"\"\n",
    "        Override this if you want to influence how the log message is printed.\n",
    "\n",
    "        If the underlying printer is a ColorPrinter, then colored logging is\n",
    "        used. You can turn it off in the underlying ColorPrinter if you want to\n",
    "        print uncolored.\n",
    "\n",
    "        :param prefix:      The prefix to print (as string).\n",
    "        :param log_message: The LogMessage object to print.\n",
    "        :param kwargs:      Any other keyword arguments.\n",
    "        \"\"\"\n",
    "        if isinstance(self._printer, ColorPrinter):\n",
    "            self.printer.print(prefix,\n",
    "                               end=\" \",\n",
    "                               color=LOG_LEVEL_COLORS[log_message.log_level],\n",
    "                               **kwargs)\n",
    "            self.printer.print(log_message.message, **kwargs)\n",
    "        else:\n",
    "            self.printer.print(prefix, log_message.message, **kwargs)\n"
  ],
  "/home/tushar/coala/coalib/output/printers/__init__.py": [
    "\"\"\"\n",
    "This package holds printer objects. Printer objects are general purpose and not\n",
    "tied to coala.\n",
    "\n",
    "If you need logging capabilities please take a look at the LogPrinter object\n",
    "which adds logging capabilities \"for free\" if used as base class for any other\n",
    "printer.\n",
    "\"\"\"\n"
  ],
  "/home/tushar/coala/coalib/parsing/CliParsing.py": [
    "import os\n",
    "import sys\n",
    "from argparse import ArgumentParser\n",
    "from collections import OrderedDict\n",
    "\n",
    "from coalib.parsing.DefaultArgParser import default_arg_parser\n",
    "from coalib.parsing.LineParser import LineParser\n",
    "from coalib.settings.Section import Section, append_to_sections\n",
    "\n",
    "\n",
    "def parse_cli(arg_list=None,\n",
    "              origin=os.getcwd(),\n",
    "              arg_parser=None,\n",
    "              key_value_delimiters=('=', ':'),\n",
    "              comment_seperators=(),\n",
    "              key_delimiters=(',',),\n",
    "              section_override_delimiters=(\".\",)):\n",
    "    \"\"\"\n",
    "    Parses the CLI arguments and creates sections out of it.\n",
    "\n",
    "    :param arg_list:                    The CLI argument list.\n",
    "    :param origin:                      Directory used to interpret relative\n",
    "                                        paths given as argument.\n",
    "    :param arg_parser:                  Instance of ArgParser that is used to\n",
    "                                        parse none-setting arguments.\n",
    "    :param key_value_delimiters:        Delimiters to separate key and value\n",
    "                                        in setting arguments.\n",
    "    :param comment_seperators:          Allowed prefixes for comments.\n",
    "    :param key_delimiters:              Delimiter to separate multiple keys of\n",
    "                                        a setting argument.\n",
    "    :param section_override_delimiters: The delimiter to delimit the section\n",
    "                                        from the key name (e.g. the '.' in\n",
    "                                        sect.key = value).\n",
    "    :return:                            A dictionary holding section names\n",
    "                                        as keys and the sections themselves\n",
    "                                        as value.\n",
    "    \"\"\"\n",
    "    # Note: arg_list can also be []. Hence we cannot use\n",
    "    # `arg_list = arg_list or default_list`\n",
    "    arg_list = sys.argv[1:] if arg_list is None else arg_list\n",
    "    arg_parser = arg_parser or default_arg_parser()\n",
    "    origin += os.path.sep\n",
    "    sections = OrderedDict(default=Section('Default'))\n",
    "    line_parser = LineParser(key_value_delimiters,\n",
    "                             comment_seperators,\n",
    "                             key_delimiters,\n",
    "                             {},\n",
    "                             section_override_delimiters)\n",
    "\n",
    "    for arg_key, arg_value in sorted(\n",
    "            vars(arg_parser.parse_args(arg_list)).items()):\n",
    "        if arg_key == 'settings' and arg_value is not None:\n",
    "            parse_custom_settings(sections,\n",
    "                                  arg_value,\n",
    "                                  origin,\n",
    "                                  line_parser)\n",
    "        else:\n",
    "            if isinstance(arg_value, list):\n",
    "                arg_value = \",\".join([str(val) for val in arg_value])\n",
    "\n",
    "            append_to_sections(sections,\n",
    "                               arg_key,\n",
    "                               arg_value,\n",
    "                               origin,\n",
    "                               from_cli=True)\n",
    "\n",
    "    return sections\n",
    "\n",
    "\n",
    "def parse_custom_settings(sections,\n",
    "                          custom_settings_list,\n",
    "                          origin,\n",
    "                          line_parser):\n",
    "    \"\"\"\n",
    "    Parses the custom settings given to coala via ``-S something=value``.\n",
    "\n",
    "    :param sections:             The Section dictionary to add to (mutable).\n",
    "    :param custom_settings_list: The list of settings strings.\n",
    "    :param origin:               The originating directory.\n",
    "    :param line_parser:          The LineParser to use.\n",
    "    \"\"\"\n",
    "    for setting_definition in custom_settings_list:\n",
    "        (_, key_touples, value, _) = line_parser.parse(setting_definition)\n",
    "        for key_touple in key_touples:\n",
    "            append_to_sections(sections,\n",
    "                               key=key_touple[1],\n",
    "                               value=value,\n",
    "                               origin=origin,\n",
    "                               section_name=key_touple[0],\n",
    "                               from_cli=True)\n",
    "\n",
    "\n",
    "def check_conflicts(sections):\n",
    "    '''\n",
    "    Checks if there are any conflicting aruments passed\n",
    "\n",
    "    :return:            True if no conflicts\n",
    "    :raises SystemExit: If there are conflicting arguments (exit code: 2)\n",
    "    '''\n",
    "    conflicts = {'no_config': {'save', 'find_config'}}\n",
    "    conflicting_keys = conflicts.keys()\n",
    "\n",
    "    for section in sections:\n",
    "        keys = set(sections[section])\n",
    "        possible_conflicts = keys & conflicting_keys\n",
    "        for key in possible_conflicts:\n",
    "            intersection = keys & conflicts[key]\n",
    "            if len(intersection) > 0:\n",
    "                ArgumentParser().exit(2,\n",
    "                                      key + \" cannot be given at the same \"\n",
    "                                      \"time with \" + ', '.join(intersection))\n",
    "    return True\n"
  ],
  "/home/tushar/coala/coalib/parsing/ConfParser.py": [
    "import os\n",
    "from collections import OrderedDict\n",
    "\n",
    "from coalib.misc import Constants\n",
    "from coalib.parsing.LineParser import LineParser\n",
    "from coalib.settings.Section import Section\n",
    "from coalib.settings.Setting import Setting\n",
    "\n",
    "\n",
    "class ConfParser:\n",
    "\n",
    "    def __init__(self,\n",
    "                 key_value_delimiters=('=',),\n",
    "                 comment_seperators=('#',),\n",
    "                 key_delimiters=(',', ' '),\n",
    "                 section_name_surroundings=None,\n",
    "                 remove_empty_iter_elements=True):\n",
    "        section_name_surroundings = section_name_surroundings or {\"[\": \"]\"}\n",
    "\n",
    "        self.line_parser = LineParser(key_value_delimiters,\n",
    "                                      comment_seperators,\n",
    "                                      key_delimiters,\n",
    "                                      section_name_surroundings)\n",
    "\n",
    "        self.__remove_empty_iter_elements = remove_empty_iter_elements\n",
    "\n",
    "        # Declare it\n",
    "        self.sections = None\n",
    "        self.__rand_helper = None\n",
    "        self.__init_sections()\n",
    "\n",
    "    def parse(self, input_data, overwrite=False):\n",
    "        \"\"\"\n",
    "        Parses the input and adds the new data to the existing.\n",
    "\n",
    "        :param input_data: The filename to parse from.\n",
    "        :param overwrite:  If True, wipes all existing Settings inside this\n",
    "                           instance and adds only the newly parsed ones. If\n",
    "                           False, adds the newly parsed data to the existing\n",
    "                           one (and overwrites already existing keys with the\n",
    "                           newly parsed values).\n",
    "        :return:           A dictionary with (lowercase) section names as keys\n",
    "                           and their Setting objects as values.\n",
    "        \"\"\"\n",
    "        if os.path.isdir(input_data):\n",
    "            input_data = os.path.join(input_data, Constants.default_coafile)\n",
    "\n",
    "        with open(input_data, \"r\", encoding='utf-8') as _file:\n",
    "            lines = _file.readlines()\n",
    "\n",
    "        if overwrite:\n",
    "            self.__init_sections()\n",
    "\n",
    "        self.__parse_lines(lines, input_data)\n",
    "\n",
    "        return self.sections\n",
    "\n",
    "    def get_section(self, name, create_if_not_exists=False):\n",
    "        key = self.__refine_key(name)\n",
    "        sec = self.sections.get(key, None)\n",
    "        if sec is not None:\n",
    "            return sec\n",
    "\n",
    "        if not create_if_not_exists:\n",
    "            raise IndexError\n",
    "\n",
    "        retval = self.sections[key] = Section(str(name),\n",
    "                                              self.sections[\"default\"])\n",
    "        return retval\n",
    "\n",
    "    @staticmethod\n",
    "    def __refine_key(key):\n",
    "        return str(key).lower().strip()\n",
    "\n",
    "    def __add_comment(self, section, comment, origin):\n",
    "        key = \"comment\" + str(self.__rand_helper)\n",
    "        self.__rand_helper += 1\n",
    "        section.append(Setting(\n",
    "            key,\n",
    "            comment,\n",
    "            origin,\n",
    "            remove_empty_iter_elements=self.__remove_empty_iter_elements))\n",
    "\n",
    "    def __parse_lines(self, lines, origin):\n",
    "        current_section_name = \"default\"\n",
    "        current_section = self.get_section(current_section_name)\n",
    "        current_keys = []\n",
    "\n",
    "        for line in lines:\n",
    "            section_name, keys, value, comment = self.line_parser.parse(line)\n",
    "\n",
    "            if comment != \"\":\n",
    "                self.__add_comment(current_section, comment, origin)\n",
    "\n",
    "            if section_name != \"\":\n",
    "                current_section_name = section_name\n",
    "                current_section = self.get_section(current_section_name, True)\n",
    "                current_keys = []\n",
    "                continue\n",
    "\n",
    "            if comment == \"\" and keys == [] and value == \"\":\n",
    "                self.__add_comment(current_section, \"\", origin)\n",
    "                continue\n",
    "\n",
    "            if keys != []:\n",
    "                current_keys = keys\n",
    "\n",
    "            for section_override, key in current_keys:\n",
    "                if key == \"\":\n",
    "                    continue\n",
    "\n",
    "                if section_override == \"\":\n",
    "                    current_section.add_or_create_setting(\n",
    "                        Setting(key,\n",
    "                                value,\n",
    "                                origin,\n",
    "                                # Ignore PEP8Bear, it fails to format that\n",
    "                                remove_empty_iter_elements=\n",
    "                                self.__remove_empty_iter_elements),\n",
    "                        allow_appending=(keys == []))\n",
    "                else:\n",
    "                    self.get_section(\n",
    "                        section_override,\n",
    "                        True).add_or_create_setting(\n",
    "                            Setting(key,\n",
    "                                    value,\n",
    "                                    origin,\n",
    "                                    # Ignore PEP8Bear, it fails to format that\n",
    "                                    remove_empty_iter_elements=\n",
    "                                    self.__remove_empty_iter_elements),\n",
    "                            allow_appending=(keys == []))\n",
    "\n",
    "    def __init_sections(self):\n",
    "        self.sections = OrderedDict()\n",
    "        self.sections[\"default\"] = Section(\"Default\")\n",
    "        self.__rand_helper = 0\n"
  ],
  "/home/tushar/coala/coalib/parsing/DefaultArgParser.py": [
    "import argparse\n",
    "import sys\n",
    "\n",
    "from coalib.misc import Constants\n",
    "from coalib.collecting.Collectors import get_all_bears_names\n",
    "\n",
    "try:\n",
    "    from argcomplete.completers import ChoicesCompleter\n",
    "except ImportError:\n",
    "    class ChoicesCompleter:\n",
    "\n",
    "        def __init__(self, *args, **kwargs):\n",
    "            pass\n",
    "\n",
    "\n",
    "def default_arg_parser(formatter_class=None):\n",
    "    \"\"\"\n",
    "    This function creates an ArgParser to parse command line arguments.\n",
    "\n",
    "    :param formatter_class: Formatting the arg_parser output into a specific\n",
    "                            form. For example: In the manpage format.\n",
    "    \"\"\"\n",
    "    formatter_class = formatter_class or argparse.RawDescriptionHelpFormatter\n",
    "\n",
    "    entry_point = sys.argv[0]\n",
    "    for entry in ['coala-ci', 'coala-dbus', 'coala-format', 'coala-json',\n",
    "                  'coala-delete-orig']:\n",
    "        if entry_point.endswith(entry):\n",
    "            parser_type = entry\n",
    "            break\n",
    "    else:\n",
    "        parser_type = 'coala'\n",
    "\n",
    "    arg_parser = argparse.ArgumentParser(\n",
    "        formatter_class=formatter_class,\n",
    "        prog=\"coala\",\n",
    "        description=\"coala is a simple COde AnaLysis Application. Its goal \"\n",
    "                    \"is to make static code analysis easy and convenient \"\n",
    "                    \"for all languages. coala uses bears, which are analysis \"\n",
    "                    \"routines that can be combined arbitrarily.\")\n",
    "\n",
    "    arg_parser.add_argument('TARGETS',\n",
    "                            nargs='*',\n",
    "                            help=\"Sections to be executed exclusively.\")\n",
    "    arg_parser.add_argument('-c',\n",
    "                            '--config',\n",
    "                            nargs=1,\n",
    "                            metavar='FILE',\n",
    "                            help='Configuration file to be used, defaults to '\n",
    "                                 + repr(Constants.default_coafile))\n",
    "    FIND_CONFIG_HELP = ('Attempt to find config file by checking parent '\n",
    "                        'directories of the current working directory. It is '\n",
    "                        'assumed that the config file is named '\n",
    "                        + repr(Constants.default_coafile) + '. This arg is '\n",
    "                        'ignored if --config is also given')\n",
    "    arg_parser.add_argument('-F',\n",
    "                            '--find-config',\n",
    "                            nargs='?',\n",
    "                            const=True,\n",
    "                            metavar='BOOL',\n",
    "                            help=FIND_CONFIG_HELP)\n",
    "    arg_parser.add_argument('-I',\n",
    "                            '--no-config',\n",
    "                            nargs='?',\n",
    "                            const=True,\n",
    "                            metavar='BOOL',\n",
    "                            help=\"Run without using any config file\")\n",
    "    arg_parser.add_argument('-f',\n",
    "                            '--files',\n",
    "                            nargs='+',\n",
    "                            metavar='FILE',\n",
    "                            help='Files that should be checked')\n",
    "    arg_parser.add_argument('-i',\n",
    "                            '--ignore',\n",
    "                            nargs='+',\n",
    "                            metavar='FILE',\n",
    "                            help='Files that should be ignored')\n",
    "    arg_parser.add_argument('--limit-files',\n",
    "                            nargs='+',\n",
    "                            metavar='FILE',\n",
    "                            help='Files that will be analyzed will be '\n",
    "                                 'restricted to those in the globs listed '\n",
    "                                 'in this argument as well the files setting')\n",
    "    arg_parser.add_argument('-b',\n",
    "                            '--bears',\n",
    "                            nargs='+',\n",
    "                            metavar='NAME',\n",
    "                            help='Names of bears to use').completer =\\\n",
    "        ChoicesCompleter(get_all_bears_names())\n",
    "    BEAR_DIRS_HELP = 'Additional directories where bears may lie'\n",
    "    arg_parser.add_argument('-d',\n",
    "                            '--bear-dirs',\n",
    "                            nargs='+',\n",
    "                            metavar='DIR',\n",
    "                            help=BEAR_DIRS_HELP)\n",
    "    LOG_LEVEL_HELP = (\"Enum('ERROR','INFO','WARNING','DEBUG') to set level of \"\n",
    "                      \"log output\")\n",
    "    arg_parser.add_argument('-L',\n",
    "                            '--log-level',\n",
    "                            nargs=1,\n",
    "                            choices=['ERROR', 'INFO', 'WARNING', 'DEBUG'],\n",
    "                            metavar='ENUM',\n",
    "                            help=LOG_LEVEL_HELP)\n",
    "    MIN_SEVERITY_HELP = (\"Enum('INFO', 'NORMAL', 'MAJOR') to set the minimal \"\n",
    "                         \"result severity.\")\n",
    "    arg_parser.add_argument('-m',\n",
    "                            '--min-severity',\n",
    "                            nargs=1,\n",
    "                            choices=('INFO', 'NORMAL', 'MAJOR'),\n",
    "                            metavar='ENUM',\n",
    "                            help=MIN_SEVERITY_HELP)\n",
    "    SETTINGS_HELP = 'Arbitrary settings in the form of section.key=value'\n",
    "    arg_parser.add_argument('-S',\n",
    "                            '--settings',\n",
    "                            nargs='+',\n",
    "                            metavar='SETTING',\n",
    "                            help=SETTINGS_HELP)\n",
    "    if parser_type == 'coala-json':\n",
    "        arg_parser.add_argument('--text-logs',\n",
    "                                nargs='?',\n",
    "                                const=True,\n",
    "                                metavar='BOOL',\n",
    "                                help='Don\\'t display logs as json, display '\n",
    "                                     'them as we normally do in the console.')\n",
    "        arg_parser.add_argument('-o',\n",
    "                                '--output',\n",
    "                                nargs='?',\n",
    "                                const=True,\n",
    "                                metavar='BOOL',\n",
    "                                help='Write the logs as json to a file '\n",
    "                                'where filename is specified as argument.')\n",
    "    if parser_type == 'coala':\n",
    "        SHOW_BEARS_HELP = (\"Display bears and its metadata with the sections \"\n",
    "                           \"that they belong to\")\n",
    "        arg_parser.add_argument('-B',\n",
    "                                '--show-bears',\n",
    "                                nargs='?',\n",
    "                                const=True,\n",
    "                                metavar='BOOL',\n",
    "                                help=SHOW_BEARS_HELP)\n",
    "        arg_parser.add_argument('-A',\n",
    "                                '--show-all-bears',\n",
    "                                nargs='?',\n",
    "                                const=True,\n",
    "                                metavar='BOOL',\n",
    "                                help=\"Display all bears.\")\n",
    "        arg_parser.add_argument('-l',\n",
    "                                '--show-language-bears',\n",
    "                                nargs='+',\n",
    "                                metavar='LANG',\n",
    "                                help=\"Display all bears for the given \"\n",
    "                                \"languages.\")\n",
    "    SAVE_HELP = ('Filename of file to be saved to, if provided with no '\n",
    "                 'arguments, settings will be stored back to the file given '\n",
    "                 'by -c')\n",
    "    arg_parser.add_argument('-s',\n",
    "                            '--save',\n",
    "                            nargs='?',\n",
    "                            const=True,\n",
    "                            metavar='FILE',\n",
    "                            help=SAVE_HELP)\n",
    "    TAG_HELP = ('Tag results with a specific name. You can access the results'\n",
    "                ' later with that tag.')\n",
    "    arg_parser.add_argument('-t',\n",
    "                            '--tag',\n",
    "                            nargs='?',\n",
    "                            const=True,\n",
    "                            metavar='STRING',\n",
    "                            help=TAG_HELP)\n",
    "\n",
    "    DELETE_TAG_HELP = 'Delete pre-tagged results with tag name.'\n",
    "    arg_parser.add_argument('-g',\n",
    "                            '--dtag',\n",
    "                            nargs='?',\n",
    "                            const=True,\n",
    "                            metavar='STRING',\n",
    "                            help=DELETE_TAG_HELP)\n",
    "\n",
    "    arg_parser.add_argument(\"-j\",\n",
    "                            \"--jobs\",\n",
    "                            type=int,\n",
    "                            help=\"Number of jobs to use in parallel.\")\n",
    "\n",
    "    arg_parser.add_argument('-v',\n",
    "                            '--version',\n",
    "                            action='version',\n",
    "                            version=Constants.VERSION)\n",
    "\n",
    "    arg_parser.add_argument('-n',\n",
    "                            '--no-orig',\n",
    "                            nargs='?',\n",
    "                            const=True,\n",
    "                            help=\"Deactivate creation of .orig files,\"\n",
    "                                 \".orig backup files before applying patches\")\n",
    "    arg_parser.add_argument('-r',\n",
    "                            '--relpath',\n",
    "                            nargs='?',\n",
    "                            const=True,\n",
    "                            help=\"return relative paths for files\")\n",
    "\n",
    "    try:  # pragma: no cover\n",
    "        # Auto completion should be optional, because of somewhat complicated\n",
    "        # setup.\n",
    "        import argcomplete\n",
    "        argcomplete.autocomplete(arg_parser)\n",
    "    except ImportError:\n",
    "        pass\n",
    "    return arg_parser\n"
  ],
  "/home/tushar/coala/coalib/parsing/Globbing.py": [
    "import os\n",
    "import platform\n",
    "import re\n",
    "\n",
    "from coala_decorators.decorators import yield_once\n",
    "from coalib.misc.Constants import GLOBBING_SPECIAL_CHARS\n",
    "\n",
    "\n",
    "def _end_of_set_index(string, start_index):\n",
    "    \"\"\"\n",
    "    Returns the position of the appropriate closing bracket for a glob set in\n",
    "    string.\n",
    "\n",
    "    :param string:      Glob string with wildcards\n",
    "    :param start_index: Index at which the set starts, meaning the position\n",
    "                        right behind the opening bracket\n",
    "    :return:            Position of appropriate closing bracket\n",
    "    \"\"\"\n",
    "    length = len(string)\n",
    "    closing_index = start_index\n",
    "    if closing_index < length and string[closing_index] == '!':\n",
    "        closing_index += 1\n",
    "\n",
    "    if closing_index < length:  # the set cannot be closed by a bracket here\n",
    "        closing_index += 1\n",
    "\n",
    "    while closing_index < length and string[closing_index] != ']':\n",
    "        closing_index += 1\n",
    "\n",
    "    return closing_index\n",
    "\n",
    "\n",
    "def glob_escape(input_string):\n",
    "    \"\"\"\n",
    "    Escapes the given string with ``[c]`` pattern. Examples:\n",
    "\n",
    "    >>> from coalib.parsing.Globbing import glob_escape\n",
    "    >>> glob_escape('test (1)')\n",
    "    'test [(]1[)]'\n",
    "    >>> glob_escape('test folder?')\n",
    "    'test folder[?]'\n",
    "    >>> glob_escape('test*folder')\n",
    "    'test[*]folder'\n",
    "\n",
    "    :param input_string: String that is to be escaped with ``[ ]``.\n",
    "    :return:             Escaped string in which all the special glob characters\n",
    "                         ``()[]|?*`` are escaped.\n",
    "    \"\"\"\n",
    "    return re.sub(\"(?P<char>[\" + re.escape(GLOBBING_SPECIAL_CHARS) + \"])\",\n",
    "                  \"[\\\\g<char>]\", input_string)\n",
    "\n",
    "\n",
    "def _position_is_bracketed(string, position):\n",
    "    \"\"\"\n",
    "    Tests whether the char at string[position] is inside a valid pair of\n",
    "    brackets (and therefore loses its special meaning)\n",
    "\n",
    "    :param string:   Glob string with wildcards\n",
    "    :param position: Position of a char in string\n",
    "    :return:         Whether or not the char is inside a valid set of brackets\n",
    "    \"\"\"\n",
    "    # allow negative positions and trim too long ones\n",
    "    position = len(string[:position])\n",
    "\n",
    "    index, length = 0, len(string)\n",
    "    while index < position:\n",
    "        char = string[index]\n",
    "        index += 1\n",
    "        if char == '[':\n",
    "            closing_index = _end_of_set_index(string, index)\n",
    "            if closing_index < length:\n",
    "                if index <= position < closing_index:\n",
    "                    return True\n",
    "                index = closing_index + 1\n",
    "            else:\n",
    "                return False\n",
    "    return False\n",
    "\n",
    "\n",
    "def _boundary_of_alternatives_indices(pattern):\n",
    "    \"\"\"\n",
    "    Determines the location of a set of alternatives in a glob pattern.\n",
    "    Alternatives are defined by a matching set of non-bracketed parentheses.\n",
    "\n",
    "    :param pattern: Glob pattern with wildcards.\n",
    "    :return:        Indices of the innermost set of matching non-bracketed\n",
    "                    parentheses in a tuple. The Index of a missing parenthesis\n",
    "                    will be passed as None.\n",
    "    \"\"\"\n",
    "    # Taking the leftmost closing parenthesis and the rightmost opening\n",
    "    # parenthesis left of it ensures that the parentheses belong together and\n",
    "    # the pattern is parsed correctly from the most nested section outwards.\n",
    "    end_pos = None\n",
    "    for match in re.finditer('\\\\)', pattern):\n",
    "        if not _position_is_bracketed(pattern, match.start()):\n",
    "            end_pos = match.start()\n",
    "            break  # break to get leftmost\n",
    "\n",
    "    start_pos = None\n",
    "    for match in re.finditer('\\\\(', pattern[:end_pos]):\n",
    "        if not _position_is_bracketed(pattern, match.start()):\n",
    "            start_pos = match.end()\n",
    "            # no break to get rightmost\n",
    "\n",
    "    return start_pos, end_pos\n",
    "\n",
    "\n",
    "@yield_once\n",
    "def _iter_choices(pattern):\n",
    "    \"\"\"\n",
    "    Iterate through each choice of an alternative. Splits pattern on '|'s if\n",
    "    they are not bracketed.\n",
    "\n",
    "    :param pattern: String of choices separated by '|'s\n",
    "    :return:        Iterator that yields parts of string separated by\n",
    "                    non-bracketed '|'s\n",
    "    \"\"\"\n",
    "    start_pos = 0\n",
    "    split_pos_list = [match.start() for match in re.finditer('\\\\|', pattern)]\n",
    "    split_pos_list.append(len(pattern))\n",
    "    for end_pos in split_pos_list:\n",
    "        if not _position_is_bracketed(pattern, end_pos):\n",
    "            yield pattern[start_pos: end_pos]\n",
    "            start_pos = end_pos + 1\n",
    "\n",
    "\n",
    "@yield_once\n",
    "def _iter_alternatives(pattern):\n",
    "    \"\"\"\n",
    "    Iterates through all glob patterns that can be obtaines by combination of\n",
    "    all choices for each alternative\n",
    "\n",
    "    :param pattern: Glob pattern with wildcards\n",
    "    :return:        Iterator that yields all glob patterns without alternatives\n",
    "                    that can be created from the given pattern containing them.\n",
    "    \"\"\"\n",
    "    start_pos, end_pos = _boundary_of_alternatives_indices(pattern)\n",
    "\n",
    "    if None in (start_pos, end_pos):\n",
    "        yield pattern\n",
    "    else:\n",
    "        # iterate through choices inside of parenthesis (separated by '|'):\n",
    "        for choice in _iter_choices(pattern[start_pos: end_pos]):\n",
    "            # put glob expression back together with alternative:\n",
    "            variant = pattern[:start_pos-1] + choice + pattern[end_pos+1:]\n",
    "\n",
    "            # iterate through alternatives outside of parenthesis\n",
    "            # (pattern can have more alternatives elsewhere)\n",
    "            for glob_pattern in _iter_alternatives(variant):\n",
    "                yield glob_pattern\n",
    "\n",
    "\n",
    "def translate(pattern):\n",
    "    \"\"\"\n",
    "    Translates a pattern into a regular expression.\n",
    "\n",
    "    :param pattern: Glob pattern with wildcards\n",
    "    :return:        Regular expression with the same meaning\n",
    "    \"\"\"\n",
    "    index, length = 0, len(pattern)\n",
    "    regex = ''\n",
    "    while index < length:\n",
    "        char = pattern[index]\n",
    "        index += 1\n",
    "        if char == '*':\n",
    "            # '**' matches everything\n",
    "            if index < length and pattern[index] == '*':\n",
    "                regex += '.*'\n",
    "            # on Windows, '*' matches everything but the filesystem\n",
    "            # separators '/' and '\\'.\n",
    "            elif platform.system() == 'Windows':  # pragma: nocover (Windows)\n",
    "                regex += '[^/\\\\\\\\]*'\n",
    "            # on all other (~Unix-) platforms, '*' matches everything but the\n",
    "            # filesystem separator, most likely '/'.\n",
    "            else:\n",
    "                regex += '[^' + re.escape(os.sep) + ']*'\n",
    "        elif char == '?':\n",
    "            regex += '.'\n",
    "        elif char == '[':\n",
    "            closing_index = _end_of_set_index(pattern, index)\n",
    "            if closing_index >= length:\n",
    "                regex += '\\\\['\n",
    "            else:\n",
    "                sequence = pattern[index:closing_index].replace('\\\\', '\\\\\\\\')\n",
    "                index = closing_index+1\n",
    "                if sequence[0] == '!':\n",
    "                    sequence = '^' + sequence[1:]\n",
    "                elif sequence[0] == '^':\n",
    "                    sequence = '\\\\' + sequence\n",
    "                regex += '[' + sequence + ']'\n",
    "        else:\n",
    "            regex = regex + re.escape(char)\n",
    "    return regex + '\\\\Z(?ms)'\n",
    "\n",
    "\n",
    "def fnmatch(name, patterns):\n",
    "    \"\"\"\n",
    "    Tests whether name matches pattern\n",
    "\n",
    "    :param name:     File or directory name\n",
    "    :param patterns: Glob string with wildcards or list of globs\n",
    "    :return:         Boolean: Whether or not name is matched by pattern\n",
    "\n",
    "    Glob Syntax:\n",
    "\n",
    "    -  '[seq]':         Matches any character in seq. Cannot be empty. Any\n",
    "                        special character looses its special meaning in a set.\n",
    "    -  '[!seq]':        Matches any character not in seq. Cannot be empty. Any\n",
    "                        special character looses its special meaning in a set.\n",
    "    -  '(seq_a|seq_b)': Matches either sequence_a or sequence_b as a whole.\n",
    "                        More than two or just one sequence can be given.\n",
    "    -  '?':             Matches any single character.\n",
    "    -  '*':             Matches everything but os.sep.\n",
    "    -  '**':            Matches everything.\n",
    "    \"\"\"\n",
    "    if isinstance(patterns, str):\n",
    "        patterns = [patterns]\n",
    "    if len(patterns) == 0:\n",
    "        return True\n",
    "\n",
    "    name = os.path.normcase(name)\n",
    "    for pattern in patterns:\n",
    "        for pat in _iter_alternatives(pattern):\n",
    "            pat = os.path.expanduser(pat)\n",
    "            pat = os.path.normcase(pat)\n",
    "            match = re.compile(translate(pat)).match\n",
    "            if match(name) is not None:\n",
    "                return True\n",
    "    return False\n",
    "\n",
    "\n",
    "def _absolute_flat_glob(pattern):\n",
    "    \"\"\"\n",
    "    Glob function for a pattern that do not contain wildcards.\n",
    "\n",
    "    :pattern: File or directory path\n",
    "    :return:  Iterator that yields at most one valid file or dir name\n",
    "    \"\"\"\n",
    "    dirname, basename = os.path.split(pattern)\n",
    "\n",
    "    if basename:\n",
    "        if os.path.exists(pattern):\n",
    "            yield pattern\n",
    "    else:\n",
    "        # Patterns ending with a slash should match only directories\n",
    "        if os.path.isdir(dirname):\n",
    "            yield pattern\n",
    "    return\n",
    "\n",
    "\n",
    "def _iter_relative_dirs(dirname):\n",
    "    \"\"\"\n",
    "    Recursively iterates subdirectories of all levels from dirname\n",
    "\n",
    "    :param dirname: Directory name\n",
    "    :return:        Iterator that yields files and directory from the given dir\n",
    "                    and all it's (recursive) subdirectories\n",
    "    \"\"\"\n",
    "    if not dirname:\n",
    "        dirname = os.curdir\n",
    "    try:\n",
    "        files_or_dirs = os.listdir(dirname)\n",
    "    except os.error:\n",
    "        return\n",
    "    for file_or_dir in files_or_dirs:\n",
    "        yield file_or_dir\n",
    "        path = os.path.join(dirname, file_or_dir)\n",
    "        for sub_file_or_dir in _iter_relative_dirs(path):\n",
    "            yield os.path.join(file_or_dir, sub_file_or_dir)\n",
    "\n",
    "\n",
    "def relative_wildcard_glob(dirname, pattern):\n",
    "    \"\"\"\n",
    "    Non-recursive glob for one directory. Accepts wildcards.\n",
    "\n",
    "    :param dirname: Directory name\n",
    "    :param pattern: Glob pattern with wildcards\n",
    "    :return:        List of files in the dir of dirname that match the pattern\n",
    "    \"\"\"\n",
    "    if not dirname:\n",
    "        dirname = os.curdir\n",
    "    try:\n",
    "        names = os.listdir(dirname)\n",
    "    except OSError:\n",
    "        return []\n",
    "    result = []\n",
    "    pattern = os.path.normcase(pattern)\n",
    "    match = re.compile(translate(pattern)).match\n",
    "    for name in names:\n",
    "        if match(os.path.normcase(name)):\n",
    "            result.append(name)\n",
    "    return result\n",
    "\n",
    "\n",
    "def relative_flat_glob(dirname, basename):\n",
    "    \"\"\"\n",
    "    Non-recursive glob for one directory. Does not accept wildcards.\n",
    "\n",
    "    :param dirname:  Directory name\n",
    "    :param basename: Basename of a file in dir of dirname\n",
    "    :return:         List containing Basename if the file exists\n",
    "    \"\"\"\n",
    "    if os.path.exists(os.path.join(dirname, basename)):\n",
    "        return [basename]\n",
    "    return[]\n",
    "\n",
    "\n",
    "def relative_recursive_glob(dirname, pattern):\n",
    "    \"\"\"\n",
    "    Recursive Glob for one directory and all its (nested) subdirectories.\n",
    "    Accepts only '**' as pattern.\n",
    "\n",
    "    :param dirname: Directory name\n",
    "    :param pattern: The recursive wildcard '**'\n",
    "    :return:        Iterator that yields all the (nested) subdirectories of the\n",
    "                    given dir\n",
    "    \"\"\"\n",
    "    assert pattern == '**'\n",
    "    if dirname:\n",
    "        yield pattern[:0]\n",
    "    for relative_dir in _iter_relative_dirs(dirname):\n",
    "        yield relative_dir\n",
    "\n",
    "\n",
    "wildcard_check_pattern = re.compile('([*?[])')\n",
    "\n",
    "\n",
    "def has_wildcard(pattern):\n",
    "    \"\"\"\n",
    "    Checks whether pattern has any wildcards.\n",
    "\n",
    "    :param pattern: Glob pattern that may contain wildcards\n",
    "    :return:        Boolean: Whether or not there are wildcards in pattern\n",
    "    \"\"\"\n",
    "    match = wildcard_check_pattern.search(pattern)\n",
    "    return match is not None\n",
    "\n",
    "\n",
    "def iglob(pattern):\n",
    "    \"\"\"\n",
    "    Iterates all filesystem paths that get matched by the glob pattern.\n",
    "    Syntax is equal to that of fnmatch.\n",
    "\n",
    "    :param pattern: Glob pattern with wildcards\n",
    "    :return:        Iterator that yields all file names that match pattern\n",
    "    \"\"\"\n",
    "    for pat in _iter_alternatives(pattern):\n",
    "        pat = os.path.expanduser(pat)\n",
    "        pat = os.path.normcase(pat)\n",
    "        dirname, basename = os.path.split(pat)\n",
    "        if not has_wildcard(pat):\n",
    "            for file in _absolute_flat_glob(pat):\n",
    "                yield file\n",
    "            return\n",
    "\n",
    "        if basename == '**':\n",
    "            relative_glob_function = relative_recursive_glob\n",
    "        elif has_wildcard(basename):\n",
    "            relative_glob_function = relative_wildcard_glob\n",
    "        else:\n",
    "            relative_glob_function = relative_flat_glob\n",
    "\n",
    "        if not dirname:\n",
    "            for file in relative_glob_function(dirname, basename):\n",
    "                yield file\n",
    "            return\n",
    "\n",
    "        # Prevent an infinite recursion if a drive or UNC path contains\n",
    "        # wildcard characters (i.e. r'\\\\?\\C:').\n",
    "        if dirname != pat and has_wildcard(dirname):\n",
    "            dirs = iglob(dirname)\n",
    "        else:\n",
    "            dirs = [dirname]\n",
    "\n",
    "        for dirname in dirs:\n",
    "            for name in relative_glob_function(dirname, basename):\n",
    "                yield os.path.join(dirname, name)\n",
    "\n",
    "\n",
    "def glob(pattern):\n",
    "    \"\"\"\n",
    "    Iterates all filesystem paths that get matched by the glob pattern.\n",
    "    Syntax is equal to that of fnmatch.\n",
    "\n",
    "    :param pattern: Glob pattern with wildcards\n",
    "    :return:        List of all file names that match pattern\n",
    "    \"\"\"\n",
    "    return list(iglob(pattern))\n"
  ],
  "/home/tushar/coala/coalib/parsing/LineParser.py": [
    "from coalib.misc.StringConverter import StringConverter\n",
    "from coalib.parsing.StringProcessing import unescape, convert_to_raw\n",
    "\n",
    "\n",
    "class LineParser:\n",
    "\n",
    "    def __init__(self,\n",
    "                 key_value_delimiters=('=',),\n",
    "                 comment_seperators=('#',),\n",
    "                 key_delimiters=(',', ' '),\n",
    "                 section_name_surroundings=None,\n",
    "                 section_override_delimiters=(\".\",)):\n",
    "        \"\"\"\n",
    "        Creates a new line parser. Please note that no delimiter or seperator\n",
    "        may be an \"o\" or you may encounter undefined behaviour with the\n",
    "        escapes.\n",
    "\n",
    "        :param key_value_delimiters:        Delimiters that delimit a key from\n",
    "                                            a value\n",
    "        :param comment_seperators:          Used to initiate a comment\n",
    "        :param key_delimiters:              Delimiters between several keys\n",
    "        :param section_name_surroundings:   Dictionary, e.g. {\"[\", \"]\"} means a\n",
    "                                            section name is surrounded by [].\n",
    "                                            If None, {\"[\": \"]\"} is used as\n",
    "                                            default.\n",
    "        :param section_override_delimiters: Delimiter for a section override.\n",
    "                                            E.g. \".\" would mean that\n",
    "                                            section.key is a possible key that\n",
    "                                            puts the key into the section\n",
    "                                            \"section\" despite of the current\n",
    "                                            section.\n",
    "        \"\"\"\n",
    "        section_name_surroundings = section_name_surroundings or {\"[\": \"]\"}\n",
    "\n",
    "        self.key_value_delimiters = key_value_delimiters\n",
    "        self.comment_seperators = comment_seperators\n",
    "        self.key_delimiters = key_delimiters\n",
    "        self.section_name_surroundings = section_name_surroundings\n",
    "        self.section_override_delimiters = section_override_delimiters\n",
    "\n",
    "    def parse(self, line):\n",
    "        \"\"\"\n",
    "        Note that every value in the returned touple *besides the value* is\n",
    "        unescaped. This is so since the value is meant to be put into a Setting\n",
    "        later thus the escapes may be needed there.\n",
    "\n",
    "        :param line: the line to parse\n",
    "        :return:     section_name (empty string if it's no section name),\n",
    "                     [(section_override, key), ...], value, comment\n",
    "        \"\"\"\n",
    "        line, comment = self.__seperate_by_first_occurrence(\n",
    "            line,\n",
    "            self.comment_seperators)\n",
    "        comment = unescape(comment)\n",
    "        if line == \"\":\n",
    "            return '', [], '', comment\n",
    "\n",
    "        section_name = unescape(self.__get_section_name(line))\n",
    "        if section_name != '':\n",
    "            return section_name, [], '', comment\n",
    "\n",
    "        # Escapes in value might be needed by the bears\n",
    "        keys, value = self.__extract_keys_and_value(line)\n",
    "\n",
    "        # Add all the delimiters that stored as tuples\n",
    "        all_delimiters = self.key_value_delimiters\n",
    "        all_delimiters += self.key_delimiters\n",
    "        all_delimiters += self.comment_seperators\n",
    "        all_delimiters += self.section_override_delimiters\n",
    "        all_delimiters = \"\".join(all_delimiters)\n",
    "\n",
    "        # Add all keys and values in section_name_surroundings, which is\n",
    "        # stored as a dict\n",
    "        all_delimiters += \"\".join(self.section_name_surroundings.keys())\n",
    "        all_delimiters += \"\".join(self.section_name_surroundings.values())\n",
    "\n",
    "        value = convert_to_raw(value, all_delimiters)\n",
    "\n",
    "        key_touples = []\n",
    "        for key in keys:\n",
    "            key = convert_to_raw(key, all_delimiters)\n",
    "            section, key = self.__seperate_by_first_occurrence(\n",
    "                key,\n",
    "                self.section_override_delimiters,\n",
    "                True,\n",
    "                True)\n",
    "            key_touples.append((unescape(section), unescape(key)))\n",
    "\n",
    "        return '', key_touples, value, comment\n",
    "\n",
    "    @staticmethod\n",
    "    def __seperate_by_first_occurrence(string,\n",
    "                                       delimiters,\n",
    "                                       strip_delim=False,\n",
    "                                       return_second_part_nonempty=False):\n",
    "        \"\"\"\n",
    "        Seperates a string by the first of all given delimiters. Any whitespace\n",
    "        characters will be stripped away from the parts.\n",
    "\n",
    "        :param string:                      The string to seperate.\n",
    "        :param delimiters:                  The delimiters.\n",
    "        :param strip_delim:                 Strips the delimiter from the\n",
    "                                            result if true.\n",
    "        :param return_second_part_nonempty: If no delimiter is found and this\n",
    "                                            is true the contents of the string\n",
    "                                            will be returned in the second part\n",
    "                                            of the touple instead of the first\n",
    "                                            one.\n",
    "        :return:                            (first_part, second_part)\n",
    "        \"\"\"\n",
    "        temp_string = string.replace(\"\\\\\\\\\", \"oo\")\n",
    "        i = temp_string.find(\"\\\\\")\n",
    "        while i != -1:\n",
    "            temp_string = temp_string[:i] + \"oo\" + temp_string[i+2:]\n",
    "            i = temp_string.find(\"\\\\\", i+2)\n",
    "\n",
    "        delim_pos = len(string)\n",
    "        used_delim = \"\"\n",
    "        for delim in delimiters:\n",
    "            pos = temp_string.find(delim)\n",
    "            if 0 <= pos < delim_pos:\n",
    "                delim_pos = pos\n",
    "                used_delim = delim\n",
    "\n",
    "        if return_second_part_nonempty and delim_pos == len(string):\n",
    "            return \"\", string.strip(\" \\n\")\n",
    "\n",
    "        return (\n",
    "            string[:delim_pos].strip(\" \\n\"),\n",
    "            string[delim_pos + (len(used_delim) if strip_delim else 0):].strip(\n",
    "                \" \\n\"))\n",
    "\n",
    "    def __get_section_name(self, line):\n",
    "        for begin, end in self.section_name_surroundings.items():\n",
    "            if (line[0:len(begin)] == begin and\n",
    "                    line[len(line) - len(end):len(line)] == end):\n",
    "                return line[len(begin):len(line) - len(end)].strip(\" \\n\")\n",
    "\n",
    "        return ''\n",
    "\n",
    "    def __extract_keys_and_value(self, line):\n",
    "        key_part, value = self.__seperate_by_first_occurrence(\n",
    "            line,\n",
    "            self.key_value_delimiters,\n",
    "            True,\n",
    "            True)\n",
    "        keys = list(StringConverter(\n",
    "            key_part,\n",
    "            list_delimiters=self.key_delimiters).__iter__(\n",
    "            remove_backslashes=False))\n",
    "\n",
    "        return keys, value\n"
  ],
  "/home/tushar/coala/coalib/parsing/StringProcessing/Core.py": [
    "import re\n",
    "\n",
    "from coalib.parsing.StringProcessing import InBetweenMatch\n",
    "from coalib.parsing.StringProcessing.Filters import limit, trim_empty_matches\n",
    "\n",
    "\n",
    "def search_for(pattern, string, flags=0, max_match=0, use_regex=False):\n",
    "    \"\"\"\n",
    "    Searches for a given pattern in a string.\n",
    "\n",
    "    :param pattern:   A pattern that defines what to match.\n",
    "    :param string:    The string to search in.\n",
    "    :param flags:     Additional flags to pass to the regex processor.\n",
    "    :param max_match: Defines the maximum number of matches to perform. If 0 or\n",
    "                      less is provided, the number of splits is not limited.\n",
    "    :param use_regex: Specifies whether to treat the pattern as a regex or\n",
    "                      simple string.\n",
    "    :return:          An iterator returning MatchObject's.\n",
    "    \"\"\"\n",
    "    if not use_regex:\n",
    "        pattern = re.escape(pattern)\n",
    "\n",
    "    return limit(re.finditer(pattern, string, flags), max_match)\n",
    "\n",
    "\n",
    "def unescaped_search_for(pattern,\n",
    "                         string,\n",
    "                         flags=0,\n",
    "                         max_match=0,\n",
    "                         use_regex=False):\n",
    "    \"\"\"\n",
    "    Searches for a given pattern in a string that is not escaped.\n",
    "\n",
    "    :param pattern:   A pattern that defines what to match unescaped.\n",
    "    :param string:    The string to search in.\n",
    "    :param flags:     Additional flags to pass to the regex processor.\n",
    "    :param max_match: Defines the maximum number of matches to perform. If 0 or\n",
    "                      less is provided, the number of splits is not limited.\n",
    "    :param use_regex: Specifies whether to treat the pattern as a regex or\n",
    "                      simple string.\n",
    "    :return:          An iterator returning MatchObject's.\n",
    "    \"\"\"\n",
    "    _iter = limit(\n",
    "        filter(lambda match: not position_is_escaped(string, match.start()),\n",
    "               search_for(pattern, string, flags, 0, use_regex)),\n",
    "        max_match)\n",
    "\n",
    "    for elem in _iter:\n",
    "        yield elem\n",
    "\n",
    "\n",
    "def _split(string,\n",
    "           max_split,\n",
    "           remove_empty_matches,\n",
    "           matching_function,\n",
    "           *args,\n",
    "           **kwargs):\n",
    "    \"\"\"\n",
    "    Splits a string using a given matching-function that matches the separator.\n",
    "\n",
    "    This function implements general features needed from the split functions\n",
    "    in this module (the max-split and remove-empty-matches features).\n",
    "\n",
    "    :param string:               The string where to split.\n",
    "    :param max_split:            Defines the maximum number of splits. If 0 or\n",
    "                                 less is provided, the number of splits is not\n",
    "                                 limited.\n",
    "    :param remove_empty_matches: Defines whether empty entries should\n",
    "                                 be removed from the result.\n",
    "    :param matching_function:    The matching function. It must return\n",
    "                                 MatchObject's containing the matched\n",
    "                                 split-separator.\n",
    "    :param args:                 Positional arguments to invoke the\n",
    "                                 matching_function with.\n",
    "    :param kwargs:               Key-value arguments to invoke the\n",
    "                                 matching_function with.\n",
    "    \"\"\"\n",
    "    last_end_pos = 0\n",
    "\n",
    "    for match in matching_function(*args, **kwargs):\n",
    "        split_string = string[last_end_pos: match.start()]\n",
    "        last_end_pos = match.end()\n",
    "\n",
    "        if not remove_empty_matches or len(split_string) != 0:\n",
    "            yield split_string\n",
    "\n",
    "            max_split -= 1\n",
    "            if max_split == 0:\n",
    "                break  # only reachable when max_split > 0\n",
    "\n",
    "    # Append the rest of the string.\n",
    "    if not remove_empty_matches or len(string) > last_end_pos:\n",
    "        yield string[last_end_pos:]\n",
    "\n",
    "\n",
    "def split(pattern,\n",
    "          string,\n",
    "          max_split=0,\n",
    "          remove_empty_matches=False,\n",
    "          use_regex=False):\n",
    "    \"\"\"\n",
    "    Splits the given string by the specified pattern. The return character (\\\\n)\n",
    "    is not a natural split pattern (if you don't specify it yourself).\n",
    "    This function ignores escape sequences.\n",
    "\n",
    "    :param pattern:              A pattern that defines where to split.\n",
    "    :param string:               The string to split by the defined pattern.\n",
    "    :param max_split:            Defines the maximum number of splits. If 0 or\n",
    "                                 less is provided, the number of splits is not\n",
    "                                 limited.\n",
    "    :param remove_empty_matches: Defines whether empty entries should\n",
    "                                 be removed from the result.\n",
    "    :param use_regex:            Specifies whether to treat the split pattern\n",
    "                                 as a regex or simple string.\n",
    "    :return:                     An iterator returning the split up strings.\n",
    "    \"\"\"\n",
    "    return _split(string,\n",
    "                  max_split,\n",
    "                  remove_empty_matches,\n",
    "                  search_for,\n",
    "                  pattern,\n",
    "                  string,\n",
    "                  0,\n",
    "                  0,\n",
    "                  use_regex)\n",
    "\n",
    "\n",
    "def unescaped_split(pattern,\n",
    "                    string,\n",
    "                    max_split=0,\n",
    "                    remove_empty_matches=False,\n",
    "                    use_regex=False):\n",
    "    \"\"\"\n",
    "    Splits the given string by the specified pattern. The return character (\\\\n)\n",
    "    is not a natural split pattern (if you don't specify it yourself).\n",
    "    This function handles escaped split-patterns (and so splits only patterns\n",
    "    that are unescaped).\n",
    "\n",
    "    :param pattern:              A pattern that defines where to split.\n",
    "    :param string:               The string to split by the defined pattern.\n",
    "    :param max_split:            Defines the maximum number of splits. If 0 or\n",
    "                                 less is provided, the number of splits is not\n",
    "                                 limited.\n",
    "    :param remove_empty_matches: Defines whether empty entries should\n",
    "                                 be removed from the result.\n",
    "    :param use_regex:            Specifies whether to treat the split pattern\n",
    "                                 as a regex or simple string.\n",
    "    :return:                     An iterator returning the split up strings.\n",
    "    \"\"\"\n",
    "    return _split(string,\n",
    "                  max_split,\n",
    "                  remove_empty_matches,\n",
    "                  unescaped_search_for,\n",
    "                  pattern,\n",
    "                  string,\n",
    "                  0,\n",
    "                  0,\n",
    "                  use_regex)\n",
    "\n",
    "\n",
    "def search_in_between(begin,\n",
    "                      end,\n",
    "                      string,\n",
    "                      max_matches=0,\n",
    "                      remove_empty_matches=False,\n",
    "                      use_regex=False):\n",
    "    \"\"\"\n",
    "    Searches for a string enclosed between a specified begin- and end-sequence.\n",
    "    Also enclosed \\\\n are put into the result. Doesn't handle escape sequences.\n",
    "\n",
    "    :param begin:                A pattern that defines where to start\n",
    "                                 matching.\n",
    "    :param end:                  A pattern that defines where to end matching.\n",
    "    :param string:               The string where to search in.\n",
    "    :param max_matches:          Defines the maximum number of matches. If 0 or\n",
    "                                 less is provided, the number of matches is not\n",
    "                                 limited.\n",
    "    :param remove_empty_matches: Defines whether empty entries should\n",
    "                                 be removed from the result. An entry is\n",
    "                                 considered empty if no inner match was\n",
    "                                 performed (regardless of matched start and\n",
    "                                 end patterns).\n",
    "    :param use_regex:            Specifies whether to treat the begin and end\n",
    "                                 patterns as regexes or simple strings.\n",
    "    :return:                     An iterator returning InBetweenMatch objects\n",
    "                                 that hold information about the matched begin,\n",
    "                                 inside and end string matched.\n",
    "    \"\"\"\n",
    "\n",
    "    if not use_regex:\n",
    "        begin = re.escape(begin)\n",
    "        end = re.escape(end)\n",
    "        # No need to compile the begin sequence, capturing groups get escaped.\n",
    "        begin_pattern_groups = 0\n",
    "    else:\n",
    "        # Compilation of the begin sequence is needed to get the number of\n",
    "        # capturing groups in it.\n",
    "        begin_pattern_groups = re.compile(begin).groups\n",
    "\n",
    "    # Regex explanation:\n",
    "    # 1. (begin) A capturing group that matches the begin sequence.\n",
    "    # 2. (.*?)   Match any char unlimited times, as few times as possible. Save\n",
    "    #            the match in the second capturing group (`match.group(2)`).\n",
    "    # 3. (end)   A capturing group that matches the end sequence.\n",
    "    #            Because the previous group is lazy (matches as few times as\n",
    "    #            possible) the next occurring end-sequence is matched.\n",
    "    regex = \"(\" + begin + \")(.*?)(\" + end + \")\"\n",
    "\n",
    "    matches = re.finditer(regex, string, re.DOTALL)\n",
    "\n",
    "    if remove_empty_matches:\n",
    "        matches = trim_empty_matches(matches,\n",
    "                                     (begin_pattern_groups + 2,))\n",
    "\n",
    "    matches = limit(matches, max_matches)\n",
    "\n",
    "    for m in matches:\n",
    "        yield InBetweenMatch.from_values(m.group(1),\n",
    "                                         m.start(1),\n",
    "                                         m.group(begin_pattern_groups + 2),\n",
    "                                         m.start(begin_pattern_groups + 2),\n",
    "                                         m.group(begin_pattern_groups + 3),\n",
    "                                         m.start(begin_pattern_groups + 3))\n",
    "\n",
    "\n",
    "def unescaped_search_in_between(begin,\n",
    "                                end,\n",
    "                                string,\n",
    "                                max_matches=0,\n",
    "                                remove_empty_matches=False,\n",
    "                                use_regex=False):\n",
    "    \"\"\"\n",
    "    Searches for a string enclosed between a specified begin- and end-sequence.\n",
    "    Also enclosed \\\\n are put into the result.\n",
    "    Handles escaped begin- and end-sequences (and so only patterns that are\n",
    "    unescaped).\n",
    "\n",
    "    .. warning::\n",
    "\n",
    "        Using the escape character '\\\\' in the begin- or end-sequences\n",
    "        the function can return strange results. The backslash can\n",
    "        interfere with the escaping regex-sequence used internally to\n",
    "        match the enclosed string.\n",
    "\n",
    "    :param begin:                A regex pattern that defines where to start\n",
    "                                 matching.\n",
    "    :param end:                  A regex pattern that defines where to end\n",
    "                                 matching.\n",
    "    :param string:               The string where to search in.\n",
    "    :param max_matches:          Defines the maximum number of matches. If 0 or\n",
    "                                 less is provided, the number of matches is not\n",
    "                                 limited.\n",
    "    :param remove_empty_matches: Defines whether empty entries should\n",
    "                                 be removed from the result. An entry is\n",
    "                                 considered empty if no inner match was\n",
    "                                 performed (regardless of matched start and\n",
    "                                 end patterns).\n",
    "    :param use_regex:            Specifies whether to treat the begin and end\n",
    "                                 patterns as regexes or simple strings.\n",
    "    :return:                     An iterator returning the matched strings.\n",
    "    \"\"\"\n",
    "    if not use_regex:\n",
    "        begin = re.escape(begin)\n",
    "        end = re.escape(end)\n",
    "        # No need to compile the begin sequence, capturing groups get escaped.\n",
    "        begin_pattern_groups = 0\n",
    "    else:\n",
    "        # Compilation of the begin sequence is needed to get the number of\n",
    "        # capturing groups in it.\n",
    "        begin_pattern_groups = re.compile(begin).groups\n",
    "\n",
    "    # Regex explanation:\n",
    "    # 1. (?<!\\\\)(?:\\\\\\\\)*   Unescapes the following char. The first part of\n",
    "    #                       this regex is a look-behind assertion. Only match\n",
    "    #                       the following if no single backslash is before it.\n",
    "    #                       The second part matches all double backslashes.\n",
    "    #                       In fact this sequence matches all escapes that\n",
    "    #                       occur as a multiple of two, means the following\n",
    "    #                       statement is not escaped.\n",
    "    # 2. (begin)            A capturing group that matches the begin sequence.\n",
    "    # 3. (.*?)              Match any char unlimited times, as few times as\n",
    "    #                       possible. Save the match in the capturing group\n",
    "    #                       after all capturing groups that can appear in\n",
    "    #                       'begin'.\n",
    "    # 4. (?<!\\\\)((?:\\\\\\\\)*) Again the unescaping regex, but now all escape-\n",
    "    #                       characters get captured.\n",
    "    # 5. (end)              A capturing group that matches the end sequence.\n",
    "    #                       Because the 3. group is lazy (matches as few times\n",
    "    #                       as possible) the next occurring end-sequence is\n",
    "    #                       matched.\n",
    "    regex = (r\"(?<!\\\\)(?:\\\\\\\\)*(\" + begin + r\")(.*?)(?<!\\\\)((?:\\\\\\\\)*)(\" +\n",
    "             end + \")\")\n",
    "\n",
    "    matches = re.finditer(regex, string, re.DOTALL)\n",
    "\n",
    "    if remove_empty_matches:\n",
    "        matches = trim_empty_matches(matches,\n",
    "                                     (begin_pattern_groups + 2,\n",
    "                                      begin_pattern_groups + 3))\n",
    "\n",
    "    matches = limit(matches, max_matches)\n",
    "\n",
    "    for m in matches:\n",
    "        yield InBetweenMatch.from_values(m.group(1),\n",
    "                                         m.start(1),\n",
    "                                         m.group(begin_pattern_groups + 2) +\n",
    "                                         m.group(begin_pattern_groups + 3),\n",
    "                                         m.start(begin_pattern_groups + 2),\n",
    "                                         m.group(begin_pattern_groups + 4),\n",
    "                                         m.start(begin_pattern_groups + 4))\n",
    "\n",
    "\n",
    "def escape(string, escape_chars, escape_with=\"\\\\\"):\n",
    "    \"\"\"\n",
    "    Escapes all chars given inside the given string.\n",
    "\n",
    "    :param string:       The string where to escape characters.\n",
    "    :param escape_chars: The string or Iterable that contains the characters\n",
    "                         to escape. Each char inside this string will be\n",
    "                         escaped in the order given. Duplicate chars are\n",
    "                         allowed.\n",
    "    :param escape_with:  The string that should be used as escape sequence.\n",
    "    :return:             The escaped string.\n",
    "    \"\"\"\n",
    "    for chr in escape_chars:\n",
    "        string = string.replace(chr, escape_with + chr)\n",
    "\n",
    "    return string\n",
    "\n",
    "\n",
    "def convert_to_raw(string, exceptions=\"\"):\n",
    "    \"\"\"\n",
    "    Converts a string to its raw form, converting all backslash to double\n",
    "    backslash except when the backslash escapes a character given in\n",
    "    exceptions.\n",
    "\n",
    "    :param string:     The given string that needs to be converted\n",
    "    :param exceptions: A list of characters that if escaped with backslash\n",
    "                       should not be converted to double backslash.\n",
    "    :return:           Returns the corresponding raw string.\n",
    "    \"\"\"\n",
    "    i = 0\n",
    "    length = len(string)\n",
    "    output = \"\"\n",
    "\n",
    "    while i < length:\n",
    "        if (string[i] == '\\\\' and\n",
    "                i + 1 < length and string[i + 1] not in exceptions):\n",
    "            output += \"\\\\\"\n",
    "            # If the next character is a ``\\`` then we need to write it now\n",
    "            # itself since otherwise it will be interpreted as a newly started\n",
    "            # escape sequence - thereby escaping the character at i + 2,\n",
    "            # which is unintended behavior\n",
    "            if string[i + 1] == '\\\\':\n",
    "                i += 1\n",
    "        output += string[i]\n",
    "        i += 1\n",
    "\n",
    "    return output\n",
    "\n",
    "\n",
    "def unescape(string):\n",
    "    \"\"\"\n",
    "    Trimms off all escape characters from the given string.\n",
    "\n",
    "    :param string: The string to unescape.\n",
    "    \"\"\"\n",
    "    regex = r\"\\\\(.)|\\\\$\"\n",
    "\n",
    "    return re.sub(regex, lambda m: m.group(1), string, 0, re.DOTALL)\n",
    "\n",
    "\n",
    "def position_is_escaped(string, position=None):\n",
    "    \"\"\"\n",
    "    Checks whether a char at a specific position of the string is preceded by\n",
    "    an odd number of backslashes.\n",
    "\n",
    "    :param string:   Arbitrary string\n",
    "    :param position: Position of character in string that should be checked\n",
    "    :return:         True if the character is escaped, False otherwise\n",
    "    \"\"\"\n",
    "    escapes_uneven = False\n",
    "    # iterate backwards, starting one left of position.\n",
    "    # Slicing provides a sane default behaviour and prevents IndexErrors\n",
    "    for i in range(len(string[:position]) - 1, -1, -1):\n",
    "        if string[i] == '\\\\':\n",
    "            escapes_uneven = not escapes_uneven\n",
    "        else:\n",
    "            break\n",
    "    return escapes_uneven\n",
    "\n",
    "\n",
    "def unescaped_rstrip(string):\n",
    "    \"\"\"\n",
    "    Strips whitespaces from the right side of given string that are not\n",
    "    escaped.\n",
    "\n",
    "    :param string: The string where to strip whitespaces from.\n",
    "    :return:       The right-stripped string.\n",
    "    \"\"\"\n",
    "    stripped = string.rstrip()\n",
    "    if (len(string) > len(stripped) and\n",
    "            position_is_escaped(stripped, len(string))):\n",
    "        stripped += string[len(stripped)]\n",
    "    return stripped\n",
    "\n",
    "\n",
    "def unescaped_strip(string):\n",
    "    \"\"\"\n",
    "    Strips whitespaces of the given string taking escape characters into\n",
    "    account.\n",
    "\n",
    "    :param string: The string where to strip whitespaces from.\n",
    "    :return:       The stripped string.\n",
    "    \"\"\"\n",
    "    return unescaped_rstrip(string).lstrip()\n",
    "\n",
    "\n",
    "def _nested_search_in_between(begin, end, string):\n",
    "    \"\"\"\n",
    "    Searches for a string enclosed between a specified begin- and end-sequence.\n",
    "    Matches infinite times.\n",
    "\n",
    "    This is a function specifically designed to be invoked from\n",
    "    ``nested_search_in_between()``.\n",
    "\n",
    "    :param begin:  A regex pattern that defines where to start matching.\n",
    "    :param end:    A regex pattern that defines where to end matching.\n",
    "    :param string: The string where to search in.\n",
    "    :return:       An iterator returning the matched strings.\n",
    "    \"\"\"\n",
    "    # Regex explanation:\n",
    "    # 1. (begin) A capturing group that matches the begin sequence.\n",
    "    # 2. (end)   A capturing group that matches the end sequence. Because the\n",
    "    #            1st group is lazy (matches as few times as possible) the next\n",
    "    #            occurring end-sequence is matched.\n",
    "    # The '|' in the regex matches either the first or the second part.\n",
    "    regex = \"(\" + begin + \")|(\" + end + \")\"\n",
    "\n",
    "    left_match = None\n",
    "    nesting_level = 0\n",
    "    for match in re.finditer(regex, string, re.DOTALL):\n",
    "        if match.group(1) is not None:\n",
    "            if nesting_level == 0:\n",
    "                # Store the match of the first nesting level to be able to\n",
    "                # return the string until the next fitting end sequence.\n",
    "                left_match = match\n",
    "            nesting_level += 1\n",
    "        else:\n",
    "            # The second group matched. This is the only alternative if group 1\n",
    "            # didn't, otherwise no match would be performed. No need to compile\n",
    "            # the begin and end sequences to get the number of capturing groups\n",
    "            # in them.\n",
    "            if nesting_level > 0:\n",
    "                nesting_level -= 1\n",
    "\n",
    "            if nesting_level == 0 and left_match != None:\n",
    "                yield InBetweenMatch.from_values(\n",
    "                    left_match.group(),\n",
    "                    left_match.start(),\n",
    "                    string[left_match.end(): match.start()],\n",
    "                    left_match.end(),\n",
    "                    match.group(),\n",
    "                    match.start())\n",
    "\n",
    "                left_match = None\n",
    "\n",
    "\n",
    "def nested_search_in_between(begin,\n",
    "                             end,\n",
    "                             string,\n",
    "                             max_matches=0,\n",
    "                             remove_empty_matches=False,\n",
    "                             use_regex=False):\n",
    "    \"\"\"\n",
    "    Searches for a string enclosed between a specified begin- and end-sequence.\n",
    "    Also enclosed \\\\n are put into the result. Doesn't handle escape sequences,\n",
    "    but supports nesting.\n",
    "\n",
    "    Nested sequences are ignored during the match. Means you get only the first\n",
    "    nesting level returned. If you want to acquire more levels, just reinvoke\n",
    "    this function again on the return value.\n",
    "\n",
    "    Using the same begin- and end-sequence won't match anything.\n",
    "\n",
    "    :param begin:                A pattern that defines where to start\n",
    "                                 matching.\n",
    "    :param end:                  A pattern that defines where to end matching.\n",
    "    :param string:               The string where to search in.\n",
    "    :param max_matches:          Defines the maximum number of matches. If 0 or\n",
    "                                 less is provided, the number of splits is not\n",
    "                                 limited.\n",
    "    :param remove_empty_matches: Defines whether empty entries should\n",
    "                                 be removed from the result. An entry is\n",
    "                                 considered empty if no inner match was\n",
    "                                 performed (regardless of matched start and\n",
    "                                 end patterns).\n",
    "    :param use_regex:            Specifies whether to treat the begin and end\n",
    "                                 patterns as regexes or simple strings.\n",
    "    :return:                     An iterator returning the matched strings.\n",
    "    \"\"\"\n",
    "\n",
    "    if not use_regex:\n",
    "        begin = re.escape(begin)\n",
    "        end = re.escape(end)\n",
    "\n",
    "    strings = _nested_search_in_between(begin, end, string)\n",
    "\n",
    "    if remove_empty_matches:\n",
    "        strings = filter(lambda x: str(x.inside) != \"\", strings)\n",
    "\n",
    "    return limit(strings, max_matches)\n"
  ],
  "/home/tushar/coala/coalib/parsing/StringProcessing/Filters.py": [
    "def limit(iterator, count):\n",
    "    \"\"\"\n",
    "    A filter that removes all elements behind the set limit.\n",
    "\n",
    "    :param iterator: The iterator to be filtered.\n",
    "    :param count:    The iterator limit. All elements at positions bigger than\n",
    "                     this limit are trimmed off. Exclusion: 0 or numbers below\n",
    "                     does not limit at all, means the passed iterator is\n",
    "                     completely yielded.\n",
    "    \"\"\"\n",
    "    if count <= 0:  # Performance branch\n",
    "        for elem in iterator:\n",
    "            yield elem\n",
    "    else:\n",
    "        for elem in iterator:\n",
    "            yield elem\n",
    "            count -= 1\n",
    "            if count == 0:\n",
    "                break\n",
    "\n",
    "\n",
    "def trim_empty_matches(iterator, groups=(0,)):\n",
    "    \"\"\"\n",
    "    A filter that removes empty match strings. It can only operate on iterators\n",
    "    whose elements are of type MatchObject.\n",
    "\n",
    "    :param iterator: The iterator to be filtered.\n",
    "    :param groups:   An iteratable defining the groups to check for blankness.\n",
    "                     Only results are not yielded if all groups of the match\n",
    "                     are blank.\n",
    "                     You can not only pass numbers but also strings, if your\n",
    "                     MatchObject contains named groups.\n",
    "    \"\"\"\n",
    "    for elem in iterator:\n",
    "        if any(len(elem.group(group)) > 0 for group in groups):\n",
    "            yield elem\n"
  ],
  "/home/tushar/coala/coalib/parsing/StringProcessing/InBetweenMatch.py": [
    "from coala_decorators.decorators import generate_ordering, generate_repr\n",
    "from coalib.parsing.StringProcessing import Match\n",
    "\n",
    "\n",
    "@generate_repr(\"begin\", \"inside\", \"end\")\n",
    "@generate_ordering(\"begin\", \"inside\", \"end\")\n",
    "class InBetweenMatch:\n",
    "    \"\"\"\n",
    "    Holds information about a match enclosed by two matches.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, begin, inside, end):\n",
    "        \"\"\"\n",
    "        Instantiates a new InBetweenMatch.\n",
    "\n",
    "        :param begin:  The ``Match`` of the start pattern.\n",
    "        :param inside: The ``Match`` between start and end.\n",
    "        :param end:    The ``Match`` of the end pattern.\n",
    "        \"\"\"\n",
    "        if begin > inside or inside > end:\n",
    "            raise ValueError(\"The inside match must be enclosed by the begin \"\n",
    "                             \"and end match.\")\n",
    "\n",
    "        self._begin = begin\n",
    "        self._inside = inside\n",
    "        self._end = end\n",
    "\n",
    "    @classmethod\n",
    "    def from_values(cls, begin, begin_pos, inside, inside_pos, end, end_pos):\n",
    "        \"\"\"\n",
    "        Instantiates a new InBetweenMatch from Match values.\n",
    "\n",
    "        This function allows to bypass the usage of Match object instantation:\n",
    "\n",
    "        >>> a = InBetweenMatch(Match(\"A\", 0), Match(\"B\", 1), Match(\"C\", 2))\n",
    "        >>> b = InBetweenMatch.from_values(\"A\", 0, \"B\", 1, \"C\", 2)\n",
    "        >>> assert a == b\n",
    "\n",
    "        :param begin:      The matched string from start pattern.\n",
    "        :param begin_pos:  The position of the matched begin string.\n",
    "        :param inside:     The matched string from inside/in-between pattern.\n",
    "        :param inside_pos: The position of the matched inside/in-between\n",
    "                           string.\n",
    "        :param end:        The matched string from end pattern.\n",
    "        :param end_pos:    The position of the matched end string.\n",
    "        :returns:          An InBetweenMatch from the given values.\n",
    "        \"\"\"\n",
    "        return cls(Match(begin, begin_pos),\n",
    "                   Match(inside, inside_pos),\n",
    "                   Match(end, end_pos))\n",
    "\n",
    "    @property\n",
    "    def begin(self):\n",
    "        return self._begin\n",
    "\n",
    "    @property\n",
    "    def inside(self):\n",
    "        return self._inside\n",
    "\n",
    "    @property\n",
    "    def end(self):\n",
    "        return self._end\n"
  ],
  "/home/tushar/coala/coalib/parsing/StringProcessing/Match.py": [
    "from coala_decorators.decorators import generate_ordering, generate_repr\n",
    "\n",
    "\n",
    "@generate_repr(\"match\", \"range\")\n",
    "@generate_ordering(\"range\", \"match\")\n",
    "class Match:\n",
    "    \"\"\"\n",
    "    Stores information about a single textual match.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, match, position):\n",
    "        \"\"\"\n",
    "        Instantiates a new Match.\n",
    "\n",
    "        :param match:    The actual matched string.\n",
    "        :param position: The position where the match was found. Starts from\n",
    "                         zero.\n",
    "        \"\"\"\n",
    "        self._match = match\n",
    "        self._position = position\n",
    "\n",
    "    def __len__(self):\n",
    "        return len(self.match)\n",
    "\n",
    "    def __str__(self):\n",
    "        return self.match\n",
    "\n",
    "    @property\n",
    "    def match(self):\n",
    "        \"\"\"\n",
    "        Returns the text matched.\n",
    "\n",
    "        :returns: The text matched.\n",
    "        \"\"\"\n",
    "        return self._match\n",
    "\n",
    "    @property\n",
    "    def position(self):\n",
    "        \"\"\"\n",
    "        Returns the position where the text was matched (zero-based).\n",
    "\n",
    "        :returns: The position.\n",
    "        \"\"\"\n",
    "        return self._position\n",
    "\n",
    "    @property\n",
    "    def end_position(self):\n",
    "        \"\"\"\n",
    "        Marks the end position of the matched text (zero-based).\n",
    "\n",
    "        :returns: The end-position.\n",
    "        \"\"\"\n",
    "        return len(self) + self.position\n",
    "\n",
    "    @property\n",
    "    def range(self):\n",
    "        \"\"\"\n",
    "        Returns the position range where the text was matched.\n",
    "\n",
    "        :returns: A pair indicating the position range. The first element is\n",
    "                  the start position, the second one the end position.\n",
    "        \"\"\"\n",
    "        return (self.position, self.end_position)\n"
  ],
  "/home/tushar/coala/coalib/parsing/StringProcessing/__init__.py": [
    "# Start ignoring PyImportSortBear because of dependency chains!\n",
    "from coalib.parsing.StringProcessing.Match import Match\n",
    "from coalib.parsing.StringProcessing.InBetweenMatch import InBetweenMatch\n",
    "from coalib.parsing.StringProcessing.Core import (search_for,\n",
    "                                                  unescaped_search_for,\n",
    "                                                  split,\n",
    "                                                  unescaped_split,\n",
    "                                                  search_in_between,\n",
    "                                                  unescaped_search_in_between,\n",
    "                                                  nested_search_in_between,\n",
    "                                                  escape,\n",
    "                                                  convert_to_raw,\n",
    "                                                  unescape,\n",
    "                                                  unescaped_rstrip,\n",
    "                                                  unescaped_strip,\n",
    "                                                  position_is_escaped)\n",
    "# Stop ignoring\n"
  ],
  "/home/tushar/coala/coalib/parsing/__init__.py": [
    "\"\"\"\n",
    "The StringProcessing module contains various functions for extracting\n",
    "information out of strings.\n",
    "\n",
    "Most of them support regexes for advanced pattern matching.\n",
    "\"\"\"\n"
  ],
  "/home/tushar/coala/coalib/processes/BearRunning.py": [
    "import queue\n",
    "import traceback\n",
    "\n",
    "from coalib.bears.BEAR_KIND import BEAR_KIND\n",
    "from coalib.bears.GlobalBear import GlobalBear\n",
    "from coalib.bears.LocalBear import LocalBear\n",
    "from coalib.misc import Constants\n",
    "from coalib.processes.communication.LogMessage import LOG_LEVEL, LogMessage\n",
    "from coalib.processes.CONTROL_ELEMENT import CONTROL_ELEMENT\n",
    "from coalib.results.Result import Result\n",
    "\n",
    "\n",
    "def send_msg(message_queue, timeout, log_level, *args, delimiter=' ', end=''):\n",
    "    \"\"\"\n",
    "    Puts message into message queue for a LogPrinter to present to the user.\n",
    "\n",
    "    :param message_queue: The queue to put the message into and which the\n",
    "                          LogPrinter reads.\n",
    "    :param timeout:       The queue blocks at most timeout seconds for a free\n",
    "                          slot to execute the put operation on. After the\n",
    "                          timeout it returns queue Full exception.\n",
    "    :param log_level:     The log_level i.e Error,Debug or Warning.It is sent\n",
    "                          to the LogPrinter depending on the message.\n",
    "    :param args:          This includes the elements of the message.\n",
    "    :param delimiter:     It is the value placed between each arg. By default\n",
    "                          it is a ' '.\n",
    "    :param end:           It is the value placed at the end of the message.\n",
    "    \"\"\"\n",
    "    output = str(delimiter).join(str(arg) for arg in args) + str(end)\n",
    "    message_queue.put(LogMessage(log_level, output),\n",
    "                      timeout=timeout)\n",
    "\n",
    "\n",
    "def validate_results(message_queue, timeout, result_list, name, args, kwargs):\n",
    "    \"\"\"\n",
    "    Validates if the result_list passed to it contains valid set of results.\n",
    "    That is the result_list must itself be a list and contain objects of the\n",
    "    instance of Result object. If any irregularity is found a message is put in\n",
    "    the message_queue to present the irregularity to the user. Each result_list\n",
    "    belongs to an execution of a bear.\n",
    "\n",
    "    :param message_queue: A queue that contains messages of type\n",
    "                          errors/warnings/debug statements to be printed in the\n",
    "                          Log.\n",
    "    :param timeout:       The queue blocks at most timeout seconds for a free\n",
    "                          slot to execute the put operation on. After the\n",
    "                          timeout it returns queue Full exception.\n",
    "    :param result_list:   The list of results to validate.\n",
    "    :param name:          The name of the bear executed.\n",
    "    :param args:          The args with which the bear was executed.\n",
    "    :param kwargs:        The kwargs with which the bear was executed.\n",
    "    :return:              Returns None if the result_list is invalid. Else it\n",
    "                          returns the result_list itself.\n",
    "    \"\"\"\n",
    "    if result_list is None:\n",
    "        return None\n",
    "\n",
    "    for result in result_list:\n",
    "        if not isinstance(result, Result):\n",
    "            send_msg(message_queue,\n",
    "                     timeout,\n",
    "                     LOG_LEVEL.ERROR,\n",
    "                     \"The results from the bear {bear} could only be \"\n",
    "                     \"partially processed with arguments {arglist}, \"\n",
    "                     \"{kwarglist}\"\n",
    "                     .format(bear=name, arglist=args, kwarglist=kwargs))\n",
    "            send_msg(message_queue,\n",
    "                     timeout,\n",
    "                     LOG_LEVEL.DEBUG,\n",
    "                     \"One of the results in the list for the bear {bear} is \"\n",
    "                     \"an instance of {ret} but it should be an instance of \"\n",
    "                     \"Result\"\n",
    "                     .format(bear=name, ret=result.__class__))\n",
    "            result_list.remove(result)\n",
    "\n",
    "    return result_list\n",
    "\n",
    "\n",
    "def run_bear(message_queue, timeout, bear_instance, *args, **kwargs):\n",
    "    \"\"\"\n",
    "    This method is responsible for executing the instance of a bear. It also\n",
    "    reports or logs errors if any occur during the execution of that bear\n",
    "    instance.\n",
    "\n",
    "    :param message_queue: A queue that contains messages of type\n",
    "                          errors/warnings/debug statements to be printed in the\n",
    "                          Log.\n",
    "    :param timeout:       The queue blocks at most timeout seconds for a free\n",
    "                          slot to execute the put operation on. After the\n",
    "                          timeout it returns queue Full exception.\n",
    "    :param bear_instance: The instance of the bear to be executed.\n",
    "    :param args:          The arguments that are to be passed to the bear.\n",
    "    :param kwargs:        The keyword arguments that are to be passed to the\n",
    "                          bear.\n",
    "    :return:              Returns a valid list of objects of the type Result\n",
    "                          if the bear executed succesfully. None otherwise.\n",
    "    \"\"\"\n",
    "    if kwargs.get(\"dependency_results\", True) is None:\n",
    "        del kwargs[\"dependency_results\"]\n",
    "\n",
    "    name = bear_instance.name\n",
    "\n",
    "    try:\n",
    "        result_list = bear_instance.execute(*args, **kwargs)\n",
    "    except:\n",
    "        send_msg(message_queue,\n",
    "                 timeout,\n",
    "                 LOG_LEVEL.ERROR,\n",
    "                 \"The bear {bear} failed to run with the arguments \"\n",
    "                 \"{arglist}, {kwarglist}. Skipping bear...\"\n",
    "                 .format(bear=name, arglist=args, kwarglist=kwargs))\n",
    "        send_msg(message_queue,\n",
    "                 timeout,\n",
    "                 LOG_LEVEL.DEBUG,\n",
    "                 \"Traceback for error in bear {}:\".format(name),\n",
    "                 traceback.format_exc(),\n",
    "                 delimiter=\"\\n\")\n",
    "\n",
    "        return None\n",
    "\n",
    "    return validate_results(message_queue,\n",
    "                            timeout,\n",
    "                            result_list,\n",
    "                            name,\n",
    "                            args,\n",
    "                            kwargs)\n",
    "\n",
    "\n",
    "def get_local_dependency_results(local_result_list, bear_instance):\n",
    "    \"\"\"\n",
    "    This method gets all the results originating from the dependencies of a\n",
    "    bear_instance. Each bear_instance may or may not have dependencies.\n",
    "\n",
    "    :param local_result_list: The list of results out of which the dependency\n",
    "                              results are picked.\n",
    "    :param bear_instance:     The instance of a local bear to get the\n",
    "                              dependencies from.\n",
    "    :return:                  Return none if there are no dependencies for the\n",
    "                              bear. Else return a dictionary containing\n",
    "                              dependency results.\n",
    "    \"\"\"\n",
    "    deps = bear_instance.get_dependencies()\n",
    "    if deps == []:\n",
    "        return None\n",
    "\n",
    "    dependency_results = {}\n",
    "    dep_strings = []\n",
    "    for dep in deps:\n",
    "        dep_strings.append(dep.__name__)\n",
    "\n",
    "    for result in local_result_list:\n",
    "        if result.origin in dep_strings:\n",
    "            results = dependency_results.get(result.origin, [])\n",
    "            results.append(result)\n",
    "            dependency_results[result.origin] = results\n",
    "\n",
    "    return dependency_results\n",
    "\n",
    "\n",
    "def run_local_bear(message_queue,\n",
    "                   timeout,\n",
    "                   local_result_list,\n",
    "                   file_dict,\n",
    "                   bear_instance,\n",
    "                   filename):\n",
    "    \"\"\"\n",
    "    Runs an instance of a local bear. Checks if bear_instance is of type\n",
    "    LocalBear and then passes it to the run_bear to execute.\n",
    "\n",
    "    :param message_queue:     A queue that contains messages of type\n",
    "                              errors/warnings/debug statements to be printed in\n",
    "                              the Log.\n",
    "    :param timeout:           The queue blocks at most timeout seconds for a\n",
    "                              free slot to execute the put operation on. After\n",
    "                              the timeout it returns queue Full exception.\n",
    "    :param local_result_list: Its a list that stores the results of all local\n",
    "                              bears.\n",
    "    :param file_dict:         Dictionary containing contents of file.\n",
    "    :param bear_instance:     Instance of LocalBear the run.\n",
    "    :param filename:          Name of the file to run it on.\n",
    "    :return:                  Returns a list of results generated by the passed\n",
    "                              bear_instance.\n",
    "    \"\"\"\n",
    "    if (not isinstance(bear_instance, LocalBear) or\n",
    "            bear_instance.kind() != BEAR_KIND.LOCAL):\n",
    "        send_msg(message_queue,\n",
    "                 timeout,\n",
    "                 LOG_LEVEL.WARNING,\n",
    "                 \"A given local bear ({}) is not valid. Leaving \"\n",
    "                 \"it out...\".format(bear_instance.__class__.__name__),\n",
    "                 Constants.THIS_IS_A_BUG)\n",
    "\n",
    "        return None\n",
    "\n",
    "    kwargs = {\"dependency_results\":\n",
    "              get_local_dependency_results(local_result_list,\n",
    "                                           bear_instance)}\n",
    "    return run_bear(message_queue,\n",
    "                    timeout,\n",
    "                    bear_instance,\n",
    "                    filename,\n",
    "                    file_dict[filename],\n",
    "                    **kwargs)\n",
    "\n",
    "\n",
    "def run_global_bear(message_queue,\n",
    "                    timeout,\n",
    "                    global_bear_instance,\n",
    "                    dependency_results):\n",
    "    \"\"\"\n",
    "    Runs an instance of a global bear. Checks if bear_instance is of type\n",
    "    GlobalBear and then passes it to the run_bear to execute.\n",
    "\n",
    "    :param message_queue:        A queue that contains messages of type\n",
    "                                 errors/warnings/debug statements to be printed\n",
    "                                 in the Log.\n",
    "    :param timeout:              The queue blocks at most timeout seconds for a\n",
    "                                 free slot to execute the put operation on.\n",
    "                                 After the timeout it returns queue Full\n",
    "                                 exception.\n",
    "    :param global_bear_instance: Instance of GlobalBear to run.\n",
    "    :param dependency_results:   The results of all the bears on which the\n",
    "                                 instance of the passed bear to be run depends\n",
    "                                 on.\n",
    "    :return:                     Returns a list of results generated by the\n",
    "                                 passed bear_instance.\n",
    "    \"\"\"\n",
    "    if (not isinstance(global_bear_instance, GlobalBear)\n",
    "            or global_bear_instance.kind() != BEAR_KIND.GLOBAL):\n",
    "        send_msg(message_queue,\n",
    "                 timeout,\n",
    "                 LOG_LEVEL.WARNING,\n",
    "                 \"A given global bear ({}) is not valid. Leaving it \"\n",
    "                 \"out...\"\n",
    "                 .format(global_bear_instance.__class__.__name__),\n",
    "                 Constants.THIS_IS_A_BUG)\n",
    "\n",
    "        return None\n",
    "\n",
    "    kwargs = {\"dependency_results\": dependency_results}\n",
    "    return run_bear(message_queue,\n",
    "                    timeout,\n",
    "                    global_bear_instance,\n",
    "                    **kwargs)\n",
    "\n",
    "\n",
    "def run_local_bears_on_file(message_queue,\n",
    "                            timeout,\n",
    "                            file_dict,\n",
    "                            local_bear_list,\n",
    "                            local_result_dict,\n",
    "                            control_queue,\n",
    "                            filename):\n",
    "    \"\"\"\n",
    "    This method runs a list of local bears on one file.\n",
    "\n",
    "    :param message_queue:     A queue that contains messages of type\n",
    "                              errors/warnings/debug statements to be printed\n",
    "                              in the Log.\n",
    "    :param timeout:           The queue blocks at most timeout seconds for a\n",
    "                              free slot to execute the put operation on. After\n",
    "                              the timeout it returns queue Full exception.\n",
    "    :param file_dict:         Dictionary that contains contents of files.\n",
    "    :param local_bear_list:   List of local bears to run on file.\n",
    "    :param local_result_dict: A Manager.dict that will be used to store local\n",
    "                              bear results. A list of all local bear results\n",
    "                              will be stored with the filename as key.\n",
    "    :param control_queue:     If any result gets written to the result_dict a\n",
    "                              tuple containing a CONTROL_ELEMENT (to indicate\n",
    "                              what kind of event happened) and either a bear\n",
    "                              name(for global results) or a file name to\n",
    "                              indicate the result will be put to the queue.\n",
    "    :param filename:          The name of file on which to run the bears.\n",
    "    \"\"\"\n",
    "    if filename not in file_dict:\n",
    "        send_msg(message_queue,\n",
    "                 timeout,\n",
    "                 LOG_LEVEL.ERROR,\n",
    "                 \"An internal error occurred.\",\n",
    "                 Constants.THIS_IS_A_BUG)\n",
    "        send_msg(message_queue,\n",
    "                 timeout,\n",
    "                 LOG_LEVEL.DEBUG,\n",
    "                 \"The given file through the queue is not in the file \"\n",
    "                 \"dictionary.\")\n",
    "\n",
    "        return\n",
    "\n",
    "    local_result_list = []\n",
    "    for bear_instance in local_bear_list:\n",
    "        result = run_local_bear(message_queue,\n",
    "                                timeout,\n",
    "                                local_result_list,\n",
    "                                file_dict,\n",
    "                                bear_instance,\n",
    "                                filename)\n",
    "        if result is not None:\n",
    "            local_result_list.extend(result)\n",
    "\n",
    "    local_result_dict[filename] = local_result_list\n",
    "    control_queue.put((CONTROL_ELEMENT.LOCAL, filename))\n",
    "\n",
    "\n",
    "def get_global_dependency_results(global_result_dict, bear_instance):\n",
    "    \"\"\"\n",
    "    This method gets all the results originating from the dependencies of a\n",
    "    bear_instance. Each bear_instance may or may not have dependencies.\n",
    "\n",
    "    :param global_result_dict: The list of results out of which the dependency\n",
    "                               results are picked.\n",
    "    :return:                   None if bear has no dependencies, False if\n",
    "                               dependencies are not met, the dependency dict\n",
    "                               otherwise.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        deps = bear_instance.get_dependencies()\n",
    "        if deps == []:\n",
    "            return None\n",
    "    except AttributeError:\n",
    "        # When this occurs we have an invalid bear and a warning will be\n",
    "        # emitted later.\n",
    "        return None\n",
    "\n",
    "    dependency_results = {}\n",
    "    for dep in deps:\n",
    "        depname = dep.__name__\n",
    "        if depname not in global_result_dict:\n",
    "            return False\n",
    "\n",
    "        dependency_results[depname] = global_result_dict[depname]\n",
    "\n",
    "    return dependency_results\n",
    "\n",
    "\n",
    "def get_next_global_bear(timeout,\n",
    "                         global_bear_queue,\n",
    "                         global_bear_list,\n",
    "                         global_result_dict):\n",
    "    \"\"\"\n",
    "    Retrieves the next global bear.\n",
    "\n",
    "    :param timeout:            The queue blocks at most timeout seconds for a\n",
    "                               free slot to execute the put operation on. After\n",
    "                               the timeout it returns queue Full exception.\n",
    "    :param global_bear_queue:  queue (read, write) of indexes of global bear\n",
    "                               instances in the global_bear_list.\n",
    "    :param global_bear_list:   A list containing all global bears to be\n",
    "                               executed.\n",
    "    :param global_result_dict: A Manager.dict that will be used to store global\n",
    "                               results. The list of results of one global bear\n",
    "                               will be stored with the bear name as key.\n",
    "    :return:                   (bear, bearname, dependency_results)\n",
    "    \"\"\"\n",
    "    dependency_results = False\n",
    "\n",
    "    while dependency_results is False:\n",
    "        bear_id = global_bear_queue.get(timeout=timeout)\n",
    "        bear = global_bear_list[bear_id]\n",
    "\n",
    "        dependency_results = (\n",
    "            get_global_dependency_results(global_result_dict, bear))\n",
    "        if dependency_results is False:\n",
    "            global_bear_queue.put(bear_id)\n",
    "\n",
    "    return bear, dependency_results\n",
    "\n",
    "\n",
    "def task_done(obj):\n",
    "    \"\"\"\n",
    "    Invokes task_done if the given queue provides this operation. Otherwise\n",
    "    passes silently.\n",
    "\n",
    "    :param obj: Any object.\n",
    "    \"\"\"\n",
    "    if hasattr(obj, \"task_done\"):\n",
    "        obj.task_done()\n",
    "\n",
    "\n",
    "def run_local_bears(filename_queue,\n",
    "                    message_queue,\n",
    "                    timeout,\n",
    "                    file_dict,\n",
    "                    local_bear_list,\n",
    "                    local_result_dict,\n",
    "                    control_queue):\n",
    "    \"\"\"\n",
    "    Run local bears on all the files given.\n",
    "\n",
    "    :param filename_queue:    queue (read) of file names to check with\n",
    "                              local bears.\n",
    "    :param message_queue:     A queue that contains messages of type\n",
    "                              errors/warnings/debug statements to be printed\n",
    "                              in the Log.\n",
    "    :param timeout:           The queue blocks at most timeout seconds for a\n",
    "                              free slot to execute the put operation on. After\n",
    "                              the timeout it returns queue Full exception.\n",
    "    :param file_dict:         Dictionary that contains contents of files.\n",
    "    :param local_bear_list:   List of local bears to run.\n",
    "    :param local_result_dict: A Manager.dict that will be used to store local\n",
    "                              bear results. A list of all local bear results\n",
    "                              will be stored with the filename as key.\n",
    "    :param control_queue:     If any result gets written to the result_dict a\n",
    "                              tuple containing a CONTROL_ELEMENT (to indicate\n",
    "                              what kind of event happened) and either a bear\n",
    "                              name(for global results) or a file name to\n",
    "                              indicate the result will be put to the queue.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        while True:\n",
    "            filename = filename_queue.get(timeout=timeout)\n",
    "            run_local_bears_on_file(message_queue,\n",
    "                                    timeout,\n",
    "                                    file_dict,\n",
    "                                    local_bear_list,\n",
    "                                    local_result_dict,\n",
    "                                    control_queue,\n",
    "                                    filename)\n",
    "            task_done(filename_queue)\n",
    "    except queue.Empty:\n",
    "        return\n",
    "\n",
    "\n",
    "def run_global_bears(message_queue,\n",
    "                     timeout,\n",
    "                     global_bear_queue,\n",
    "                     global_bear_list,\n",
    "                     global_result_dict,\n",
    "                     control_queue):\n",
    "    \"\"\"\n",
    "    Run all global bears.\n",
    "\n",
    "    :param message_queue:      A queue that contains messages of type\n",
    "                               errors/warnings/debug statements to be printed\n",
    "                               in the Log.\n",
    "    :param timeout:            The queue blocks at most timeout seconds for a\n",
    "                               free slot to execute the put operation on. After\n",
    "                               the timeout it returns queue Full exception.\n",
    "    :param global_bear_queue:  queue (read, write) of indexes of global bear\n",
    "                               instances in the global_bear_list.\n",
    "    :param global_bear_list:   list of global bear instances\n",
    "    :param global_result_dict: A Manager.dict that will be used to store global\n",
    "                               results. The list of results of one global bear\n",
    "                               will be stored with the bear name as key.\n",
    "    :param control_queue:      If any result gets written to the result_dict a\n",
    "                               tuple containing a CONTROL_ELEMENT (to indicate\n",
    "                               what kind of event happened) and either a bear\n",
    "                               name(for global results) or a file name to\n",
    "                               indicate the result will be put to the queue.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        while True:\n",
    "            bear, dep_results = (\n",
    "                get_next_global_bear(timeout,\n",
    "                                     global_bear_queue,\n",
    "                                     global_bear_list,\n",
    "                                     global_result_dict))\n",
    "            bearname = bear.__class__.__name__\n",
    "            result = run_global_bear(message_queue, timeout, bear, dep_results)\n",
    "            if result:\n",
    "                global_result_dict[bearname] = result\n",
    "                control_queue.put((CONTROL_ELEMENT.GLOBAL, bearname))\n",
    "            else:\n",
    "                global_result_dict[bearname] = None\n",
    "            task_done(global_bear_queue)\n",
    "    except queue.Empty:\n",
    "        return\n",
    "\n",
    "\n",
    "def run(file_name_queue,\n",
    "        local_bear_list,\n",
    "        global_bear_list,\n",
    "        global_bear_queue,\n",
    "        file_dict,\n",
    "        local_result_dict,\n",
    "        global_result_dict,\n",
    "        message_queue,\n",
    "        control_queue,\n",
    "        timeout=0):\n",
    "    \"\"\"\n",
    "    This is the method that is actually runs by processes.\n",
    "\n",
    "    If parameters type is 'queue (read)' this means it has to implement the\n",
    "    get(timeout=TIMEOUT) method and it shall raise queue.Empty if the queue\n",
    "    is empty up until the end of the timeout. If the queue has the\n",
    "    (optional!) task_done() attribute, the run method will call it after\n",
    "    processing each item.\n",
    "\n",
    "    If parameters type is 'queue (write)' it shall implement the\n",
    "    put(object, timeout=TIMEOUT) method.\n",
    "\n",
    "    If the queues raise any exception not specified here the user will get\n",
    "    an 'unknown error' message. So beware of that.\n",
    "\n",
    "    :param file_name_queue:    queue (read) of file names to check with local\n",
    "                               bears. Each invocation of the run method needs\n",
    "                               one such queue which it checks with all the\n",
    "                               local bears. The queue could be empty.\n",
    "                               (Repeat until queue empty.)\n",
    "    :param local_bear_list:    List of local bear instances.\n",
    "    :param global_bear_list:   List of global bear instances.\n",
    "    :param global_bear_queue:  queue (read, write) of indexes of global bear\n",
    "                               instances in the global_bear_list.\n",
    "    :param file_dict:          dict of all files as {filename:file}, file as in\n",
    "                               file.readlines().\n",
    "    :param local_result_dict:  A Manager.dict that will be used to store local\n",
    "                               results. A list of all local results.\n",
    "                               will be stored with the filename as key.\n",
    "    :param global_result_dict: A Manager.dict that will be used to store global\n",
    "                               results. The list of results of one global bear\n",
    "                               will be stored with the bear name as key.\n",
    "    :param message_queue:      queue (write) for debug/warning/error\n",
    "                               messages (type LogMessage)\n",
    "    :param control_queue:      queue (write). If any result gets written to the\n",
    "                               result_dict a tuple containing a CONTROL_ELEMENT\n",
    "                               (to indicate what kind of event happened) and\n",
    "                               either a bear name (for global results) or a\n",
    "                               file name to indicate the result will be put to\n",
    "                               the queue. If the run method finished all its\n",
    "                               local bears it will put\n",
    "                               (CONTROL_ELEMENT.LOCAL_FINISHED, None) to the\n",
    "                               queue, if it finished all global ones,\n",
    "                               (CONTROL_ELEMENT.GLOBAL_FINISHED, None) will\n",
    "                               be put there.\n",
    "    :param timeout:            The queue blocks at most timeout seconds for a\n",
    "                               free slot to execute the put operation on. After\n",
    "                               the timeout it returns queue Full exception.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        run_local_bears(file_name_queue,\n",
    "                        message_queue,\n",
    "                        timeout,\n",
    "                        file_dict,\n",
    "                        local_bear_list,\n",
    "                        local_result_dict,\n",
    "                        control_queue)\n",
    "        control_queue.put((CONTROL_ELEMENT.LOCAL_FINISHED, None))\n",
    "\n",
    "        run_global_bears(message_queue,\n",
    "                         timeout,\n",
    "                         global_bear_queue,\n",
    "                         global_bear_list,\n",
    "                         global_result_dict,\n",
    "                         control_queue)\n",
    "        control_queue.put((CONTROL_ELEMENT.GLOBAL_FINISHED, None))\n",
    "    except (OSError, KeyboardInterrupt):  # pragma: no cover\n",
    "        pass\n"
  ],
  "/home/tushar/coala/coalib/processes/CONTROL_ELEMENT.py": [
    "from coalib.misc.Enum import enum\n",
    "\n",
    "CONTROL_ELEMENT = enum(\"LOCAL\", \"GLOBAL\", \"LOCAL_FINISHED\", \"GLOBAL_FINISHED\")\n"
  ],
  "/home/tushar/coala/coalib/processes/LogPrinterThread.py": [
    "import queue\n",
    "import threading\n",
    "\n",
    "\n",
    "class LogPrinterThread(threading.Thread):\n",
    "    \"\"\"\n",
    "    This is the Thread object that outputs all log messages it gets from\n",
    "    its message_queue. Setting obj.running = False will stop within the next\n",
    "    0.1 seconds.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, message_queue, log_printer):\n",
    "        threading.Thread.__init__(self)\n",
    "        self.running = True\n",
    "        self.message_queue = message_queue\n",
    "        self.log_printer = log_printer\n",
    "\n",
    "    def run(self):\n",
    "        while self.running:\n",
    "            try:\n",
    "                elem = self.message_queue.get(timeout=0.1)\n",
    "                self.log_printer.log_message(elem)\n",
    "            except queue.Empty:\n",
    "                pass\n"
  ],
  "/home/tushar/coala/coalib/processes/Processing.py": [
    "import multiprocessing\n",
    "import os\n",
    "import platform\n",
    "import queue\n",
    "import subprocess\n",
    "from itertools import chain\n",
    "\n",
    "from coalib.collecting import Dependencies\n",
    "from coalib.collecting.Collectors import collect_files\n",
    "from coalib.misc.StringConverter import StringConverter\n",
    "from coalib.output.printers.LOG_LEVEL import LOG_LEVEL\n",
    "from coalib.processes.BearRunning import run\n",
    "from coalib.processes.CONTROL_ELEMENT import CONTROL_ELEMENT\n",
    "from coalib.processes.LogPrinterThread import LogPrinterThread\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.result_actions.ApplyPatchAction import ApplyPatchAction\n",
    "from coalib.results.result_actions.PrintDebugMessageAction import (\n",
    "    PrintDebugMessageAction)\n",
    "from coalib.results.result_actions.ShowPatchAction import ShowPatchAction\n",
    "from coalib.results.RESULT_SEVERITY import RESULT_SEVERITY\n",
    "from coalib.results.SourceRange import SourceRange\n",
    "from coalib.settings.Setting import glob_list\n",
    "from coalib.parsing.Globbing import fnmatch\n",
    "\n",
    "ACTIONS = [ApplyPatchAction,\n",
    "           PrintDebugMessageAction,\n",
    "           ShowPatchAction]\n",
    "\n",
    "\n",
    "def get_cpu_count():\n",
    "    try:\n",
    "        return multiprocessing.cpu_count()\n",
    "    # cpu_count is not implemented for some CPU architectures/OSes\n",
    "    except NotImplementedError:  # pragma: no cover\n",
    "        return 2\n",
    "\n",
    "\n",
    "def fill_queue(queue_fill, any_list):\n",
    "    \"\"\"\n",
    "    Takes element from a list and populates a queue with those elements.\n",
    "\n",
    "    :param queue_fill: The queue to be filled.\n",
    "    :param any_list:   List containing the elements.\n",
    "    \"\"\"\n",
    "    for elem in any_list:\n",
    "        queue_fill.put(elem)\n",
    "\n",
    "\n",
    "def get_running_processes(processes):\n",
    "    return sum((1 if process.is_alive() else 0) for process in processes)\n",
    "\n",
    "\n",
    "def create_process_group(command_array, **kwargs):\n",
    "    if platform.system() == \"Windows\":  # pragma: no cover\n",
    "        proc = subprocess.Popen(\n",
    "            command_array,\n",
    "            creationflags=subprocess.CREATE_NEW_PROCESS_GROUP,\n",
    "            **kwargs)\n",
    "    else:\n",
    "        proc = subprocess.Popen(command_array,\n",
    "                                preexec_fn=os.setsid,\n",
    "                                **kwargs)\n",
    "    return proc\n",
    "\n",
    "\n",
    "def get_default_actions(section):\n",
    "    \"\"\"\n",
    "    Parses the key ``default_actions`` in the given section.\n",
    "\n",
    "    :param section:    The section where to parse from.\n",
    "    :return:           A dict with the bearname as keys and their default\n",
    "                       actions as values and another dict that contains bears\n",
    "                       and invalid action names.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        default_actions = dict(section[\"default_actions\"])\n",
    "    except IndexError:\n",
    "        return {}, {}\n",
    "\n",
    "    action_dict = {action.get_metadata().name: action for action in ACTIONS}\n",
    "    invalid_action_set = default_actions.values() - action_dict.keys()\n",
    "    invalid_actions = {}\n",
    "    if len(invalid_action_set) != 0:\n",
    "        invalid_actions = {\n",
    "            bear: action\n",
    "            for bear, action in default_actions.items()\n",
    "            if action in invalid_action_set}\n",
    "        for invalid in invalid_actions.keys():\n",
    "            del default_actions[invalid]\n",
    "\n",
    "    actions = {bearname: action_dict[action_name]\n",
    "               for bearname, action_name in default_actions.items()}\n",
    "    return actions, invalid_actions\n",
    "\n",
    "\n",
    "def autoapply_actions(results,\n",
    "                      file_dict,\n",
    "                      file_diff_dict,\n",
    "                      section,\n",
    "                      log_printer):\n",
    "    \"\"\"\n",
    "    Auto-applies actions like defined in the given section.\n",
    "\n",
    "    :param results:        A list of results.\n",
    "    :param file_dict:      A dictionary containing the name of files and its\n",
    "                           contents.\n",
    "    :param file_diff_dict: A dictionary that contains filenames as keys and\n",
    "                           diff objects as values.\n",
    "    :param section:        The section.\n",
    "    :param log_printer:    A log printer instance to log messages on.\n",
    "    :return:               A list of unprocessed results.\n",
    "    \"\"\"\n",
    "\n",
    "    default_actions, invalid_actions = get_default_actions(section)\n",
    "\n",
    "    for bearname, actionname in invalid_actions.items():\n",
    "        log_printer.warn(\"Selected default action {!r} for bear {!r} does \"\n",
    "                         \"not exist. Ignoring action.\".format(actionname,\n",
    "                                                              bearname))\n",
    "\n",
    "    if len(default_actions) == 0:\n",
    "        # There's nothing to auto-apply.\n",
    "        return results\n",
    "\n",
    "    not_processed_results = []\n",
    "    for result in results:\n",
    "        try:\n",
    "            action = default_actions[result.origin]\n",
    "        except KeyError:\n",
    "            not_processed_results.append(result)\n",
    "            continue\n",
    "\n",
    "        if not action.is_applicable(result, file_dict, file_diff_dict):\n",
    "            log_printer.warn(\"Selected default action {!r} for bear {!r} is \"\n",
    "                             \"not applicable. Action not applied.\".format(\n",
    "                                 action.get_metadata().name, result.origin))\n",
    "            not_processed_results.append(result)\n",
    "            continue\n",
    "\n",
    "        try:\n",
    "            action().apply_from_section(result,\n",
    "                                        file_dict,\n",
    "                                        file_diff_dict,\n",
    "                                        section)\n",
    "            log_printer.info(\"Applied {!r} on {} from {!r}.\".format(\n",
    "                action.get_metadata().name,\n",
    "                result.location_repr(),\n",
    "                result.origin))\n",
    "        except Exception as ex:\n",
    "            not_processed_results.append(result)\n",
    "            log_printer.log_exception(\n",
    "                \"Failed to execute action {!r} with error: {}.\".format(\n",
    "                    action.get_metadata().name, ex),\n",
    "                ex)\n",
    "            log_printer.debug(\"-> for result \" + repr(result) + \".\")\n",
    "\n",
    "    return not_processed_results\n",
    "\n",
    "\n",
    "def check_result_ignore(result, ignore_ranges):\n",
    "    \"\"\"\n",
    "    Determines if the result has to be ignored.\n",
    "\n",
    "    :param result:        The result that needs to be checked.\n",
    "    :param ignore_ranges: A list of tuples, each containing a list of lower\n",
    "                          cased affected bearnames and a SourceRange to\n",
    "                          ignore. If any of the bearname lists is empty, it\n",
    "                          is considered an ignore range for all bears.\n",
    "                          This may be a list of globbed bear wildcards.\n",
    "    :return:              True if the result has to be ignored.\n",
    "    \"\"\"\n",
    "    for bears, range in ignore_ranges:\n",
    "        orig = result.origin.lower()\n",
    "        if (result.overlaps(range) and\n",
    "                (len(bears) == 0 or orig in bears or fnmatch(orig, bears))):\n",
    "            return True\n",
    "\n",
    "    return False\n",
    "\n",
    "\n",
    "def print_result(results,\n",
    "                 file_dict,\n",
    "                 retval,\n",
    "                 print_results,\n",
    "                 section,\n",
    "                 log_printer,\n",
    "                 file_diff_dict,\n",
    "                 ignore_ranges):\n",
    "    \"\"\"\n",
    "    Takes the results produced by each bear and gives them to the print_results\n",
    "    method to present to the user.\n",
    "\n",
    "    :param results:        A list of results.\n",
    "    :param file_dict:      A dictionary containing the name of files and its\n",
    "                           contents.\n",
    "    :param retval:         It is True if no results were yielded ever before.\n",
    "                           If it is False this function will return False no\n",
    "                           matter what happens. Else it depends on if this\n",
    "                           invocation yields results.\n",
    "    :param print_results:  A function that prints all given results appropriate\n",
    "                           to the output medium.\n",
    "    :param file_diff_dict: A dictionary that contains filenames as keys and\n",
    "                           diff objects as values.\n",
    "    :param ignore_ranges:  A list of SourceRanges. Results that affect code in\n",
    "                           any of those ranges will be ignored.\n",
    "    :return:               Returns False if any results were yielded. Else\n",
    "                           True.\n",
    "    \"\"\"\n",
    "    min_severity_str = str(section.get('min_severity', 'INFO')).upper()\n",
    "    min_severity = RESULT_SEVERITY.str_dict.get(min_severity_str, 'INFO')\n",
    "    results = list(filter(lambda result:\n",
    "                          type(result) is Result and\n",
    "                          result.severity >= min_severity and\n",
    "                          not check_result_ignore(result, ignore_ranges),\n",
    "                          results))\n",
    "\n",
    "    if bool(section.get('autoapply', 'true')):\n",
    "        patched_results = autoapply_actions(results,\n",
    "                                            file_dict,\n",
    "                                            file_diff_dict,\n",
    "                                            section,\n",
    "                                            log_printer)\n",
    "    else:\n",
    "        patched_results = results\n",
    "\n",
    "    print_results(log_printer,\n",
    "                  section,\n",
    "                  patched_results,\n",
    "                  file_dict,\n",
    "                  file_diff_dict)\n",
    "    return retval or len(results) > 0, patched_results\n",
    "\n",
    "\n",
    "def get_file_dict(filename_list, log_printer):\n",
    "    \"\"\"\n",
    "    Reads all files into a dictionary.\n",
    "\n",
    "    :param filename_list: List of names of paths to files to get contents of.\n",
    "    :param log_printer:   The logger which logs errors.\n",
    "    :return:              Reads the content of each file into a dictionary\n",
    "                          with filenames as keys.\n",
    "    \"\"\"\n",
    "    file_dict = {}\n",
    "    for filename in filename_list:\n",
    "        try:\n",
    "            with open(filename, \"r\", encoding=\"utf-8\") as _file:\n",
    "                file_dict[filename] = tuple(_file.readlines())\n",
    "        except UnicodeDecodeError:\n",
    "            log_printer.warn(\"Failed to read file '{}'. It seems to contain \"\n",
    "                             \"non-unicode characters. Leaving it \"\n",
    "                             \"out.\".format(filename))\n",
    "        except OSError as exception:  # pragma: no cover\n",
    "            log_printer.log_exception(\"Failed to read file '{}' because of \"\n",
    "                                      \"an unknown error. Leaving it \"\n",
    "                                      \"out.\".format(filename),\n",
    "                                      exception,\n",
    "                                      log_level=LOG_LEVEL.WARNING)\n",
    "\n",
    "    log_printer.debug(\"Files that will be checked:\\n\" +\n",
    "                      \"\\n\".join(file_dict.keys()))\n",
    "    return file_dict\n",
    "\n",
    "\n",
    "def filter_raising_callables(it, exception, *args, **kwargs):\n",
    "    \"\"\"\n",
    "    Filters all callable items inside the given iterator that raise the\n",
    "    given exceptions.\n",
    "\n",
    "    :param it:        The iterator to filter.\n",
    "    :param exception: The (tuple of) exception(s) to filter for.\n",
    "    :param args:      Positional arguments to pass to the callable.\n",
    "    :param kwargs:    Keyword arguments to pass to the callable.\n",
    "    \"\"\"\n",
    "    for elem in it:\n",
    "        try:\n",
    "            yield elem(*args, **kwargs)\n",
    "        except exception:\n",
    "            pass\n",
    "\n",
    "\n",
    "def instantiate_bears(section,\n",
    "                      local_bear_list,\n",
    "                      global_bear_list,\n",
    "                      file_dict,\n",
    "                      message_queue):\n",
    "    \"\"\"\n",
    "    Instantiates each bear with the arguments it needs.\n",
    "\n",
    "    :param section:          The section the bears belong to.\n",
    "    :param local_bear_list:  List of local bear classes to instantiate.\n",
    "    :param global_bear_list: List of global bear classes to instantiate.\n",
    "    :param file_dict:        Dictionary containing filenames and their\n",
    "                             contents.\n",
    "    :param message_queue:    Queue responsible to maintain the messages\n",
    "                             delivered by the bears.\n",
    "    :return:                 The local and global bear instance lists.\n",
    "    \"\"\"\n",
    "    local_bear_list = [bear\n",
    "                       for bear in filter_raising_callables(\n",
    "                           local_bear_list,\n",
    "                           RuntimeError,\n",
    "                           section,\n",
    "                           message_queue,\n",
    "                           timeout=0.1)]\n",
    "\n",
    "    global_bear_list = [bear\n",
    "                        for bear in filter_raising_callables(\n",
    "                            global_bear_list,\n",
    "                            RuntimeError,\n",
    "                            file_dict,\n",
    "                            section,\n",
    "                            message_queue,\n",
    "                            timeout=0.1)]\n",
    "\n",
    "    return local_bear_list, global_bear_list\n",
    "\n",
    "\n",
    "def instantiate_processes(section,\n",
    "                          local_bear_list,\n",
    "                          global_bear_list,\n",
    "                          job_count,\n",
    "                          log_printer):\n",
    "    \"\"\"\n",
    "    Instantiate the number of processes that will run bears which will be\n",
    "    responsible for running bears in a multiprocessing environment.\n",
    "\n",
    "    :param section:          The section the bears belong to.\n",
    "    :param local_bear_list:  List of local bears belonging to the section.\n",
    "    :param global_bear_list: List of global bears belonging to the section.\n",
    "    :param job_count:        Max number of processes to create.\n",
    "    :param log_printer:      The log printer to warn to.\n",
    "    :return:                 A tuple containing a list of processes,\n",
    "                             and the arguments passed to each process which are\n",
    "                             the same for each object.\n",
    "    \"\"\"\n",
    "    filename_list = collect_files(\n",
    "        glob_list(section.get('files', \"\")),\n",
    "        log_printer,\n",
    "        ignored_file_paths=glob_list(section.get('ignore', \"\")),\n",
    "        limit_file_paths=glob_list(section.get('limit_files', \"\")))\n",
    "    file_dict = get_file_dict(filename_list, log_printer)\n",
    "\n",
    "    manager = multiprocessing.Manager()\n",
    "    global_bear_queue = multiprocessing.Queue()\n",
    "    filename_queue = multiprocessing.Queue()\n",
    "    local_result_dict = manager.dict()\n",
    "    global_result_dict = manager.dict()\n",
    "    message_queue = multiprocessing.Queue()\n",
    "    control_queue = multiprocessing.Queue()\n",
    "\n",
    "    bear_runner_args = {\"file_name_queue\": filename_queue,\n",
    "                        \"local_bear_list\": local_bear_list,\n",
    "                        \"global_bear_list\": global_bear_list,\n",
    "                        \"global_bear_queue\": global_bear_queue,\n",
    "                        \"file_dict\": file_dict,\n",
    "                        \"local_result_dict\": local_result_dict,\n",
    "                        \"global_result_dict\": global_result_dict,\n",
    "                        \"message_queue\": message_queue,\n",
    "                        \"control_queue\": control_queue,\n",
    "                        \"timeout\": 0.1}\n",
    "\n",
    "    local_bear_list[:], global_bear_list[:] = instantiate_bears(\n",
    "        section,\n",
    "        local_bear_list,\n",
    "        global_bear_list,\n",
    "        file_dict,\n",
    "        message_queue)\n",
    "\n",
    "    fill_queue(filename_queue, file_dict.keys())\n",
    "    fill_queue(global_bear_queue, range(len(global_bear_list)))\n",
    "\n",
    "    return ([multiprocessing.Process(target=run, kwargs=bear_runner_args)\n",
    "             for i in range(job_count)],\n",
    "            bear_runner_args)\n",
    "\n",
    "\n",
    "def get_ignore_scope(line, keyword):\n",
    "    \"\"\"\n",
    "    Retrieves the bears that are to be ignored defined in the given line.\n",
    "\n",
    "    :param line:    The line containing the ignore declaration.\n",
    "    :param keyword: The keyword that was found. Everything after the rightmost\n",
    "                    occurrence of it will be considered for the scope.\n",
    "    :return:        A list of lower cased bearnames or an empty list (-> \"all\")\n",
    "    \"\"\"\n",
    "    toignore = line[line.rfind(keyword) + len(keyword):]\n",
    "    if toignore.startswith(\"all\"):\n",
    "        return []\n",
    "    else:\n",
    "        return list(StringConverter(toignore, list_delimiters=', '))\n",
    "\n",
    "\n",
    "def yield_ignore_ranges(file_dict):\n",
    "    \"\"\"\n",
    "    Yields tuples of affected bears and a SourceRange that shall be ignored for\n",
    "    those.\n",
    "\n",
    "    :param file_dict: The file dictionary.\n",
    "    \"\"\"\n",
    "    for filename, file in file_dict.items():\n",
    "        start = None\n",
    "        bears = []\n",
    "        stop_ignoring = False\n",
    "        for line_number, line in enumerate(file, start=1):\n",
    "            line = line.lower()\n",
    "            if \"start ignoring \" in line:\n",
    "                start = line_number\n",
    "                bears = get_ignore_scope(line, \"start ignoring \")\n",
    "            elif \"stop ignoring\" in line:\n",
    "                stop_ignoring = True\n",
    "                if start:\n",
    "                    yield (bears,\n",
    "                           SourceRange.from_values(filename,\n",
    "                                                   start,\n",
    "                                                   1,\n",
    "                                                   line_number,\n",
    "                                                   len(file[line_number-1])))\n",
    "            elif \"ignore \" in line:\n",
    "                yield (get_ignore_scope(line, \"ignore \"),\n",
    "                       SourceRange.from_values(filename,\n",
    "                                               line_number,\n",
    "                                               1,\n",
    "                                               line_number+1,\n",
    "                                               len(file[line_number])))\n",
    "        if stop_ignoring is False and start is not None:\n",
    "            yield (bears,\n",
    "                   SourceRange.from_values(filename,\n",
    "                                           start,\n",
    "                                           1,\n",
    "                                           len(file),\n",
    "                                           len(file[-1])))\n",
    "\n",
    "\n",
    "def process_queues(processes,\n",
    "                   control_queue,\n",
    "                   local_result_dict,\n",
    "                   global_result_dict,\n",
    "                   file_dict,\n",
    "                   print_results,\n",
    "                   section,\n",
    "                   log_printer):\n",
    "    \"\"\"\n",
    "    Iterate the control queue and send the results recieved to the print_result\n",
    "    method so that they can be presented to the user.\n",
    "\n",
    "    :param processes:          List of processes which can be used to run\n",
    "                               Bears.\n",
    "    :param control_queue:      Containing control elements that indicate\n",
    "                               whether there is a result available and which\n",
    "                               bear it belongs to.\n",
    "    :param local_result_dict:  Dictionary containing results respective to\n",
    "                               local bears. It is modified by the processes\n",
    "                               i.e. results are added to it by multiple\n",
    "                               processes.\n",
    "    :param global_result_dict: Dictionary containing results respective to\n",
    "                               global bears. It is modified by the processes\n",
    "                               i.e. results are added to it by multiple\n",
    "                               processes.\n",
    "    :param file_dict:          Dictionary containing file contents with\n",
    "                               filename as keys.\n",
    "    :param print_results:      Prints all given results appropriate to the\n",
    "                               output medium.\n",
    "    :return:                   Return True if all bears execute succesfully and\n",
    "                               Results were delivered to the user. Else False.\n",
    "    \"\"\"\n",
    "    file_diff_dict = {}\n",
    "    retval = False\n",
    "    # Number of processes working on local/global bears. They are count down\n",
    "    # when the last queue element of that process is processed which may be\n",
    "    # *after* the process has ended!\n",
    "    local_processes = len(processes)\n",
    "    global_processes = len(processes)\n",
    "    global_result_buffer = []\n",
    "    ignore_ranges = list(yield_ignore_ranges(file_dict))\n",
    "\n",
    "    # One process is the logger thread\n",
    "    while local_processes > 1:\n",
    "        try:\n",
    "            control_elem, index = control_queue.get(timeout=0.1)\n",
    "\n",
    "            if control_elem == CONTROL_ELEMENT.LOCAL_FINISHED:\n",
    "                local_processes -= 1\n",
    "            elif control_elem == CONTROL_ELEMENT.GLOBAL_FINISHED:\n",
    "                global_processes -= 1\n",
    "            elif control_elem == CONTROL_ELEMENT.LOCAL:\n",
    "                assert local_processes != 0\n",
    "                retval, res = print_result(local_result_dict[index],\n",
    "                                           file_dict,\n",
    "                                           retval,\n",
    "                                           print_results,\n",
    "                                           section,\n",
    "                                           log_printer,\n",
    "                                           file_diff_dict,\n",
    "                                           ignore_ranges)\n",
    "                local_result_dict[index] = res\n",
    "            else:\n",
    "                assert control_elem == CONTROL_ELEMENT.GLOBAL\n",
    "                global_result_buffer.append(index)\n",
    "        except queue.Empty:\n",
    "            if get_running_processes(processes) < 2:  # pragma: no cover\n",
    "                # Recover silently, those branches are only\n",
    "                # nondeterministically covered.\n",
    "                break\n",
    "\n",
    "    # Flush global result buffer\n",
    "    for elem in global_result_buffer:\n",
    "        retval, res = print_result(global_result_dict[elem],\n",
    "                                   file_dict,\n",
    "                                   retval,\n",
    "                                   print_results,\n",
    "                                   section,\n",
    "                                   log_printer,\n",
    "                                   file_diff_dict,\n",
    "                                   ignore_ranges)\n",
    "        global_result_dict[elem] = res\n",
    "\n",
    "    # One process is the logger thread\n",
    "    while global_processes > 1:\n",
    "        try:\n",
    "            control_elem, index = control_queue.get(timeout=0.1)\n",
    "\n",
    "            if control_elem == CONTROL_ELEMENT.GLOBAL:\n",
    "                retval, res = print_result(global_result_dict[index],\n",
    "                                           file_dict,\n",
    "                                           retval,\n",
    "                                           print_results,\n",
    "                                           section,\n",
    "                                           log_printer,\n",
    "                                           file_diff_dict,\n",
    "                                           ignore_ranges)\n",
    "                global_result_dict[index] = res\n",
    "            else:\n",
    "                assert control_elem == CONTROL_ELEMENT.GLOBAL_FINISHED\n",
    "                global_processes -= 1\n",
    "        except queue.Empty:\n",
    "            if get_running_processes(processes) < 2:  # pragma: no cover\n",
    "                # Recover silently, those branches are only\n",
    "                # nondeterministically covered.\n",
    "                break\n",
    "\n",
    "    return retval\n",
    "\n",
    "\n",
    "def simplify_section_result(section_result):\n",
    "    \"\"\"\n",
    "    Takes in a section's result from ``execute_section`` and simplifies it\n",
    "    for easy usage in other functions.\n",
    "\n",
    "    :param section_result: The result of a section which was executed.\n",
    "    :return:               Tuple containing:\n",
    "                            - bool - True if results were yielded\n",
    "                            - bool - True if unfixed results were yielded\n",
    "                            - list - Results from all bears (local and global)\n",
    "    \"\"\"\n",
    "    section_yielded_result = section_result[0]\n",
    "    results_for_section = []\n",
    "    for value in chain(section_result[1].values(),\n",
    "                       section_result[2].values()):\n",
    "        if value is None:\n",
    "            continue\n",
    "\n",
    "        for result in value:\n",
    "            results_for_section.append(result)\n",
    "    section_yielded_unfixed_results = len(results_for_section) > 0\n",
    "\n",
    "    return (section_yielded_result,\n",
    "            section_yielded_unfixed_results,\n",
    "            results_for_section)\n",
    "\n",
    "\n",
    "def execute_section(section,\n",
    "                    global_bear_list,\n",
    "                    local_bear_list,\n",
    "                    print_results,\n",
    "                    log_printer):\n",
    "    \"\"\"\n",
    "    Executes the section with the given bears.\n",
    "\n",
    "    The execute_section method does the following things:\n",
    "\n",
    "    1. Prepare a Process\n",
    "       -  Load files\n",
    "       -  Create queues\n",
    "    2. Spawn up one or more Processes\n",
    "    3. Output results from the Processes\n",
    "    4. Join all processes\n",
    "\n",
    "    :param section:          The section to execute.\n",
    "    :param global_bear_list: List of global bears belonging to the section.\n",
    "    :param local_bear_list:  List of local bears belonging to the section.\n",
    "    :param print_results:    Prints all given results appropriate to the\n",
    "                             output medium.\n",
    "    :param log_printer:      The log_printer to warn to.\n",
    "    :return:                 Tuple containing a bool (True if results were\n",
    "                             yielded, False otherwise), a Manager.dict\n",
    "                             containing all local results(filenames are key)\n",
    "                             and a Manager.dict containing all global bear\n",
    "                             results (bear names are key) as well as the\n",
    "                             file dictionary.\n",
    "    \"\"\"\n",
    "    local_bear_list = Dependencies.resolve(local_bear_list)\n",
    "    global_bear_list = Dependencies.resolve(global_bear_list)\n",
    "\n",
    "    try:\n",
    "        running_processes = int(section['jobs'])\n",
    "    except ValueError:\n",
    "        log_printer.warn(\"Unable to convert setting 'jobs' into a number. \"\n",
    "                         \"Falling back to CPU count.\")\n",
    "        running_processes = get_cpu_count()\n",
    "    except IndexError:\n",
    "        running_processes = get_cpu_count()\n",
    "\n",
    "    processes, arg_dict = instantiate_processes(section,\n",
    "                                                local_bear_list,\n",
    "                                                global_bear_list,\n",
    "                                                running_processes,\n",
    "                                                log_printer)\n",
    "\n",
    "    logger_thread = LogPrinterThread(arg_dict[\"message_queue\"],\n",
    "                                     log_printer)\n",
    "    # Start and join the logger thread along with the processes to run bears\n",
    "    processes.append(logger_thread)\n",
    "\n",
    "    for runner in processes:\n",
    "        runner.start()\n",
    "\n",
    "    try:\n",
    "        return (process_queues(processes,\n",
    "                               arg_dict[\"control_queue\"],\n",
    "                               arg_dict[\"local_result_dict\"],\n",
    "                               arg_dict[\"global_result_dict\"],\n",
    "                               arg_dict[\"file_dict\"],\n",
    "                               print_results,\n",
    "                               section,\n",
    "                               log_printer),\n",
    "                arg_dict[\"local_result_dict\"],\n",
    "                arg_dict[\"global_result_dict\"],\n",
    "                arg_dict[\"file_dict\"])\n",
    "    finally:\n",
    "        logger_thread.running = False\n",
    "\n",
    "        for runner in processes:\n",
    "            runner.join()\n"
  ],
  "/home/tushar/coala/coalib/processes/__init__.py": [],
  "/home/tushar/coala/coalib/processes/communication/LogMessage.py": [
    "from datetime import datetime\n",
    "\n",
    "from coalib.output.printers.LOG_LEVEL import LOG_LEVEL\n",
    "\n",
    "\n",
    "class LogMessage:\n",
    "\n",
    "    def __init__(self,\n",
    "                 log_level,\n",
    "                 *messages,\n",
    "                 delimiter=\" \",\n",
    "                 timestamp=None):\n",
    "        if log_level not in LOG_LEVEL.reverse:\n",
    "            raise ValueError(\"log_level has to be a valid LOG_LEVEL.\")\n",
    "\n",
    "        str_messages = [str(message) for message in messages]\n",
    "        self.message = str(delimiter).join(str_messages).rstrip()\n",
    "        if self.message == \"\":\n",
    "            raise ValueError(\"Empty log messages are not allowed.\")\n",
    "\n",
    "        self.log_level = log_level\n",
    "        self.timestamp = timestamp or datetime.today()\n",
    "\n",
    "    def __str__(self):\n",
    "        log_level = LOG_LEVEL.reverse.get(self.log_level, \"ERROR\")\n",
    "        return '[{}] {}'.format(log_level, self.message)\n",
    "\n",
    "    def __eq__(self, other):\n",
    "        return (isinstance(other, LogMessage) and\n",
    "                other.log_level == self.log_level and\n",
    "                other.message == self.message)\n",
    "\n",
    "    def __ne__(self, other):\n",
    "        return not self.__eq__(other)\n",
    "\n",
    "    def to_string_dict(self):\n",
    "        \"\"\"\n",
    "        Makes a dictionary which has all keys and values as strings and\n",
    "        contains all the data that the LogMessage has.\n",
    "\n",
    "        :return: Dictionary with keys and values as string.\n",
    "        \"\"\"\n",
    "        retval = {}\n",
    "\n",
    "        retval[\"message\"] = str(self.message)\n",
    "        retval[\"timestamp\"] = (\"\" if self.timestamp == None\n",
    "                               else self.timestamp.isoformat())\n",
    "        retval[\"log_level\"] = str(LOG_LEVEL.reverse.get(self.log_level, \"\"))\n",
    "\n",
    "        return retval\n"
  ],
  "/home/tushar/coala/coalib/processes/communication/__init__.py": [],
  "/home/tushar/coala/coalib/results/AbsolutePosition.py": [
    "from coalib.results.TextPosition import TextPosition\n",
    "from coala_decorators.decorators import enforce_signature\n",
    "\n",
    "\n",
    "class AbsolutePosition(TextPosition):\n",
    "\n",
    "    @enforce_signature\n",
    "    def __init__(self,\n",
    "                 text: (tuple, list, None)=None,\n",
    "                 position: (int, None)=None):\n",
    "        \"\"\"\n",
    "        Creates an AbsolutePosition object that represents the index of a\n",
    "        character in a string.\n",
    "\n",
    "        :param text:     The text containing the character.\n",
    "        :param position: Position identifying the index of character\n",
    "                         in text.\n",
    "        \"\"\"\n",
    "        line = column = None\n",
    "        if position is not None and text is not None:\n",
    "            line, column = calc_line_col(text, position)\n",
    "        self._text = text\n",
    "        self._position = position\n",
    "        super().__init__(line, column)\n",
    "\n",
    "    @property\n",
    "    def position(self):\n",
    "        return self._position\n",
    "\n",
    "\n",
    "def calc_line_col(text, position):\n",
    "    r\"\"\"\n",
    "    Creates a tuple containing (line, column) by calculating line number\n",
    "    and column in the text, from position.\n",
    "\n",
    "    The position represents the index of a character. In the following\n",
    "    example 'a' is at position '0' and it's corresponding line and column are:\n",
    "\n",
    "    >>> calc_line_col(('a\\n',), 0)\n",
    "    (1, 1)\n",
    "\n",
    "    All special characters(including the newline character) belong in the same\n",
    "    line, and have their own position. A line is an item in the tuple:\n",
    "\n",
    "    >>> calc_line_col(('a\\n', 'b\\n'), 1)\n",
    "    (1, 2)\n",
    "    >>> calc_line_col(('a\\n', 'b\\n'), 2)\n",
    "    (2, 1)\n",
    "\n",
    "    :param text:          A tuple/list of lines in which position is to\n",
    "                          be calculated.\n",
    "    :param position:      Position (starting from 0) of character to be found\n",
    "                          in the (line, column) form.\n",
    "    :return:              A tuple of the form (line, column), where both line\n",
    "                          and column start from 1.\n",
    "    \"\"\"\n",
    "    for linenum, line in enumerate(text, start=1):\n",
    "        linelen = len(line)\n",
    "        if position < linelen:\n",
    "            return linenum, position + 1\n",
    "        position -= linelen\n",
    "\n",
    "    raise ValueError(\"Position not found in text\")\n"
  ],
  "/home/tushar/coala/coalib/results/Diff.py": [
    "import copy\n",
    "import difflib\n",
    "\n",
    "from coalib.results.LineDiff import LineDiff, ConflictError\n",
    "from coalib.results.SourceRange import SourceRange\n",
    "from coala_decorators.decorators import enforce_signature, generate_eq\n",
    "\n",
    "\n",
    "@generate_eq(\"_file\", \"modified\", \"rename\", \"delete\")\n",
    "class Diff:\n",
    "    \"\"\"\n",
    "    A Diff result represents a difference for one file.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, file_list, rename=False, delete=False):\n",
    "        \"\"\"\n",
    "        Creates an empty diff for the given file.\n",
    "\n",
    "        :param file_list: The original (unmodified) file as a list of its\n",
    "                          lines.\n",
    "        :param rename:    False or str containing new name of file.\n",
    "        :param delete:    True if file is set to be deleted.\n",
    "        \"\"\"\n",
    "        self._changes = {}\n",
    "        self._file = file_list\n",
    "        self.rename = rename\n",
    "        self.delete = delete\n",
    "\n",
    "    @classmethod\n",
    "    def from_string_arrays(cls, file_array_1, file_array_2, rename=False):\n",
    "        \"\"\"\n",
    "        Creates a Diff object from two arrays containing strings.\n",
    "\n",
    "        If this Diff is applied to the original array, the second array will be\n",
    "        created.\n",
    "\n",
    "        :param file_array_1: Original array\n",
    "        :param file_array_2: Array to compare\n",
    "        :param rename:       False or str containing new name of file.\n",
    "        \"\"\"\n",
    "        result = cls(file_array_1, rename=rename)\n",
    "\n",
    "        matcher = difflib.SequenceMatcher(None, file_array_1, file_array_2)\n",
    "        # We use this because its faster (generator) and doesnt yield as much\n",
    "        # useless information as get_opcodes.\n",
    "        for change_group in matcher.get_grouped_opcodes(1):\n",
    "            for (tag,\n",
    "                 a_index_1,\n",
    "                 a_index_2,\n",
    "                 b_index_1,\n",
    "                 b_index_2) in change_group:\n",
    "                if tag == \"delete\":\n",
    "                    for index in range(a_index_1+1, a_index_2+1):\n",
    "                        result.delete_line(index)\n",
    "                elif tag == \"insert\":\n",
    "                    # We add after line, they add before, so dont add 1 here\n",
    "                    result.add_lines(a_index_1,\n",
    "                                     file_array_2[b_index_1:b_index_2])\n",
    "                elif tag == \"replace\":\n",
    "                    result.change_line(a_index_1+1,\n",
    "                                       file_array_1[a_index_1],\n",
    "                                       file_array_2[b_index_1])\n",
    "                    result.add_lines(a_index_1+1,\n",
    "                                     file_array_2[b_index_1+1:b_index_2])\n",
    "                    for index in range(a_index_1+2, a_index_2+1):\n",
    "                        result.delete_line(index)\n",
    "\n",
    "        return result\n",
    "\n",
    "    @classmethod\n",
    "    def from_clang_fixit(cls, fixit, file):\n",
    "        \"\"\"\n",
    "        Creates a Diff object from a given clang fixit and the file contents.\n",
    "\n",
    "        :param fixit: A cindex.Fixit object.\n",
    "        :param file:  A list of lines in the file to apply the fixit to.\n",
    "        :return:      The corresponding Diff object.\n",
    "        \"\"\"\n",
    "        assert isinstance(file, (list, tuple))\n",
    "\n",
    "        oldvalue = '\\n'.join(file[fixit.range.start.line-1:\n",
    "                                  fixit.range.end.line])\n",
    "        endindex = fixit.range.end.column - len(file[fixit.range.end.line-1])-1\n",
    "\n",
    "        newvalue = (oldvalue[:fixit.range.start.column-1] +\n",
    "                    fixit.value +\n",
    "                    oldvalue[endindex:])\n",
    "        new_file = (file[:fixit.range.start.line-1] +\n",
    "                    type(file)(newvalue.splitlines(True)) +\n",
    "                    file[fixit.range.end.line:])\n",
    "\n",
    "        return cls.from_string_arrays(file, new_file)\n",
    "\n",
    "    def _get_change(self, line_nr, min_line=1):\n",
    "        if not isinstance(line_nr, int):\n",
    "            raise TypeError(\"line_nr needs to be an integer.\")\n",
    "        if line_nr < min_line:\n",
    "            raise ValueError(\"The given line number is not allowed.\")\n",
    "\n",
    "        return self._changes.get(line_nr, LineDiff())\n",
    "\n",
    "    def stats(self):\n",
    "        \"\"\"\n",
    "        Returns tuple containing number of additions and deletions in the diff.\n",
    "        \"\"\"\n",
    "        additions = 0\n",
    "        deletions = 0\n",
    "        for line_diff in self._changes.values():\n",
    "            if line_diff.change:\n",
    "                additions += 1\n",
    "                deletions += 1\n",
    "            elif line_diff.delete:\n",
    "                deletions += 1\n",
    "            if line_diff.add_after:\n",
    "                additions += len(line_diff.add_after)\n",
    "        return additions, deletions\n",
    "\n",
    "    def __len__(self):\n",
    "        \"\"\"\n",
    "        Returns total number of additions and deletions in diff.\n",
    "        \"\"\"\n",
    "        return sum(self.stats())\n",
    "\n",
    "    @property\n",
    "    def rename(self):\n",
    "        \"\"\"\n",
    "        :return: string containing new name of the file.\n",
    "        \"\"\"\n",
    "        return self._rename\n",
    "\n",
    "    @rename.setter\n",
    "    @enforce_signature\n",
    "    def rename(self, rename: (str, False)):\n",
    "        \"\"\"\n",
    "        :param rename: False or string containing new name of file.\n",
    "        \"\"\"\n",
    "        self._rename = rename\n",
    "\n",
    "    @property\n",
    "    def delete(self):\n",
    "        \"\"\"\n",
    "        :return: True if file is set to be deleted.\n",
    "        \"\"\"\n",
    "        return self._delete\n",
    "\n",
    "    @delete.setter\n",
    "    @enforce_signature\n",
    "    def delete(self, delete: bool):\n",
    "        \"\"\"\n",
    "        :param delete: True if file is set to be deleted, False otherwise.\n",
    "        \"\"\"\n",
    "        self._delete = delete\n",
    "\n",
    "    @property\n",
    "    def original(self):\n",
    "        \"\"\"\n",
    "        Retrieves the original file.\n",
    "        \"\"\"\n",
    "        return self._file\n",
    "\n",
    "    @property\n",
    "    def modified(self):\n",
    "        \"\"\"\n",
    "        Calculates the modified file, after applying the Diff to the original.\n",
    "        \"\"\"\n",
    "        result = []\n",
    "\n",
    "        if self.delete:\n",
    "            return result\n",
    "\n",
    "        current_line = 0\n",
    "\n",
    "        # Note that line_nr counts from _1_ although 0 is possible when\n",
    "        # inserting lines before everything\n",
    "        for line_nr in sorted(self._changes):\n",
    "            result.extend(self._file[current_line:max(line_nr-1, 0)])\n",
    "            linediff = self._changes[line_nr]\n",
    "            if not linediff.delete and not linediff.change and line_nr > 0:\n",
    "                result.append(self._file[line_nr-1])\n",
    "            elif linediff.change:\n",
    "                result.append(linediff.change[1])\n",
    "\n",
    "            if linediff.add_after:\n",
    "                result.extend(linediff.add_after)\n",
    "\n",
    "            current_line = line_nr\n",
    "\n",
    "        result.extend(self._file[current_line:])\n",
    "\n",
    "        return result\n",
    "\n",
    "    @property\n",
    "    def unified_diff(self):\n",
    "        \"\"\"\n",
    "        Generates a unified diff corresponding to this patch.\n",
    "\n",
    "        Note that the unified diff is not deterministic and thus not suitable\n",
    "        for equality comparison.\n",
    "        \"\"\"\n",
    "        return ''.join(difflib.unified_diff(\n",
    "            self.original,\n",
    "            self.modified,\n",
    "            tofile=self.rename if isinstance(self.rename, str) else ''))\n",
    "\n",
    "    def __json__(self):\n",
    "        \"\"\"\n",
    "        Override JSON export, using the unified diff is the easiest thing for\n",
    "        the users.\n",
    "        \"\"\"\n",
    "        return self.unified_diff\n",
    "\n",
    "    def affected_code(self, filename):\n",
    "        \"\"\"\n",
    "        Creates a list of SourceRange objects which point to the related code.\n",
    "        Changes on continuous lines will be put into one SourceRange.\n",
    "\n",
    "        :param filename: The filename to associate the SourceRange's to.\n",
    "        :return:         A list of all related SourceRange objects.\n",
    "        \"\"\"\n",
    "        return list(diff.range(filename)\n",
    "                    for diff in self.split_diff(distance=0))\n",
    "\n",
    "    def split_diff(self, distance=1):\n",
    "        \"\"\"\n",
    "        Splits this diff into small pieces, such that several continuously\n",
    "        altered lines are still together in one diff. All subdiffs will be\n",
    "        yielded.\n",
    "\n",
    "        A diff like this with changes being together closely won't be splitted:\n",
    "\n",
    "        >>> diff = Diff.from_string_arrays([     'b', 'c', 'e'],\n",
    "        ...                                ['a', 'b', 'd', 'f'])\n",
    "        >>> len(list(diff.split_diff()))\n",
    "        1\n",
    "\n",
    "        If we set the distance to 0, it will be splitted:\n",
    "\n",
    "        >>> len(list(diff.split_diff(distance=0)))\n",
    "        2\n",
    "\n",
    "        If a negative distance is given, every change will be yielded as an own\n",
    "        diff, even if they are right beneath each other:\n",
    "\n",
    "        >>> len(list(diff.split_diff(distance=-1)))\n",
    "        3\n",
    "\n",
    "        :param distance: Number of unchanged lines that are allowed in between\n",
    "                         two changed lines so they get yielded as one diff.\n",
    "        \"\"\"\n",
    "        last_line = -1\n",
    "        this_diff = Diff(self._file, rename=self.rename, delete=self.delete)\n",
    "        for line in sorted(self._changes.keys()):\n",
    "            if line > last_line + distance + 1 and len(this_diff._changes) > 0:\n",
    "                yield this_diff\n",
    "                this_diff = Diff(self._file, rename=self.rename,\n",
    "                                 delete=self.delete)\n",
    "\n",
    "            last_line = line\n",
    "            this_diff._changes[line] = self._changes[line]\n",
    "\n",
    "        if len(this_diff._changes) > 0:\n",
    "            yield this_diff\n",
    "\n",
    "    def range(self, filename):\n",
    "        \"\"\"\n",
    "        Calculates a SourceRange spanning over the whole Diff. If something is\n",
    "        added after the 0th line (i.e. before the first line) the first line\n",
    "        will be included in the SourceRange.\n",
    "\n",
    "        :param filename: The filename to associate the SourceRange with.\n",
    "        :return:         A SourceRange object.\n",
    "        \"\"\"\n",
    "        start = min(self._changes.keys())\n",
    "        end = max(self._changes.keys())\n",
    "        return SourceRange.from_values(filename,\n",
    "                                       start_line=max(1, start),\n",
    "                                       end_line=max(1, end))\n",
    "\n",
    "    def __add__(self, other):\n",
    "        \"\"\"\n",
    "        Adds another diff to this one. Will throw an exception if this is not\n",
    "        possible. (This will *not* be done in place.)\n",
    "        \"\"\"\n",
    "        if not isinstance(other, Diff):\n",
    "            raise TypeError(\"Only diffs can be added to a diff.\")\n",
    "\n",
    "        if self.rename != other.rename and False not in (self.rename,\n",
    "                                                         other.rename):\n",
    "            raise ConflictError(\"Diffs contain conflicting renamings.\")\n",
    "\n",
    "        result = copy.deepcopy(self)\n",
    "        result.rename = self.rename or other.rename\n",
    "        result.delete = self.delete or other.delete\n",
    "\n",
    "        for line_nr in other._changes:\n",
    "            change = other._changes[line_nr]\n",
    "            if change.delete is True:\n",
    "                result.delete_line(line_nr)\n",
    "            if change.add_after is not False:\n",
    "                result.add_lines(line_nr, change.add_after)\n",
    "            if change.change is not False:\n",
    "                result.change_line(line_nr, change.change[0], change.change[1])\n",
    "\n",
    "        return result\n",
    "\n",
    "    def delete_line(self, line_nr):\n",
    "        \"\"\"\n",
    "        Mark the given line nr as deleted. The first line is line number 1.\n",
    "        \"\"\"\n",
    "        linediff = self._get_change(line_nr)\n",
    "        linediff.delete = True\n",
    "        self._changes[line_nr] = linediff\n",
    "\n",
    "    def add_lines(self, line_nr_before, lines):\n",
    "        \"\"\"\n",
    "        Adds lines after the given line number.\n",
    "\n",
    "        :param line_nr_before: Line number of the line before the additions.\n",
    "                               Use 0 for insert lines before everything.\n",
    "        :param lines:          A list of lines to add.\n",
    "        \"\"\"\n",
    "        if lines == []:\n",
    "            return  # No action\n",
    "\n",
    "        linediff = self._get_change(line_nr_before, min_line=0)\n",
    "        if linediff.add_after is not False:\n",
    "            raise ConflictError(\"Cannot add lines after the given line since \"\n",
    "                                \"there are already lines.\")\n",
    "\n",
    "        linediff.add_after = lines\n",
    "        self._changes[line_nr_before] = linediff\n",
    "\n",
    "    def change_line(self, line_nr, original_line, replacement):\n",
    "        \"\"\"\n",
    "        Changes the given line with the given line number. The replacement will\n",
    "        be there instead.\n",
    "        \"\"\"\n",
    "        linediff = self._get_change(line_nr)\n",
    "        if linediff.change is not False:\n",
    "            raise ConflictError(\"An already changed line cannot be changed.\")\n",
    "\n",
    "        linediff.change = (original_line, replacement)\n",
    "        self._changes[line_nr] = linediff\n"
  ],
  "/home/tushar/coala/coalib/results/HiddenResult.py": [
    "from coalib.results.Result import Result\n",
    "\n",
    "\n",
    "class HiddenResult(Result):\n",
    "    \"\"\"\n",
    "    This is a result that is not meant to be shown to the user. It can be used\n",
    "    to transfer any data from a dependent bear to others.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, origin, contents):\n",
    "        \"\"\"\n",
    "        Creates a new HiddenResult. The contents can be accessed with\n",
    "        obj.contents later.\n",
    "\n",
    "        :param origin:   The originating bear.\n",
    "        :param contents: Any object that is picklable since it will be\n",
    "                         transferred across processes.\n",
    "        \"\"\"\n",
    "        Result.__init__(self, origin, \"\")\n",
    "\n",
    "        self.contents = contents\n"
  ],
  "/home/tushar/coala/coalib/results/LineDiff.py": [
    "import collections\n",
    "\n",
    "from coala_decorators.decorators import generate_repr\n",
    "\n",
    "\n",
    "class ConflictError(Exception):\n",
    "    pass\n",
    "\n",
    "\n",
    "@generate_repr('change', 'delete', 'add_after')\n",
    "class LineDiff:\n",
    "    \"\"\"\n",
    "    A LineDiff holds the difference between two strings.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, change=False, delete=False, add_after=False):\n",
    "        \"\"\"\n",
    "        Creates a new LineDiff object. Note that a line cannot be\n",
    "        changed _and_ deleted at the same time.\n",
    "\n",
    "        :param change: False or a tuple (original, replacement)\n",
    "        :param delete: True/False\n",
    "        :param add_after: False or a list of lines to append after this ones\n",
    "        \"\"\"\n",
    "        # change property setter will need this value for assertion\n",
    "        self._delete = False\n",
    "\n",
    "        self.change = change\n",
    "        self.delete = delete\n",
    "        self.add_after = add_after\n",
    "\n",
    "    def __eq__(self, other):\n",
    "        return (self.change == other.change and\n",
    "                self.delete == other.delete and\n",
    "                self.add_after == other.add_after)\n",
    "\n",
    "    @property\n",
    "    def change(self):\n",
    "        return self._change\n",
    "\n",
    "    @change.setter\n",
    "    def change(self, value):\n",
    "        if value is not False and not isinstance(value, tuple):\n",
    "            raise TypeError(\"change must be False or a tuple with an original \"\n",
    "                            \"and a replacement string.\")\n",
    "        if value is not False and self.delete is not False:\n",
    "            raise ConflictError(\"A line cannot be changed and deleted \"\n",
    "                                \"at the same time.\")\n",
    "\n",
    "        self._change = value\n",
    "\n",
    "    @property\n",
    "    def delete(self):\n",
    "        return self._delete\n",
    "\n",
    "    @delete.setter\n",
    "    def delete(self, value):\n",
    "        if not isinstance(value, bool):\n",
    "            raise TypeError(\"delete can only be a boolean value.\")\n",
    "        if value is not False and self.change is not False:\n",
    "            raise ConflictError(\"A line cannot be changed and deleted \"\n",
    "                                \"at the same time.\")\n",
    "\n",
    "        self._delete = value\n",
    "\n",
    "    @property\n",
    "    def add_after(self):\n",
    "        return self._add_after\n",
    "\n",
    "    @add_after.setter\n",
    "    def add_after(self, value):\n",
    "        if value is not False and not isinstance(value, collections.Iterable):\n",
    "            raise TypeError(\n",
    "                \"add_after must be False or a list of lines to append.\")\n",
    "        if isinstance(value, collections.Iterable):\n",
    "            value = list(value)\n",
    "        self._add_after = value if value != [] else False\n"
  ],
  "/home/tushar/coala/coalib/results/RESULT_SEVERITY.py": [
    "from coalib.misc.Enum import enum\n",
    "\n",
    "RESULT_SEVERITY = enum(\"INFO\", \"NORMAL\", \"MAJOR\")\n",
    "RESULT_SEVERITY.__str__ = lambda x: RESULT_SEVERITY.reverse.get(x, \"NORMAL\")\n",
    "RESULT_SEVERITY_COLORS = {RESULT_SEVERITY.INFO: \"green\",\n",
    "                          RESULT_SEVERITY.NORMAL: \"yellow\",\n",
    "                          RESULT_SEVERITY.MAJOR: \"red\"}\n"
  ],
  "/home/tushar/coala/coalib/results/Result.py": [
    "import uuid\n",
    "from os.path import relpath\n",
    "\n",
    "from coala_decorators.decorators import (\n",
    "    enforce_signature, generate_ordering, generate_repr, get_public_members)\n",
    "from coalib.results.RESULT_SEVERITY import RESULT_SEVERITY\n",
    "from coalib.results.SourceRange import SourceRange\n",
    "\n",
    "\n",
    "# Omit additional info, debug message and diffs for brevity\n",
    "@generate_repr((\"id\", hex),\n",
    "               \"origin\",\n",
    "               \"affected_code\",\n",
    "               (\"severity\", RESULT_SEVERITY.reverse.get),\n",
    "               \"message\")\n",
    "@generate_ordering(\"affected_code\",\n",
    "                   \"severity\",\n",
    "                   \"origin\",\n",
    "                   \"message\",\n",
    "                   \"additional_info\",\n",
    "                   \"debug_msg\",\n",
    "                   \"diffs\")\n",
    "class Result:\n",
    "    \"\"\"\n",
    "    A result is anything that has an origin and a message.\n",
    "\n",
    "    Optionally it might affect a file.\n",
    "    \"\"\"\n",
    "\n",
    "    @enforce_signature\n",
    "    def __init__(self,\n",
    "                 origin,\n",
    "                 message: str,\n",
    "                 affected_code: (tuple, list)=(),\n",
    "                 severity: int=RESULT_SEVERITY.NORMAL,\n",
    "                 additional_info: str=\"\",\n",
    "                 debug_msg=\"\",\n",
    "                 diffs: (dict, None)=None):\n",
    "        \"\"\"\n",
    "        :param origin:          Class name or class of the creator of this\n",
    "                                object.\n",
    "        :param message:         Message to show with this result.\n",
    "        :param affected_code:   A tuple of SourceRange objects pointing to\n",
    "                                related positions in the source code.\n",
    "        :param severity:        Severity of this result.\n",
    "        :param additional_info: A long description holding additional\n",
    "                                information about the issue and/or how to fix\n",
    "                                it. You can use this like a manual entry for a\n",
    "                                category of issues.\n",
    "        :param debug_msg:       A message which may help the user find out why\n",
    "                                this result was yielded.\n",
    "        :param diffs:           A dictionary with filenames as key and a\n",
    "                                sequence of ``Diff`` objects associated with\n",
    "                                them as values.\n",
    "        \"\"\"\n",
    "        origin = origin or \"\"\n",
    "        if not isinstance(origin, str):\n",
    "            origin = origin.__class__.__name__\n",
    "        if severity not in RESULT_SEVERITY.reverse:\n",
    "            raise ValueError(\"severity is not a valid RESULT_SEVERITY\")\n",
    "\n",
    "        self.origin = origin\n",
    "        self.message = message\n",
    "        self.debug_msg = debug_msg\n",
    "        self.additional_info = additional_info\n",
    "        # Sorting is important for tuple comparison\n",
    "        self.affected_code = tuple(sorted(affected_code))\n",
    "        self.severity = severity\n",
    "        self.diffs = diffs\n",
    "        self.id = uuid.uuid4().int\n",
    "\n",
    "    @classmethod\n",
    "    @enforce_signature\n",
    "    def from_values(cls,\n",
    "                    origin,\n",
    "                    message: str,\n",
    "                    file: str,\n",
    "                    line: (int, None)=None,\n",
    "                    column: (int, None)=None,\n",
    "                    end_line: (int, None)=None,\n",
    "                    end_column: (int, None)=None,\n",
    "                    severity: int=RESULT_SEVERITY.NORMAL,\n",
    "                    additional_info: str=\"\",\n",
    "                    debug_msg=\"\",\n",
    "                    diffs: (dict, None)=None):\n",
    "        \"\"\"\n",
    "        Creates a result with only one SourceRange with the given start and end\n",
    "        locations.\n",
    "\n",
    "        :param origin:          Class name or class of the creator of this\n",
    "                                object.\n",
    "        :param message:         A message to explain the result.\n",
    "        :param file:            The related file.\n",
    "        :param line:            The first related line in the file.\n",
    "                                (First line is 1)\n",
    "        :param column:          The column indicating the first character.\n",
    "                                (First character is 1)\n",
    "        :param end_line:        The last related line in the file.\n",
    "        :param end_column:      The column indicating the last character.\n",
    "        :param severity:        A RESULT_SEVERITY object.\n",
    "        :param debug_msg:       Another object useful for debugging purposes.\n",
    "        :param additional_info: A long description holding additional\n",
    "                                information about the issue and/or how to fix\n",
    "                                it. You can use this like a manual entry for a\n",
    "                                category of issues.\n",
    "        :param diffs:           A dictionary with filenames as key and a\n",
    "                                sequence of ``Diff`` objects associated with\n",
    "                                them as values.\n",
    "        \"\"\"\n",
    "        range = SourceRange.from_values(file,\n",
    "                                        line,\n",
    "                                        column,\n",
    "                                        end_line,\n",
    "                                        end_column)\n",
    "\n",
    "        return cls(origin=origin,\n",
    "                   message=message,\n",
    "                   affected_code=(range,),\n",
    "                   severity=severity,\n",
    "                   additional_info=additional_info,\n",
    "                   debug_msg=debug_msg,\n",
    "                   diffs=diffs)\n",
    "\n",
    "    def to_string_dict(self):\n",
    "        \"\"\"\n",
    "        Makes a dictionary which has all keys and values as strings and\n",
    "        contains all the data that the base Result has.\n",
    "\n",
    "        FIXME: diffs are not serialized ATM.\n",
    "        FIXME: Only the first SourceRange of affected_code is serialized. If\n",
    "        there are more, this data is currently missing.\n",
    "\n",
    "        :return: Dictionary with keys and values as string.\n",
    "        \"\"\"\n",
    "        retval = {}\n",
    "\n",
    "        members = [\"id\",\n",
    "                   \"additional_info\",\n",
    "                   \"debug_msg\",\n",
    "                   \"message\",\n",
    "                   \"origin\"]\n",
    "\n",
    "        for member in members:\n",
    "            value = getattr(self, member)\n",
    "            retval[member] = \"\" if value == None else str(value)\n",
    "\n",
    "        retval[\"severity\"] = str(RESULT_SEVERITY.reverse.get(\n",
    "            self.severity, \"\"))\n",
    "        if len(self.affected_code) > 0:\n",
    "            retval[\"file\"] = self.affected_code[0].file\n",
    "            line = self.affected_code[0].start.line\n",
    "            retval[\"line_nr\"] = \"\" if line is None else str(line)\n",
    "        else:\n",
    "            retval[\"file\"], retval[\"line_nr\"] = \"\", \"\"\n",
    "\n",
    "        return retval\n",
    "\n",
    "    @enforce_signature\n",
    "    def apply(self, file_dict: dict):\n",
    "        \"\"\"\n",
    "        Applies all contained diffs to the given file_dict. This operation will\n",
    "        be done in-place.\n",
    "\n",
    "        :param file_dict: A dictionary containing all files with filename as\n",
    "                          key and all lines a value. Will be modified.\n",
    "        \"\"\"\n",
    "        for filename in self.diffs:\n",
    "            file_dict[filename] = self.diffs[filename].modified\n",
    "\n",
    "    def __add__(self, other):\n",
    "        \"\"\"\n",
    "        Joins those patches to one patch.\n",
    "\n",
    "        :param other: The other patch.\n",
    "        \"\"\"\n",
    "        assert isinstance(self.diffs, dict)\n",
    "        assert isinstance(other.diffs, dict)\n",
    "\n",
    "        for filename in other.diffs:\n",
    "            if filename in self.diffs:\n",
    "                self.diffs[filename] += other.diffs[filename]\n",
    "            else:\n",
    "                self.diffs[filename] = other.diffs[filename]\n",
    "\n",
    "        return self\n",
    "\n",
    "    def overlaps(self, ranges):\n",
    "        \"\"\"\n",
    "        Determines if the result overlaps with source ranges provided.\n",
    "\n",
    "        :param ranges: A list SourceRange objects to check for overlap.\n",
    "        :return:       True if the ranges overlap with the result.\n",
    "        \"\"\"\n",
    "        if isinstance(ranges, SourceRange):\n",
    "            ranges = [ranges]\n",
    "\n",
    "        for range in ranges:\n",
    "            for self_range in self.affected_code:\n",
    "                if range.overlaps(self_range):\n",
    "                    return True\n",
    "\n",
    "        return False\n",
    "\n",
    "    def location_repr(self):\n",
    "        \"\"\"\n",
    "        Retrieves a string, that briefly represents\n",
    "        the affected code of the result.\n",
    "\n",
    "        :return: A string containing all of the affected files\n",
    "                 seperated by a comma.\n",
    "        \"\"\"\n",
    "\n",
    "        if not self.affected_code:\n",
    "            return \"the whole project\"\n",
    "\n",
    "        # Set important to exclude duplicate file names\n",
    "        range_paths = set(sourcerange.file\n",
    "                          for sourcerange in self.affected_code)\n",
    "\n",
    "        return ', '.join(repr(relpath(range_path))\n",
    "                         for range_path in sorted(range_paths))\n",
    "\n",
    "    def __json__(self, use_relpath=False):\n",
    "        _dict = get_public_members(self)\n",
    "        if use_relpath and _dict['diffs']:\n",
    "            _dict['diffs'] = {relpath(file): diff\n",
    "                              for file, diff in _dict['diffs'].items()}\n",
    "        return _dict\n"
  ],
  "/home/tushar/coala/coalib/results/ResultFilter.py": [
    "import copy\n",
    "from difflib import SequenceMatcher\n",
    "\n",
    "from coalib.results.Diff import ConflictError, Diff\n",
    "from coalib.results.SourceRange import SourceRange\n",
    "\n",
    "\n",
    "def filter_results(original_file_dict,\n",
    "                   modified_file_dict,\n",
    "                   original_results,\n",
    "                   modified_results):\n",
    "    \"\"\"\n",
    "    Filters results for such ones that are unique across file changes\n",
    "\n",
    "    :param original_file_dict: Dict of lists of file contents before  changes\n",
    "    :param modified_file_dict: Dict of lists of file contents after changes\n",
    "    :param original_results:   List of results of the old files\n",
    "    :param modified_results:   List of results of the new files\n",
    "    :return:                   List of results from new files that are unique\n",
    "                               from all those that existed in the old changes\n",
    "    \"\"\"\n",
    "\n",
    "    renamed_files = ensure_files_present(original_file_dict,\n",
    "                                         modified_file_dict)\n",
    "    # diffs_dict[file] is a diff between the original and modified file\n",
    "    diffs_dict = {}\n",
    "    for file in original_file_dict:\n",
    "        diffs_dict[file] = Diff.from_string_arrays(\n",
    "            original_file_dict[file],\n",
    "            modified_file_dict[renamed_files.get(file, file)])\n",
    "\n",
    "    orig_result_diff_dict_dict = remove_result_ranges_diffs(original_results,\n",
    "                                                            original_file_dict)\n",
    "\n",
    "    mod_result_diff_dict_dict = remove_result_ranges_diffs(modified_results,\n",
    "                                                           modified_file_dict)\n",
    "\n",
    "    unique_results = []\n",
    "\n",
    "    for m_r in reversed(modified_results):\n",
    "        unique = True\n",
    "\n",
    "        for o_r in original_results:\n",
    "\n",
    "            if basics_match(o_r, m_r):\n",
    "                if source_ranges_match(original_file_dict,\n",
    "                                       diffs_dict,\n",
    "                                       orig_result_diff_dict_dict[o_r],\n",
    "                                       mod_result_diff_dict_dict[m_r],\n",
    "                                       renamed_files):\n",
    "\n",
    "                    # at least one original result matches completely\n",
    "                    unique = False\n",
    "                    break\n",
    "        if unique:\n",
    "            unique_results.append(m_r)\n",
    "\n",
    "    return unique_results\n",
    "\n",
    "\n",
    "def basics_match(original_result,\n",
    "                 modified_result):\n",
    "    \"\"\"\n",
    "    Checks whether the following properties of two results match:\n",
    "    * origin\n",
    "    * message\n",
    "    * severity\n",
    "    * debug_msg\n",
    "\n",
    "    :param original_result: A result of the old files\n",
    "    :param modified_result: A result of the new files\n",
    "    :return:                Boolean value whether or not the properties match\n",
    "    \"\"\"\n",
    "\n",
    "    return all(getattr(original_result, member) ==\n",
    "               getattr(modified_result, member)\n",
    "               for member in ['origin', 'message', 'severity', 'debug_msg'])\n",
    "\n",
    "\n",
    "def source_ranges_match(original_file_dict,\n",
    "                        diff_dict,\n",
    "                        original_result_diff_dict,\n",
    "                        modified_result_diff_dict,\n",
    "                        renamed_files):\n",
    "    \"\"\"\n",
    "    Checks whether the SourceRanges of two results match\n",
    "\n",
    "    :param original_file_dict: Dict of lists of file contents before changes\n",
    "    :param diff_dict:          Dict of diffs describing the changes per file\n",
    "    :param original_result_diff_dict: diff for each file for this result\n",
    "    :param modified_result_diff_dict: guess\n",
    "    :param renamed_files:   A dictionary containing file renamings across runs\n",
    "    :return:                     Boolean value whether the SourceRanges match\n",
    "    \"\"\"\n",
    "    for file_name in original_file_dict:\n",
    "\n",
    "        try:  # fails if the affected range of the result get's modified\n",
    "            original_total_diff = (diff_dict[file_name] +\n",
    "                                   original_result_diff_dict[file_name])\n",
    "        except ConflictError:\n",
    "            return False\n",
    "\n",
    "        # original file with file_diff and original_diff applied\n",
    "        original_total_file = original_total_diff.modified\n",
    "        # modified file with modified_diff applied\n",
    "        modified_total_file = modified_result_diff_dict[\n",
    "            renamed_files.get(file_name, file_name)].modified\n",
    "        if original_total_file != modified_total_file:\n",
    "            return False\n",
    "    return True\n",
    "\n",
    "\n",
    "def remove_range(file_contents, source_range):\n",
    "    \"\"\"\n",
    "    removes the chars covered by the sourceRange from the file\n",
    "\n",
    "    :param file_contents: list of lines in the file\n",
    "    :param source_range:  Source Range\n",
    "    :return:              list of file contents without specified chars removed\n",
    "    \"\"\"\n",
    "    if not file_contents:\n",
    "        return []\n",
    "\n",
    "    newfile = list(file_contents)\n",
    "    # attention: line numbers in the SourceRange are human-readable,\n",
    "    # list indices start with 0\n",
    "\n",
    "    source_range = source_range.expand(file_contents)\n",
    "\n",
    "    if source_range.start.line == source_range.end.line:\n",
    "        # if it's all in one line, replace the line by it's beginning and end\n",
    "        newfile[source_range.start.line - 1] = (\n",
    "            newfile[source_range.start.line - 1][:source_range.start.column-1]\n",
    "            + newfile[source_range.start.line - 1][source_range.end.column:])\n",
    "        if newfile[source_range.start.line - 1] == \"\":\n",
    "            del newfile[source_range.start.line - 1]\n",
    "    else:\n",
    "        # cut away after start\n",
    "        newfile[source_range.start.line - 1] = (\n",
    "            newfile[source_range.start.line - 1][:source_range.start.column-1])\n",
    "\n",
    "        # cut away before end\n",
    "        newfile[source_range.end.line - 1] = (\n",
    "            newfile[source_range.end.line - 1][source_range.end.column:])\n",
    "\n",
    "        # start: index = first line number ==> line after first line\n",
    "        # end: index = last line -2 ==> line before last line\n",
    "\n",
    "        for i in reversed(range(\n",
    "                source_range.start.line, source_range.end.line - 1)):\n",
    "            del newfile[i]\n",
    "\n",
    "        # remove leftover empty lines\n",
    "        # the first line here is actually the former `source_range.end.line -1`\n",
    "        if newfile[source_range.start.line] == \"\":\n",
    "            del newfile[source_range.start.line]\n",
    "        if newfile[source_range.start.line - 1] == \"\":\n",
    "            del newfile[source_range.start.line - 1]\n",
    "\n",
    "    return newfile\n",
    "\n",
    "\n",
    "def remove_result_ranges_diffs(result_list, file_dict):\n",
    "    \"\"\"\n",
    "    Calculates the diffs to all files in file_dict that describe the removal of\n",
    "    each respective result's affected code.\n",
    "\n",
    "    :param result_list: list of results\n",
    "    :param file_dict:   dict of file contents\n",
    "    :return:            returnvalue[result][file] is a diff of the changes the\n",
    "                        removal of this result's affected code would cause for\n",
    "                        the file.\n",
    "    \"\"\"\n",
    "    result_diff_dict_dict = {}\n",
    "    for original_result in result_list:\n",
    "        mod_file_dict = copy.deepcopy(file_dict)\n",
    "\n",
    "        # gather all source ranges from this result\n",
    "        source_ranges = []\n",
    "\n",
    "        # SourceRanges must be sorted backwards and overlaps must be eliminated\n",
    "        # this way, the deletion based on sourceRanges is not offset by\n",
    "        # previous deletions in the same line that invalidate the indices.\n",
    "        previous = None\n",
    "\n",
    "        for source_range in sorted(original_result.affected_code, reverse=True):\n",
    "            # previous exists and overlaps\n",
    "            if previous is not None and source_range.overlaps(previous):\n",
    "                combined_sr = SourceRange.join(previous, source_range)\n",
    "                previous = combined_sr\n",
    "            elif previous is None:\n",
    "                previous = source_range\n",
    "            # previous exists but it doesn't overlap\n",
    "            else:\n",
    "                source_ranges.append(previous)\n",
    "                previous = source_range\n",
    "        # don't forget last entry if there were any:\n",
    "        if previous:\n",
    "            source_ranges.append(previous)\n",
    "\n",
    "        for source_range in source_ranges:\n",
    "            file_name = source_range.file\n",
    "            new_file = remove_range(mod_file_dict[file_name],\n",
    "                                    source_range)\n",
    "            mod_file_dict[file_name] = new_file\n",
    "\n",
    "        diff_dict = {}\n",
    "        for file_name in file_dict:\n",
    "            diff_dict[file_name] = Diff.from_string_arrays(\n",
    "                file_dict[file_name],\n",
    "                mod_file_dict[file_name])\n",
    "\n",
    "        result_diff_dict_dict[original_result] = diff_dict\n",
    "\n",
    "    return result_diff_dict_dict\n",
    "\n",
    "\n",
    "def ensure_files_present(original_file_dict, modified_file_dict):\n",
    "    \"\"\"\n",
    "    Ensures that all files are available as keys in both dicts.\n",
    "\n",
    "    :param original_file_dict: Dict of lists of file contents before  changes\n",
    "    :param modified_file_dict: Dict of lists of file contents after changes\n",
    "    :return:                   Return a dictionary of renamed files.\n",
    "    \"\"\"\n",
    "    original_files = set(original_file_dict.keys())\n",
    "    modified_files = set(modified_file_dict.keys())\n",
    "    affected_files = original_files | modified_files\n",
    "    original_unique_files = affected_files - modified_files\n",
    "    renamed_files_dict = {}\n",
    "    for file in filter(\n",
    "            lambda filter_file: filter_file not in original_files,\n",
    "            affected_files):\n",
    "        for comparable_file in original_unique_files:\n",
    "            s = SequenceMatcher(\n",
    "                None,\n",
    "                ''.join(modified_file_dict[file]),\n",
    "                ''.join(original_file_dict[comparable_file]))\n",
    "            if s.real_quick_ratio() >= 0.5 and s.ratio() > 0.5:\n",
    "                renamed_files_dict[comparable_file] = file\n",
    "                break\n",
    "        else:\n",
    "            original_file_dict[file] = []\n",
    "    for file in filter(\n",
    "            lambda filter_file: filter_file not in modified_files,\n",
    "            affected_files):\n",
    "        modified_file_dict[file] = []\n",
    "    return renamed_files_dict\n"
  ],
  "/home/tushar/coala/coalib/results/SourcePosition.py": [
    "from os.path import relpath, abspath\n",
    "\n",
    "from coala_decorators.decorators import (\n",
    "    enforce_signature, generate_ordering, generate_repr, get_public_members)\n",
    "from coalib.results.TextPosition import TextPosition\n",
    "\n",
    "\n",
    "@generate_repr(\"file\", \"line\", \"column\")\n",
    "@generate_ordering(\"file\", \"line\", \"column\")\n",
    "class SourcePosition(TextPosition):\n",
    "\n",
    "    @enforce_signature\n",
    "    def __init__(self, file: str, line=None, column=None):\n",
    "        \"\"\"\n",
    "        Creates a new result position object that represents the position of a\n",
    "        result in the source code.\n",
    "\n",
    "        :param file:        The filename.\n",
    "        :param line:        The line in file or None, the first line is 1.\n",
    "        :param column:      The column indicating the character. The first one\n",
    "                            in a line is 1.\n",
    "        :raises TypeError:  Raised when\n",
    "                            - file is not a string or None.\n",
    "                            - line or columns are no integers.\n",
    "        \"\"\"\n",
    "        TextPosition.__init__(self, line, column)\n",
    "\n",
    "        self._file = abspath(file)\n",
    "\n",
    "    @property\n",
    "    def file(self):\n",
    "        return self._file\n",
    "\n",
    "    def __json__(self, use_relpath=False):\n",
    "        _dict = get_public_members(self)\n",
    "        if use_relpath:\n",
    "            _dict['file'] = relpath(_dict['file'])\n",
    "        return _dict\n"
  ],
  "/home/tushar/coala/coalib/results/SourceRange.py": [
    "from os.path import relpath\n",
    "\n",
    "from coala_decorators.decorators import enforce_signature, get_public_members\n",
    "from coalib.results.SourcePosition import SourcePosition\n",
    "from coalib.results.TextRange import TextRange\n",
    "from coalib.results.AbsolutePosition import AbsolutePosition\n",
    "\n",
    "\n",
    "class SourceRange(TextRange):\n",
    "\n",
    "    @enforce_signature\n",
    "    def __init__(self,\n",
    "                 start: SourcePosition,\n",
    "                 end: (SourcePosition, None)=None):\n",
    "        \"\"\"\n",
    "        Creates a new SourceRange.\n",
    "\n",
    "        :param start:       A SourcePosition indicating the start of the range.\n",
    "        :param end:         A SourcePosition indicating the end of the range.\n",
    "                            If ``None`` is given, the start object will be used\n",
    "                            here. end must be in the same file and be greater\n",
    "                            than start as negative ranges are not allowed.\n",
    "        :raises TypeError:  Raised when\n",
    "                            - start is no SourcePosition or None.\n",
    "                            - end is no SourcePosition.\n",
    "        :raises ValueError: Raised when file of start and end mismatch.\n",
    "        \"\"\"\n",
    "        TextRange.__init__(self, start, end)\n",
    "\n",
    "        if self.start.file != self.end.file:\n",
    "            raise ValueError(\"File of start and end position do not match.\")\n",
    "\n",
    "    @classmethod\n",
    "    def from_values(cls,\n",
    "                    file,\n",
    "                    start_line=None,\n",
    "                    start_column=None,\n",
    "                    end_line=None,\n",
    "                    end_column=None):\n",
    "        start = SourcePosition(file, start_line, start_column)\n",
    "        if end_line or (end_column and end_column > start_column):\n",
    "            end = SourcePosition(file, end_line if end_line else start_line,\n",
    "                                 end_column)\n",
    "        else:\n",
    "            end = None\n",
    "\n",
    "        return cls(start, end)\n",
    "\n",
    "    @classmethod\n",
    "    def from_clang_range(cls, range):\n",
    "        \"\"\"\n",
    "        Creates a SourceRange from a clang SourceRange object.\n",
    "\n",
    "        :param range: A cindex.SourceRange object.\n",
    "        \"\"\"\n",
    "        return cls.from_values(range.start.file.name,\n",
    "                               range.start.line,\n",
    "                               range.start.column,\n",
    "                               range.end.line,\n",
    "                               range.end.column)\n",
    "\n",
    "    @classmethod\n",
    "    @enforce_signature\n",
    "    def from_absolute_position(cls,\n",
    "                               file: str,\n",
    "                               position_start: AbsolutePosition,\n",
    "                               position_end: (AbsolutePosition, None)=None):\n",
    "        \"\"\"\n",
    "        Creates a SourceRange from a start and end positions.\n",
    "\n",
    "        :param file:           Name of the file.\n",
    "        :param position_start: Start of range given by AbsolutePosition.\n",
    "        :param position_end:   End of range given by AbsolutePosition or None.\n",
    "        \"\"\"\n",
    "        start = SourcePosition(file, position_start.line, position_start.column)\n",
    "        end = None\n",
    "        if position_end:\n",
    "            end = SourcePosition(file, position_end.line, position_end.column)\n",
    "        return cls(start, end)\n",
    "\n",
    "    @property\n",
    "    def file(self):\n",
    "        return self.start.file\n",
    "\n",
    "    @enforce_signature\n",
    "    def renamed_file(self, file_diff_dict: dict):\n",
    "        \"\"\"\n",
    "        Retrieves the filename this source range refers to while taking the\n",
    "        possible file renamings in the given file_diff_dict into account:\n",
    "\n",
    "        :param file_diff_dict: A dictionary with filenames as key and their\n",
    "                               associated Diff objects as values.\n",
    "        \"\"\"\n",
    "        diff = file_diff_dict.get(self.file)\n",
    "        if diff is None:\n",
    "            return self.file\n",
    "\n",
    "        return diff.rename if diff.rename is not False else self.file\n",
    "\n",
    "    def expand(self, file_contents):\n",
    "        \"\"\"\n",
    "        Passes a new SourceRange that covers the same area of a file as this\n",
    "        one would. All values of None get replaced with absolute values.\n",
    "\n",
    "        values of None will be interpreted as follows:\n",
    "        self.start.line is None:   -> 1\n",
    "        self.start.column is None: -> 1\n",
    "        self.end.line is None:     -> last line of file\n",
    "        self.end.column is None:   -> last column of self.end.line\n",
    "\n",
    "        :param file_contents: File contents of the applicable file\n",
    "        :return:              TextRange with absolute values\n",
    "        \"\"\"\n",
    "        tr = TextRange.expand(self, file_contents)\n",
    "\n",
    "        return SourceRange.from_values(self.file,\n",
    "                                       tr.start.line,\n",
    "                                       tr.start.column,\n",
    "                                       tr.end.line,\n",
    "                                       tr.end.column)\n",
    "\n",
    "    def __json__(self, use_relpath=False):\n",
    "        _dict = get_public_members(self)\n",
    "        if use_relpath:\n",
    "            _dict['file'] = relpath(_dict['file'])\n",
    "        return _dict\n"
  ],
  "/home/tushar/coala/coalib/results/TextPosition.py": [
    "from coala_decorators.decorators import (\n",
    "    enforce_signature, generate_ordering, generate_repr)\n",
    "\n",
    "\n",
    "@generate_repr(\"line\", \"column\")\n",
    "@generate_ordering(\"line\", \"column\")\n",
    "class TextPosition:\n",
    "\n",
    "    @enforce_signature\n",
    "    def __init__(self, line: (int, None)=None, column: (int, None)=None):\n",
    "        \"\"\"\n",
    "        Creates a new TextPosition object that represents the position inside\n",
    "        a string with line/column numbers.\n",
    "\n",
    "        :param line:        The line in file or None, the first line is 1.\n",
    "        :param column:      The column indicating the character. The first one\n",
    "                            in a line is 1.\n",
    "        :raises TypeError:  Raised when line or columns are no integers.\n",
    "        :raises ValueError: Raised when a column is set but line is None.\n",
    "        \"\"\"\n",
    "        if line is None and column is not None:\n",
    "            raise ValueError(\"A column can only be set if a line is set.\")\n",
    "\n",
    "        self._line = line\n",
    "        self._column = column\n",
    "\n",
    "    @property\n",
    "    def line(self):\n",
    "        return self._line\n",
    "\n",
    "    @property\n",
    "    def column(self):\n",
    "        return self._column\n"
  ],
  "/home/tushar/coala/coalib/results/TextRange.py": [
    "import copy\n",
    "\n",
    "from coala_decorators.decorators import (\n",
    "    enforce_signature, generate_ordering, generate_repr)\n",
    "from coalib.results.TextPosition import TextPosition\n",
    "\n",
    "\n",
    "@generate_repr(\"start\", \"end\")\n",
    "@generate_ordering(\"start\", \"end\")\n",
    "class TextRange:\n",
    "\n",
    "    @enforce_signature\n",
    "    def __init__(self, start: TextPosition, end: (TextPosition, None)=None):\n",
    "        \"\"\"\n",
    "        Creates a new TextRange.\n",
    "\n",
    "        :param start:       A TextPosition indicating the start of the range.\n",
    "                            Can't be ``None``.\n",
    "        :param end:         A TextPosition indicating the end of the range. If\n",
    "                            ``None`` is given, the start object will be used\n",
    "                            here.\n",
    "        :raises TypeError:  Raised when\n",
    "                            - start is no TextPosition or None.\n",
    "                            - end is no TextPosition.\n",
    "        :raises ValueError: Raised when end position is smaller than start\n",
    "                            position, because negative ranges are not allowed.\n",
    "        \"\"\"\n",
    "\n",
    "        self._start = start\n",
    "        self._end = end or copy.deepcopy(start)\n",
    "\n",
    "        if self._end < start:\n",
    "            raise ValueError(\"End position can't be less than start position.\")\n",
    "\n",
    "    @classmethod\n",
    "    def from_values(cls,\n",
    "                    start_line=None,\n",
    "                    start_column=None,\n",
    "                    end_line=None,\n",
    "                    end_column=None):\n",
    "        \"\"\"\n",
    "        Creates a new TextRange.\n",
    "\n",
    "        :param start_line:   The line number of the start position. The first\n",
    "                             line is 1.\n",
    "        :param start_column: The column number of the start position. The first\n",
    "                             column is 1.\n",
    "        :param end_line:     The line number of the end position. If this\n",
    "                             parameter is ``None``, then the end position is set\n",
    "                             the same like start position and end_column gets\n",
    "                             ignored.\n",
    "        :param end_column:   The column number of the end position.\n",
    "        :return:             A TextRange.\n",
    "        \"\"\"\n",
    "        start = TextPosition(start_line, start_column)\n",
    "        if end_line is None:\n",
    "            end = None\n",
    "        else:\n",
    "            end = TextPosition(end_line, end_column)\n",
    "\n",
    "        return cls(start, end)\n",
    "\n",
    "    @classmethod\n",
    "    def join(cls, a, b):\n",
    "        \"\"\"\n",
    "        Creates a new TextRange that covers the area of two overlapping ones\n",
    "\n",
    "        :param a: TextRange (needs to overlap b)\n",
    "        :param b: TextRange (needs to overlap a)\n",
    "        :return:  A new TextRange covering the union of the Area of a and b\n",
    "        \"\"\"\n",
    "        if not isinstance(a, cls) or not isinstance(b, cls):\n",
    "            raise TypeError(\n",
    "                \"only instances of {} can be joined\".format(cls.__name__))\n",
    "\n",
    "        if not a.overlaps(b):\n",
    "            raise ValueError(\n",
    "                    \"{}s must overlap to be joined\".format(cls.__name__))\n",
    "\n",
    "        return cls(min(a.start, b.start), max(a.end, b.end))\n",
    "\n",
    "    @property\n",
    "    def start(self):\n",
    "        return self._start\n",
    "\n",
    "    @property\n",
    "    def end(self):\n",
    "        return self._end\n",
    "\n",
    "    def overlaps(self, other):\n",
    "        return self.start <= other.end and self.end >= other.start\n",
    "\n",
    "    def expand(self, text_lines):\n",
    "        \"\"\"\n",
    "        Passes a new TextRange that covers the same area of a file as this one\n",
    "        would. All values of None get replaced with absolute values.\n",
    "\n",
    "        values of None will be interpreted as follows:\n",
    "        self.start.line is None:   -> 1\n",
    "        self.start.column is None: -> 1\n",
    "        self.end.line is None:     -> last line of file\n",
    "        self.end.column is None:   -> last column of self.end.line\n",
    "\n",
    "        :param text_lines: File contents of the applicable file\n",
    "        :return:           TextRange with absolute values\n",
    "        \"\"\"\n",
    "        start_line = self.start.line or 1\n",
    "        start_column = self.start.column or 1\n",
    "        end_line = self.end.line or len(text_lines)\n",
    "        end_column = self.end.column or len(text_lines[end_line - 1])\n",
    "\n",
    "        return TextRange.from_values(start_line,\n",
    "                                     start_column,\n",
    "                                     end_line,\n",
    "                                     end_column)\n"
  ],
  "/home/tushar/coala/coalib/results/__init__.py": [],
  "/home/tushar/coala/coalib/results/result_actions/ApplyPatchAction.py": [
    "import shutil\n",
    "from os.path import isfile\n",
    "from os import remove\n",
    "\n",
    "from coalib.results.Diff import ConflictError\n",
    "from coalib.results.result_actions.ResultAction import ResultAction\n",
    "\n",
    "\n",
    "class ApplyPatchAction(ResultAction):\n",
    "\n",
    "    SUCCESS_MESSAGE = \"Patch applied successfully.\"\n",
    "\n",
    "    @staticmethod\n",
    "    def is_applicable(result, original_file_dict, file_diff_dict):\n",
    "        if not result.diffs:\n",
    "            return False\n",
    "\n",
    "        try:\n",
    "            for filename in result.diffs:\n",
    "                if filename in file_diff_dict:\n",
    "                    result.diffs[filename].__add__(\n",
    "                        file_diff_dict[filename])\n",
    "\n",
    "            return True\n",
    "        except ConflictError:\n",
    "            return False\n",
    "\n",
    "    def apply(self,\n",
    "              result,\n",
    "              original_file_dict,\n",
    "              file_diff_dict,\n",
    "              no_orig: bool=False):\n",
    "        \"\"\"\n",
    "        Apply the patch automatically.\n",
    "\n",
    "        :param no_orig: Whether or not to create .orig backup files\n",
    "        \"\"\"\n",
    "        for filename in result.diffs:\n",
    "            pre_patch_filename = filename\n",
    "            if filename in file_diff_dict:\n",
    "                diff = file_diff_dict[filename]\n",
    "                pre_patch_filename = (diff.rename\n",
    "                                      if diff.rename is not False\n",
    "                                      else filename)\n",
    "                file_diff_dict[filename] += result.diffs[filename]\n",
    "            else:\n",
    "                file_diff_dict[filename] = result.diffs[filename]\n",
    "\n",
    "            # Backup original file, override old backup if needed\n",
    "            if (not no_orig and\n",
    "                    isfile(pre_patch_filename) and\n",
    "                    not isfile(pre_patch_filename + \".orig\")):\n",
    "                shutil.copy2(pre_patch_filename, pre_patch_filename + \".orig\")\n",
    "\n",
    "            diff = file_diff_dict[filename]\n",
    "            if diff.delete or diff.rename:\n",
    "                if isfile(pre_patch_filename):\n",
    "                    remove(pre_patch_filename)\n",
    "            if not diff.delete:\n",
    "                new_filename = (diff.rename\n",
    "                                if diff.rename is not False\n",
    "                                else filename)\n",
    "                with open(new_filename, mode='w', encoding='utf-8') as file:\n",
    "                    file.writelines(diff.modified)\n",
    "\n",
    "        return file_diff_dict\n"
  ],
  "/home/tushar/coala/coalib/results/result_actions/OpenEditorAction.py": [
    "import subprocess\n",
    "\n",
    "from coalib.results.Diff import Diff\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.result_actions.ResultAction import ResultAction\n",
    "\n",
    "EDITOR_ARGS = {\n",
    "    \"subl\": \"--wait\",\n",
    "    \"gedit\": \"-s\",\n",
    "    \"atom\": \"--wait\"\n",
    "}\n",
    "\n",
    "\n",
    "GUI_EDITORS = [\"kate\", \"gedit\", \"subl\", \"atom\"]\n",
    "\n",
    "\n",
    "class OpenEditorAction(ResultAction):\n",
    "\n",
    "    SUCCESS_MESSAGE = \"Changes saved successfully.\"\n",
    "\n",
    "    @staticmethod\n",
    "    def is_applicable(result, original_file_dict, file_diff_dict):\n",
    "        return isinstance(result, Result) and len(result.affected_code) > 0\n",
    "\n",
    "    def apply(self, result, original_file_dict, file_diff_dict, editor: str):\n",
    "        '''\n",
    "        Open the affected file(s) in an editor.\n",
    "\n",
    "        :param editor: The editor to open the file with.\n",
    "        '''\n",
    "        # Use set to remove duplicates\n",
    "        filenames = set(src.file for src in result.affected_code)\n",
    "\n",
    "        editor_args = [editor] + list(filenames)\n",
    "        arg = EDITOR_ARGS.get(editor.strip(), None)\n",
    "        if arg:\n",
    "            editor_args.append(arg)\n",
    "\n",
    "        # Dear user, you wanted an editor, so you get it. But do you really\n",
    "        # think you can do better than we?\n",
    "        if editor in GUI_EDITORS:\n",
    "            subprocess.call(editor_args, stdout=subprocess.PIPE)\n",
    "        else:\n",
    "            subprocess.call(editor_args)\n",
    "\n",
    "        for filename in filenames:\n",
    "            with open(filename, encoding='utf-8') as file:\n",
    "                file_diff_dict[filename] = Diff.from_string_arrays(\n",
    "                    original_file_dict[filename], file.readlines())\n",
    "\n",
    "        return file_diff_dict\n"
  ],
  "/home/tushar/coala/coalib/results/result_actions/PrintDebugMessageAction.py": [
    "from coalib.results.Result import Result\n",
    "from coalib.results.result_actions.ResultAction import ResultAction\n",
    "\n",
    "\n",
    "class PrintDebugMessageAction(ResultAction):\n",
    "\n",
    "    @staticmethod\n",
    "    def is_applicable(result, original_file_dict, file_diff_dict):\n",
    "        return isinstance(result, Result) and result.debug_msg != \"\"\n",
    "\n",
    "    def apply(self, result, original_file_dict, file_diff_dict):\n",
    "        \"\"\"\n",
    "        Print the debug message of the result.\n",
    "        \"\"\"\n",
    "        print(result.debug_msg)\n",
    "\n",
    "        return file_diff_dict\n"
  ],
  "/home/tushar/coala/coalib/results/result_actions/PrintMoreInfoAction.py": [
    "from coalib.results.Result import Result\n",
    "from coalib.results.result_actions.ResultAction import ResultAction\n",
    "\n",
    "\n",
    "class PrintMoreInfoAction(ResultAction):\n",
    "\n",
    "    @staticmethod\n",
    "    def is_applicable(result, original_file_dict, file_diff_dict):\n",
    "        return isinstance(result, Result) and result.additional_info != \"\"\n",
    "\n",
    "    def apply(self, result, original_file_dict, file_diff_dict):\n",
    "        \"\"\"\n",
    "        Print additional information given by the result.\n",
    "        \"\"\"\n",
    "        print(result.additional_info)\n",
    "\n",
    "        return file_diff_dict\n"
  ],
  "/home/tushar/coala/coalib/results/result_actions/ResultAction.py": [
    "\"\"\"\n",
    "A ResultAction is an action that is applicable to at least some results. This\n",
    "file serves the base class for all result actions, thus providing a unified\n",
    "interface for all actions.\n",
    "\"\"\"\n",
    "from coala_decorators.decorators import enforce_signature\n",
    "from coalib.settings.FunctionMetadata import FunctionMetadata\n",
    "from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "class ResultAction:\n",
    "\n",
    "    SUCCESS_MESSAGE = \"The action was executed successfully.\"\n",
    "\n",
    "    @staticmethod\n",
    "    def is_applicable(result, original_file_dict, file_diff_dict):\n",
    "        \"\"\"\n",
    "        Checks whether the Action is valid for the result type.\n",
    "\n",
    "        Returns ``True`` by default.\n",
    "\n",
    "        :param result:             The result from the coala run to check if an\n",
    "                                   Action is applicable.\n",
    "        :param original_file_dict: A dictionary containing the files in the\n",
    "                                   state where the result was generated.\n",
    "        :param file_diff_dict:     A dictionary containing a diff for every\n",
    "                                   file from the state in the\n",
    "                                   original_file_dict to the current state.\n",
    "                                   This dict will be altered so you do not\n",
    "                                   need to use the return value.\n",
    "        \"\"\"\n",
    "        return True\n",
    "\n",
    "    def apply(self, result, original_file_dict, file_diff_dict, **kwargs):\n",
    "        \"\"\"\n",
    "        This action has no description although it should. Probably something\n",
    "        went wrong.\n",
    "        \"\"\"\n",
    "        raise NotImplementedError\n",
    "\n",
    "    @enforce_signature\n",
    "    def apply_from_section(self,\n",
    "                           result,\n",
    "                           original_file_dict: dict,\n",
    "                           file_diff_dict: dict,\n",
    "                           section: Section):\n",
    "        \"\"\"\n",
    "        Applies this action to the given results with all additional options\n",
    "        given as a section. The file dictionaries\n",
    "        are needed for differential results.\n",
    "\n",
    "        :param result:             The result to apply.\n",
    "        :param original_file_dict: A dictionary containing the files in the\n",
    "                                   state where the result was generated.\n",
    "        :param file_diff_dict:     A dictionary containing a diff for every\n",
    "                                   file from the state in the\n",
    "                                   original_file_dict to the current state.\n",
    "                                   This dict will be altered so you do not\n",
    "                                   need to use the return value.\n",
    "        :param section:            The section where to retrieve the additional\n",
    "                                   information.\n",
    "        :return                    The modified file_diff_dict.\n",
    "        \"\"\"\n",
    "        params = self.get_metadata().create_params_from_section(section)\n",
    "        return self.apply(result, original_file_dict, file_diff_dict, **params)\n",
    "\n",
    "    @classmethod\n",
    "    def get_metadata(cls):\n",
    "        \"\"\"\n",
    "        Retrieves metadata for the apply function. The description may be used\n",
    "        to advertise this action to the user. The parameters and their help\n",
    "        texts are additional information that are needed from the user. You can\n",
    "        create a section out of the inputs from the user and use\n",
    "        apply_from_section to apply\n",
    "\n",
    "        :return A FunctionMetadata object.\n",
    "        \"\"\"\n",
    "        data = FunctionMetadata.from_function(\n",
    "            cls.apply,\n",
    "            omit={\"self\", \"result\", \"original_file_dict\", \"file_diff_dict\"})\n",
    "        data.name = cls.__name__\n",
    "\n",
    "        return data\n"
  ],
  "/home/tushar/coala/coalib/results/result_actions/ShowPatchAction.py": [
    "import difflib\n",
    "\n",
    "from pyprint.ConsolePrinter import ConsolePrinter\n",
    "\n",
    "from coalib.results.Diff import ConflictError\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.result_actions.ResultAction import ResultAction\n",
    "\n",
    "\n",
    "def format_line(line, real_nr=\"\", sign=\"|\", mod_nr=\"\", symbol=\"\", ):\n",
    "    return \"|{:>4}{}{:>4}|{:1}{}\".format(real_nr,\n",
    "                                         sign,\n",
    "                                         mod_nr,\n",
    "                                         symbol,\n",
    "                                         line.rstrip(\"\\n\"))\n",
    "\n",
    "\n",
    "def print_beautified_diff(difflines, printer):\n",
    "    current_line_added = None\n",
    "    current_line_subtracted = None\n",
    "    for line in difflines:\n",
    "        if line.startswith(\"@@\"):\n",
    "            values = line[line.find(\"-\"):line.rfind(\" \")]\n",
    "            subtracted, added = tuple(values.split(\" \"))\n",
    "            current_line_added = int(added.split(\",\")[0][1:])\n",
    "            current_line_subtracted = int(subtracted.split(\",\")[0][1:])\n",
    "        elif line.startswith(\"---\"):\n",
    "            printer.print(format_line(line[4:], real_nr=\"----\"), color=\"red\")\n",
    "        elif line.startswith(\"+++\"):\n",
    "            printer.print(format_line(line[4:], mod_nr=\"++++\"),\n",
    "                          color=\"green\")\n",
    "        elif line.startswith(\"+\"):\n",
    "            printer.print(format_line(line[1:],\n",
    "                                      mod_nr=current_line_added,\n",
    "                                      symbol=\"+\"),\n",
    "                          color=\"green\")\n",
    "            current_line_added += 1\n",
    "        elif line.startswith(\"-\"):\n",
    "            printer.print(format_line(line[1:],\n",
    "                                      real_nr=current_line_subtracted,\n",
    "                                      symbol=\"-\"),\n",
    "                          color=\"red\")\n",
    "            current_line_subtracted += 1\n",
    "        else:\n",
    "            printer.print(format_line(line[1:],\n",
    "                                      real_nr=current_line_subtracted,\n",
    "                                      mod_nr=current_line_added,\n",
    "                                      symbol=\" \"))\n",
    "            current_line_subtracted += 1\n",
    "            current_line_added += 1\n",
    "\n",
    "\n",
    "class ShowPatchAction(ResultAction):\n",
    "\n",
    "    SUCCESS_MESSAGE = \"Displayed patch successfully.\"\n",
    "\n",
    "    @staticmethod\n",
    "    def is_applicable(result, original_file_dict, file_diff_dict):\n",
    "        if not isinstance(result, Result) or not result.diffs:\n",
    "            return False\n",
    "\n",
    "        try:\n",
    "            for filename in result.diffs:\n",
    "                if filename in file_diff_dict:\n",
    "                    result.diffs[filename].__add__(file_diff_dict[filename])\n",
    "            return True\n",
    "        except ConflictError:\n",
    "            return False\n",
    "\n",
    "    def apply(self,\n",
    "              result,\n",
    "              original_file_dict,\n",
    "              file_diff_dict,\n",
    "              colored: bool=True):\n",
    "        '''\n",
    "        Print a diff of the patch that would be applied.\n",
    "\n",
    "        :param colored: Wether or not to use colored output.\n",
    "        '''\n",
    "        printer = ConsolePrinter(colored)\n",
    "\n",
    "        for filename, this_diff in sorted(result.diffs.items()):\n",
    "            original_file = original_file_dict[filename]\n",
    "            try:\n",
    "                current_file = file_diff_dict[filename].modified\n",
    "                new_file = (file_diff_dict[filename] + this_diff).modified\n",
    "            except KeyError:\n",
    "                current_file = original_file\n",
    "                new_file = this_diff.modified\n",
    "\n",
    "            print_beautified_diff(difflib.unified_diff(current_file,\n",
    "                                                       new_file,\n",
    "                                                       fromfile=filename,\n",
    "                                                       tofile=filename),\n",
    "                                  printer)\n",
    "\n",
    "        return file_diff_dict\n"
  ],
  "/home/tushar/coala/coalib/results/result_actions/__init__.py": [
    "\"\"\"\n",
    "The result_actions package holds objects deriving from ResultAction.\n",
    "A ResultAction represents an action that an be applied to a result.\n",
    "\"\"\"\n"
  ],
  "/home/tushar/coala/coalib/settings/ConfigurationGathering.py": [
    "import os\n",
    "import re\n",
    "import sys\n",
    "\n",
    "from coalib.misc import Constants\n",
    "from coalib.output.ConfWriter import ConfWriter\n",
    "from coalib.output.printers.LOG_LEVEL import LOG_LEVEL\n",
    "from coalib.parsing.CliParsing import parse_cli, check_conflicts\n",
    "from coalib.parsing.ConfParser import ConfParser\n",
    "from coalib.settings.Section import Section\n",
    "from coalib.settings.SectionFilling import fill_settings\n",
    "from coalib.settings.Setting import Setting, path\n",
    "\n",
    "\n",
    "def merge_section_dicts(lower, higher):\n",
    "    \"\"\"\n",
    "    Merges the section dictionaries. The values of higher will take\n",
    "    precedence over the ones of lower. Lower will hold the modified dict in\n",
    "    the end.\n",
    "\n",
    "    :param lower:  A section.\n",
    "    :param higher: A section which values will take precedence over the ones\n",
    "                   from the other.\n",
    "    :return:       The merged dict.\n",
    "    \"\"\"\n",
    "    for name in higher:\n",
    "        if name in lower:\n",
    "            lower[name].update(higher[name], ignore_defaults=True)\n",
    "        else:\n",
    "            # no deep copy needed\n",
    "            lower[name] = higher[name]\n",
    "\n",
    "    return lower\n",
    "\n",
    "\n",
    "def load_config_file(filename, log_printer, silent=False):\n",
    "    \"\"\"\n",
    "    Loads sections from a config file. Prints an appropriate warning if\n",
    "    it doesn't exist and returns a section dict containing an empty\n",
    "    default section in that case.\n",
    "\n",
    "    It assumes that the cli_sections are available.\n",
    "\n",
    "    :param filename:    The file to load settings from.\n",
    "    :param log_printer: The log printer to log the warning/error to (in case).\n",
    "    :param silent:      Whether or not to warn the user/exit if the file\n",
    "                        doesn't exist.\n",
    "    :raises SystemExit: Exits when given filename is invalid and is not the\n",
    "                        default coafile. Only raised when ``silent`` is\n",
    "                        ``False``.\n",
    "    \"\"\"\n",
    "    filename = os.path.abspath(filename)\n",
    "\n",
    "    try:\n",
    "        return ConfParser().parse(filename)\n",
    "    except FileNotFoundError:\n",
    "        if not silent:\n",
    "            if os.path.basename(filename) == Constants.default_coafile:\n",
    "                log_printer.warn(\"The default coafile \" +\n",
    "                                 repr(Constants.default_coafile) + \" was not \"\n",
    "                                 \"found. Ignoring it.\")\n",
    "            else:\n",
    "                log_printer.err(\"The requested coafile \" + repr(filename) +\n",
    "                                \" does not exist.\")\n",
    "                sys.exit(2)\n",
    "\n",
    "        return {\"default\": Section(\"default\")}\n",
    "\n",
    "\n",
    "def save_sections(sections):\n",
    "    \"\"\"\n",
    "    Saves the given sections if they are to be saved.\n",
    "\n",
    "    :param sections: A section dict.\n",
    "    \"\"\"\n",
    "    default_section = sections[\"default\"]\n",
    "    try:\n",
    "        if bool(default_section.get(\"save\", \"false\")):\n",
    "            conf_writer = ConfWriter(\n",
    "                str(default_section.get(\"config\", Constants.default_coafile)))\n",
    "        else:\n",
    "            return\n",
    "    except ValueError:\n",
    "        conf_writer = ConfWriter(str(default_section.get(\"save\", \".coafile\")))\n",
    "\n",
    "    conf_writer.write_sections(sections)\n",
    "    conf_writer.close()\n",
    "\n",
    "\n",
    "def warn_nonexistent_targets(targets, sections, log_printer):\n",
    "    \"\"\"\n",
    "    Prints out a warning on the given log printer for all targets that are\n",
    "    not existent within the given sections.\n",
    "\n",
    "    :param targets:     The targets to check.\n",
    "    :param sections:    The sections to search. (Dict.)\n",
    "    :param log_printer: The log printer to warn to.\n",
    "    \"\"\"\n",
    "    for target in targets:\n",
    "        if target not in sections:\n",
    "            log_printer.warn(\n",
    "                \"The requested section '{section}' is not existent. \"\n",
    "                \"Thus it cannot be executed.\".format(section=target))\n",
    "\n",
    "\n",
    "def load_configuration(arg_list, log_printer, arg_parser=None):\n",
    "    \"\"\"\n",
    "    Parses the CLI args and loads the config file accordingly, taking\n",
    "    default_coafile and the users .coarc into account.\n",
    "\n",
    "    :param arg_list:    The list of command line arguments.\n",
    "    :param log_printer: The LogPrinter object for logging.\n",
    "    :return:            A tuple holding (log_printer: LogPrinter, sections:\n",
    "                        dict(str, Section), targets: list(str)). (Types\n",
    "                        indicated after colon.)\n",
    "    \"\"\"\n",
    "    cli_sections = parse_cli(arg_list=arg_list, arg_parser=arg_parser)\n",
    "    check_conflicts(cli_sections)\n",
    "\n",
    "    if (\n",
    "            bool(cli_sections[\"default\"].get(\"find_config\", \"False\")) and\n",
    "            str(cli_sections[\"default\"].get(\"config\")) == \"\"):\n",
    "        cli_sections[\"default\"].add_or_create_setting(\n",
    "            Setting(\"config\", re.escape(find_user_config(os.getcwd()))))\n",
    "\n",
    "    targets = []\n",
    "    # We don't want to store targets argument back to file, thus remove it\n",
    "    for item in list(cli_sections[\"default\"].contents.pop(\"targets\", \"\")):\n",
    "        targets.append(item.lower())\n",
    "\n",
    "    if bool(cli_sections[\"default\"].get(\"no_config\", \"False\")):\n",
    "        sections = cli_sections\n",
    "    else:\n",
    "        default_sections = load_config_file(Constants.system_coafile,\n",
    "                                            log_printer)\n",
    "        user_sections = load_config_file(\n",
    "            Constants.user_coafile,\n",
    "            log_printer,\n",
    "            silent=True)\n",
    "\n",
    "        default_config = str(\n",
    "            default_sections[\"default\"].get(\"config\", \".coafile\"))\n",
    "        user_config = str(user_sections[\"default\"].get(\n",
    "            \"config\", default_config))\n",
    "        config = os.path.abspath(\n",
    "            str(cli_sections[\"default\"].get(\"config\", user_config)))\n",
    "\n",
    "        try:\n",
    "            save = bool(cli_sections[\"default\"].get(\"save\", \"False\"))\n",
    "        except ValueError:\n",
    "            # A file is deposited for the save parameter, means we want to save\n",
    "            # but to a specific file.\n",
    "            save = True\n",
    "\n",
    "        coafile_sections = load_config_file(config, log_printer, silent=save)\n",
    "\n",
    "        sections = merge_section_dicts(default_sections, user_sections)\n",
    "\n",
    "        sections = merge_section_dicts(sections, coafile_sections)\n",
    "\n",
    "        sections = merge_section_dicts(sections, cli_sections)\n",
    "\n",
    "    for section in sections:\n",
    "        if section != \"default\":\n",
    "            sections[section].defaults = sections[\"default\"]\n",
    "\n",
    "    str_log_level = str(sections[\"default\"].get(\"log_level\", \"\")).upper()\n",
    "    log_printer.log_level = LOG_LEVEL.str_dict.get(str_log_level,\n",
    "                                                   LOG_LEVEL.INFO)\n",
    "\n",
    "    return sections, targets\n",
    "\n",
    "\n",
    "def find_user_config(file_path, max_trials=10):\n",
    "    \"\"\"\n",
    "    Uses the filepath to find the most suitable user config file for the file\n",
    "    by going down one directory at a time and finding config files there.\n",
    "\n",
    "    :param file_path:  The path of the file whose user config needs to be found\n",
    "    :param max_trials: The maximum number of directories to go down to.\n",
    "    :return:           The config file's path, empty string if none was found\n",
    "    \"\"\"\n",
    "    file_path = os.path.normpath(os.path.abspath(os.path.expanduser(\n",
    "        file_path)))\n",
    "    old_dir = None\n",
    "    base_dir = (file_path if os.path.isdir(file_path)\n",
    "                else os.path.dirname(file_path))\n",
    "    home_dir = os.path.expanduser(\"~\")\n",
    "\n",
    "    while base_dir != old_dir and old_dir != home_dir and max_trials != 0:\n",
    "        config_file = os.path.join(base_dir, \".coafile\")\n",
    "        if os.path.isfile(config_file):\n",
    "            return config_file\n",
    "\n",
    "        old_dir = base_dir\n",
    "        base_dir = os.path.dirname(old_dir)\n",
    "        max_trials = max_trials - 1\n",
    "\n",
    "    return \"\"\n",
    "\n",
    "\n",
    "def get_config_directory(section):\n",
    "    \"\"\"\n",
    "    Retrieves the configuration directory for the given section.\n",
    "\n",
    "    Given an empty section:\n",
    "\n",
    "    >>> section = Section(\"name\")\n",
    "\n",
    "    The configuration directory is not defined and will therefore fallback to\n",
    "    the current directory:\n",
    "\n",
    "    >>> get_config_directory(section) == os.path.abspath(\".\")\n",
    "    True\n",
    "\n",
    "    If the ``files`` setting is given with an originating coafile, the directory\n",
    "    of the coafile will be assumed the configuration directory:\n",
    "\n",
    "    >>> section.append(Setting(\"files\", \"**\", origin=\"/tmp/.coafile\"))\n",
    "    >>> get_config_directory(section) == os.path.abspath('/tmp/')\n",
    "    True\n",
    "\n",
    "    However if its origin is already a directory this will be preserved:\n",
    "\n",
    "    >>> section['files'].origin = os.path.abspath('/tmp/dir/')\n",
    "    >>> os.makedirs(section['files'].origin, exist_ok=True)\n",
    "    >>> get_config_directory(section) == section['files'].origin\n",
    "    True\n",
    "\n",
    "    The user can manually set a project directory with the ``project_dir``\n",
    "    setting:\n",
    "\n",
    "    >>> section.append(Setting('project_dir', os.path.abspath('/tmp'), '/'))\n",
    "    >>> get_config_directory(section) == os.path.abspath('/tmp')\n",
    "    True\n",
    "\n",
    "    If no section is given, the current directory is returned:\n",
    "\n",
    "    >>> get_config_directory(None) == os.path.abspath(\".\")\n",
    "    True\n",
    "\n",
    "    To summarize, the config directory will be chosen by the following\n",
    "    priorities if possible in that order:\n",
    "\n",
    "    - the ``project_dir`` setting\n",
    "    - the origin of the ``files`` setting, if it's a directory\n",
    "    - the directory of the origin of the ``files`` setting\n",
    "    - the current directory\n",
    "\n",
    "    :param section: The section to inspect.\n",
    "    :return: The directory where the project is lying.\n",
    "    \"\"\"\n",
    "    if section is None:\n",
    "        return os.getcwd()\n",
    "\n",
    "    if 'project_dir' in section:\n",
    "        return path(section.get('project_dir'))\n",
    "\n",
    "    config = os.path.abspath(section.get('files', '').origin)\n",
    "    return config if os.path.isdir(config) else os.path.dirname(config)\n",
    "\n",
    "\n",
    "def gather_configuration(acquire_settings,\n",
    "                         log_printer,\n",
    "                         autoapply=None,\n",
    "                         arg_list=None,\n",
    "                         arg_parser=None):\n",
    "    \"\"\"\n",
    "    Loads all configuration files, retrieves bears and all needed\n",
    "    settings, saves back if needed and warns about non-existent targets.\n",
    "\n",
    "    This function:\n",
    "\n",
    "    -  Reads and merges all settings in sections from\n",
    "\n",
    "       -  Default config\n",
    "       -  User config\n",
    "       -  Configuration file\n",
    "       -  CLI\n",
    "\n",
    "    -  Collects all the bears\n",
    "    -  Fills up all needed settings\n",
    "    -  Writes back the new sections to the configuration file if needed\n",
    "    -  Gives all information back to caller\n",
    "\n",
    "    :param acquire_settings: The method to use for requesting settings. It will\n",
    "                             get a parameter which is a dictionary with the\n",
    "                             settings name as key and a list containing a\n",
    "                             description in [0] and the names of the bears\n",
    "                             who need this setting in all following indexes.\n",
    "    :param log_printer:      The log printer to use for logging. The log level\n",
    "                             will be adjusted to the one given by the section.\n",
    "    :param autoapply:        Set whether to autoapply patches. This is\n",
    "                             overridable via any configuration file/CLI.\n",
    "    :param arg_list:         CLI args to use\n",
    "    :return:                 A tuple with the following contents:\n",
    "\n",
    "                             -  A dictionary with the sections\n",
    "                             -  Dictionary of list of local bears for each\n",
    "                                section\n",
    "                             -  Dictionary of list of global bears for each\n",
    "                                section\n",
    "                             -  The targets list\n",
    "    \"\"\"\n",
    "    # Note: arg_list can also be []. Hence we cannot use\n",
    "    # `arg_list = arg_list or default_list`\n",
    "    arg_list = sys.argv[1:] if arg_list is None else arg_list\n",
    "    sections, targets = load_configuration(arg_list, log_printer, arg_parser)\n",
    "    local_bears, global_bears = fill_settings(sections,\n",
    "                                              acquire_settings,\n",
    "                                              log_printer)\n",
    "    save_sections(sections)\n",
    "    warn_nonexistent_targets(targets, sections, log_printer)\n",
    "\n",
    "    if autoapply is not None:\n",
    "        if not autoapply and 'autoapply' not in sections['default']:\n",
    "            sections['default']['autoapply'] = \"False\"\n",
    "\n",
    "    return (sections,\n",
    "            local_bears,\n",
    "            global_bears,\n",
    "            targets)\n"
  ],
  "/home/tushar/coala/coalib/settings/DocstringMetadata.py": [
    "import inspect\n",
    "from collections import OrderedDict\n",
    "\n",
    "from coalib.misc.Enum import enum\n",
    "\n",
    "\n",
    "class DocstringMetadata:\n",
    "    _ParseMode = enum(\"DESCRIPTION\", \"PARAM\", \"RETVAL\")\n",
    "\n",
    "    def __init__(self, desc, param_dict, retval_desc):\n",
    "        \"\"\"\n",
    "        Represents a docstring of a python class or function.\n",
    "\n",
    "        :param desc:        A description as string.\n",
    "        :param param_dict:  A dictionary containing parameter names as key and\n",
    "                            their description as value. To preserve the order,\n",
    "                            use OrderedDict.\n",
    "        :param retval_desc: A string describing the return value.\n",
    "        \"\"\"\n",
    "        self.desc = desc\n",
    "        self.param_dict = param_dict\n",
    "        self.retval_desc = retval_desc\n",
    "\n",
    "    @classmethod\n",
    "    def from_docstring(cls, docstring):\n",
    "        \"\"\"\n",
    "        Parses a python docstring. Usable attributes are:\n",
    "        :param\n",
    "        @param\n",
    "        :return\n",
    "        @return\n",
    "        \"\"\"\n",
    "        lines = inspect.cleandoc(docstring).split(\"\\n\")\n",
    "\n",
    "        parse_mode = cls._ParseMode.DESCRIPTION\n",
    "        cur_param = \"\"\n",
    "\n",
    "        desc = \"\"\n",
    "        param_dict = OrderedDict()\n",
    "        retval_desc = \"\"\n",
    "        for line in lines:\n",
    "            line = line.strip()\n",
    "\n",
    "            if line.startswith(\":param \") or line.startswith(\"@param \"):\n",
    "                parse_mode = cls._ParseMode.PARAM\n",
    "                splitted = line[7:].split(\":\", 1)\n",
    "                cur_param = splitted[0]\n",
    "                param_dict[cur_param] = splitted[1].strip()\n",
    "\n",
    "                continue\n",
    "\n",
    "            if line.startswith(\":return: \") or line.startswith(\"@return: \"):\n",
    "                parse_mode = cls._ParseMode.RETVAL\n",
    "                retval_desc = line[9:].strip()\n",
    "\n",
    "                continue\n",
    "\n",
    "            def concat_doc_parts(old: str, new: str):\n",
    "                if new != '' and not old.endswith('\\n'):\n",
    "                    return old + ' ' + new\n",
    "\n",
    "                return old + (new if new != '' else '\\n')\n",
    "\n",
    "            if parse_mode == cls._ParseMode.RETVAL:\n",
    "                retval_desc = concat_doc_parts(retval_desc, line)\n",
    "            elif parse_mode == cls._ParseMode.PARAM:\n",
    "                param_dict[cur_param] = concat_doc_parts(param_dict[cur_param],\n",
    "                                                         line)\n",
    "            else:\n",
    "                desc = concat_doc_parts(desc, line)\n",
    "\n",
    "        return (cls(desc=desc.strip(),\n",
    "                    param_dict=param_dict,\n",
    "                    retval_desc=retval_desc.strip()))\n",
    "\n",
    "    def __str__(self):\n",
    "        return str(self.desc)\n"
  ],
  "/home/tushar/coala/coalib/settings/FunctionMetadata.py": [
    "from collections import OrderedDict\n",
    "from copy import copy\n",
    "from inspect import getfullargspec, ismethod\n",
    "\n",
    "from coala_decorators.decorators import enforce_signature\n",
    "from coalib.settings.DocstringMetadata import DocstringMetadata\n",
    "\n",
    "\n",
    "class FunctionMetadata:\n",
    "    str_nodesc = \"No description given.\"\n",
    "    str_optional = \"Optional, defaults to '{}'.\"\n",
    "\n",
    "    @enforce_signature\n",
    "    def __init__(self,\n",
    "                 name: str,\n",
    "                 desc: str=\"\",\n",
    "                 retval_desc: str=\"\",\n",
    "                 non_optional_params: (dict, None)=None,\n",
    "                 optional_params: (dict, None)=None,\n",
    "                 omit: (set, tuple, list, frozenset)=frozenset()):\n",
    "        \"\"\"\n",
    "        Creates the FunctionMetadata object.\n",
    "\n",
    "        :param name:                The name of the function.\n",
    "        :param desc:                The description of the function.\n",
    "        :param retval_desc:         The retval description of the function.\n",
    "        :param non_optional_params: A dict containing the name of non optional\n",
    "                                    parameters as the key and a tuple of a\n",
    "                                    description and the python annotation. To\n",
    "                                    preserve the order, use OrderedDict.\n",
    "        :param optional_params:     A dict containing the name of optional\n",
    "                                    parameters as the key and a tuple\n",
    "                                    of a description, the python annotation and\n",
    "                                    the default value. To preserve the order,\n",
    "                                    use OrderedDict.\n",
    "        :param omit:                A set of parameters to omit.\n",
    "        \"\"\"\n",
    "        if non_optional_params is None:\n",
    "            non_optional_params = OrderedDict()\n",
    "        if optional_params is None:\n",
    "            optional_params = OrderedDict()\n",
    "\n",
    "        self.name = name\n",
    "        self._desc = desc\n",
    "        self.retval_desc = retval_desc\n",
    "        self._non_optional_params = non_optional_params\n",
    "        self._optional_params = optional_params\n",
    "        self.omit = set(omit)\n",
    "\n",
    "    @property\n",
    "    def desc(self):\n",
    "        \"\"\"\n",
    "        Returns description of the function.\n",
    "        \"\"\"\n",
    "        return self._desc\n",
    "\n",
    "    @desc.setter\n",
    "    @enforce_signature\n",
    "    def desc(self, new_desc: str):\n",
    "        \"\"\"\n",
    "        Set's the description to the new_desc.\n",
    "        \"\"\"\n",
    "        self._desc = new_desc\n",
    "\n",
    "    def _filter_out_omitted(self, params):\n",
    "        \"\"\"\n",
    "        Filters out parameters that are to omit. This is a helper method for\n",
    "        the param related properties.\n",
    "\n",
    "        :param params: The parameter dictionary to filter.\n",
    "        :return:       The filtered dictionary.\n",
    "        \"\"\"\n",
    "        return OrderedDict(filter(lambda p: p[0] not in self.omit,\n",
    "                                  tuple(params.items())))\n",
    "\n",
    "    @property\n",
    "    def non_optional_params(self):\n",
    "        \"\"\"\n",
    "        Retrieves a dict containing the name of non optional parameters as the\n",
    "        key and a tuple of a description and the python annotation. Values that\n",
    "        are present in self.omit will be omitted.\n",
    "        \"\"\"\n",
    "        return self._filter_out_omitted(self._non_optional_params)\n",
    "\n",
    "    @property\n",
    "    def optional_params(self):\n",
    "        \"\"\"\n",
    "        Retrieves a dict containing the name of optional parameters as the key\n",
    "        and a tuple of a description, the python annotation and the default\n",
    "        value. Values that are present in self.omit will be omitted.\n",
    "        \"\"\"\n",
    "        return self._filter_out_omitted(self._optional_params)\n",
    "\n",
    "    def create_params_from_section(self, section):\n",
    "        \"\"\"\n",
    "        Create a params dictionary for this function that holds all values the\n",
    "        function needs plus optional ones that are available.\n",
    "\n",
    "        :param section:    The section to retrieve the values from.\n",
    "        :return:           The params dictionary.\n",
    "        \"\"\"\n",
    "        params = {}\n",
    "\n",
    "        for param in self.non_optional_params:\n",
    "            _, annotation = self.non_optional_params[param]\n",
    "            params[param] = self._get_param(param, section, annotation)\n",
    "\n",
    "        for param in self.optional_params:\n",
    "            if param in section:\n",
    "                _, annotation, _ = self.optional_params[param]\n",
    "                params[param] = self._get_param(param, section, annotation)\n",
    "\n",
    "        return params\n",
    "\n",
    "    @staticmethod\n",
    "    def _get_param(param, section, annotation):\n",
    "        if annotation is None:\n",
    "            annotation = lambda x: x\n",
    "\n",
    "        try:\n",
    "            return annotation(section[param])\n",
    "        except (TypeError, ValueError):\n",
    "            raise ValueError(\"Unable to convert parameter {!r} into type \"\n",
    "                             \"{}.\".format(param, annotation))\n",
    "\n",
    "    @classmethod\n",
    "    def from_function(cls, func, omit=frozenset()):\n",
    "        \"\"\"\n",
    "        Creates a FunctionMetadata object from a function. Please note that any\n",
    "        variable argument lists are not supported. If you do not want the\n",
    "        first (usual named 'self') argument to appear please pass the method of\n",
    "        an actual INSTANCE of a class; passing the method of the class isn't\n",
    "        enough. Alternatively you can add \"self\" to the omit set.\n",
    "\n",
    "        :param func: The function. If __metadata__ of the unbound function is\n",
    "                     present it will be copied and used, otherwise it will be\n",
    "                     generated.\n",
    "        :param omit: A set of parameter names that are to be ignored.\n",
    "        :return:     The FunctionMetadata object corresponding to the given\n",
    "                     function.\n",
    "        \"\"\"\n",
    "        if hasattr(func, \"__metadata__\"):\n",
    "            metadata = copy(func.__metadata__)\n",
    "            metadata.omit = omit\n",
    "            return metadata\n",
    "\n",
    "        doc = func.__doc__ or \"\"\n",
    "        doc_comment = DocstringMetadata.from_docstring(doc)\n",
    "\n",
    "        non_optional_params = OrderedDict()\n",
    "        optional_params = OrderedDict()\n",
    "\n",
    "        argspec = getfullargspec(func)\n",
    "        args = argspec.args or ()\n",
    "        defaults = argspec.defaults or ()\n",
    "        num_non_defaults = len(args) - len(defaults)\n",
    "        for i, arg in enumerate(args):\n",
    "            # Implicit self argument or omitted explicitly\n",
    "            if i < 1 and ismethod(func):\n",
    "                continue\n",
    "\n",
    "            if i < num_non_defaults:\n",
    "                non_optional_params[arg] = (\n",
    "                    doc_comment.param_dict.get(arg, cls.str_nodesc),\n",
    "                    argspec.annotations.get(arg, None))\n",
    "            else:\n",
    "                optional_params[arg] = (\n",
    "                    doc_comment.param_dict.get(arg, cls.str_nodesc) + \" (\" +\n",
    "                    cls.str_optional.format(\n",
    "                        defaults[i-num_non_defaults]) + \")\",\n",
    "                    argspec.annotations.get(arg, None),\n",
    "                    defaults[i-num_non_defaults])\n",
    "\n",
    "        return cls(name=func.__name__,\n",
    "                   desc=doc_comment.desc,\n",
    "                   retval_desc=doc_comment.retval_desc,\n",
    "                   non_optional_params=non_optional_params,\n",
    "                   optional_params=optional_params,\n",
    "                   omit=omit)\n",
    "\n",
    "    def filter_parameters(self, dct):\n",
    "        \"\"\"\n",
    "        Filters the given dict for keys that are declared as parameters inside\n",
    "        this metadata (either optional or non-optional).\n",
    "\n",
    "        You can use this function to safely pass parameters from a given\n",
    "        dictionary:\n",
    "\n",
    "        >>> def multiply(a, b=2, c=0):\n",
    "        ...     return a * b + c\n",
    "        >>> metadata = FunctionMetadata.from_function(multiply)\n",
    "        >>> args = metadata.filter_parameters({'a': 10, 'b': 20, 'd': 30})\n",
    "\n",
    "        You can safely pass the arguments to the function now:\n",
    "\n",
    "        >>> multiply(**args)  # 10 * 20\n",
    "        200\n",
    "\n",
    "        :param dct:\n",
    "            The dict to filter.\n",
    "        :return:\n",
    "            A new dict containing the filtered items.\n",
    "        \"\"\"\n",
    "        return {key: dct[key]\n",
    "                for key in (self.non_optional_params.keys() |\n",
    "                            self.optional_params.keys())\n",
    "                if key in dct}\n",
    "\n",
    "    @classmethod\n",
    "    def merge(cls, *metadatas):\n",
    "        \"\"\"\n",
    "        Merges signatures of ``FunctionMetadata`` objects.\n",
    "\n",
    "        Parameter (either optional or non-optional) and non-parameter\n",
    "        descriptions are merged from left to right, meaning the right hand\n",
    "        metadata overrides the left hand one.\n",
    "\n",
    "        >>> def a(x, y):\n",
    "        ...     '''\n",
    "        ...     desc of *a*\n",
    "        ...     :param x: x of a\n",
    "        ...     :param y: y of a\n",
    "        ...     :return:  5*x*y\n",
    "        ...     '''\n",
    "        ...     return 5 * x * y\n",
    "        >>> def b(x):\n",
    "        ...     '''\n",
    "        ...     desc of *b*\n",
    "        ...     :param x: x of b\n",
    "        ...     :return:  100*x\n",
    "        ...     '''\n",
    "        ...     return 100 * x\n",
    "        >>> metadata1 = FunctionMetadata.from_function(a)\n",
    "        >>> metadata2 = FunctionMetadata.from_function(b)\n",
    "        >>> merged = FunctionMetadata.merge(metadata1, metadata2)\n",
    "        >>> merged.name\n",
    "        \"<Merged signature of 'a', 'b'>\"\n",
    "        >>> merged.desc\n",
    "        'desc of *b*'\n",
    "        >>> merged.retval_desc\n",
    "        '100*x'\n",
    "        >>> merged.non_optional_params['x'][0]\n",
    "        'x of b'\n",
    "        >>> merged.non_optional_params['y'][0]\n",
    "        'y of a'\n",
    "\n",
    "        :param metadatas:\n",
    "            The sequence of metadatas to merge.\n",
    "        :return:\n",
    "            A ``FunctionMetadata`` object containing the merged signature of\n",
    "            all given metadatas.\n",
    "        \"\"\"\n",
    "        # Collect the metadatas, as we operate on them more often and we want\n",
    "        # to support arbitrary sequences.\n",
    "        metadatas = tuple(metadatas)\n",
    "\n",
    "        merged_name = (\"<Merged signature of \" +\n",
    "                       \", \".join(repr(metadata.name)\n",
    "                                 for metadata in metadatas) +\n",
    "                       \">\")\n",
    "\n",
    "        merged_desc = next((m.desc for m in reversed(metadatas) if m.desc), \"\")\n",
    "        merged_retval_desc = next(\n",
    "            (m.retval_desc for m in reversed(metadatas) if m.retval_desc), \"\")\n",
    "        merged_non_optional_params = {}\n",
    "        merged_optional_params = {}\n",
    "\n",
    "        for metadata in metadatas:\n",
    "            # Use the fields and not the properties to get also omitted\n",
    "            # parameters.\n",
    "            merged_non_optional_params.update(metadata._non_optional_params)\n",
    "            merged_optional_params.update(metadata._optional_params)\n",
    "\n",
    "        merged_omit = set.union(*(metadata.omit for metadata in metadatas))\n",
    "\n",
    "        return cls(merged_name,\n",
    "                   merged_desc,\n",
    "                   merged_retval_desc,\n",
    "                   merged_non_optional_params,\n",
    "                   merged_optional_params,\n",
    "                   merged_omit)\n"
  ],
  "/home/tushar/coala/coalib/settings/Section.py": [
    "import copy\n",
    "import os\n",
    "import sys\n",
    "from collections import OrderedDict\n",
    "\n",
    "from coalib.collecting.Collectors import collect_registered_bears_dirs\n",
    "from coala_decorators.decorators import enforce_signature, generate_repr\n",
    "from coalib.misc.DictUtilities import update_ordered_dict_key\n",
    "from coalib.settings.Setting import Setting, path_list\n",
    "from coalib.parsing.Globbing import glob_escape\n",
    "\n",
    "\n",
    "def append_to_sections(sections,\n",
    "                       key,\n",
    "                       value,\n",
    "                       origin,\n",
    "                       section_name=None,\n",
    "                       from_cli=False):\n",
    "    \"\"\"\n",
    "    Appends the given data as a Setting to a Section with the given name. If\n",
    "    the Section does not exist before it will be created empty.\n",
    "\n",
    "    :param sections:     The sections dictionary to add to.\n",
    "    :param key:          The key of the setting to add.\n",
    "    :param value:        The value of the setting to add.\n",
    "    :param origin:       The origin value of the setting to add.\n",
    "    :param section_name: The name of the section to add to.\n",
    "    :param from_cli:     Whether or not this data comes from the CLI.\n",
    "    \"\"\"\n",
    "    if key == '' or value is None:\n",
    "        return\n",
    "\n",
    "    if section_name == \"\" or section_name is None:\n",
    "        section_name = \"default\"\n",
    "\n",
    "    if not section_name.lower() in sections:\n",
    "        sections[section_name.lower()] = Section(section_name)\n",
    "\n",
    "    sections[section_name.lower()].append(\n",
    "        Setting(key, str(value), origin, from_cli=from_cli))\n",
    "\n",
    "\n",
    "@generate_repr()\n",
    "class Section:\n",
    "    \"\"\"\n",
    "    This class holds a set of settings.\n",
    "    \"\"\"\n",
    "\n",
    "    @staticmethod\n",
    "    def __prepare_key(key):\n",
    "        return str(key).lower().strip()\n",
    "\n",
    "    def __init__(self,\n",
    "                 name,\n",
    "                 defaults=None):\n",
    "        if defaults is not None and not isinstance(defaults, Section):\n",
    "            raise TypeError(\"defaults has to be a Section object or None.\")\n",
    "        if defaults is self:\n",
    "            raise ValueError(\"defaults may not be self for non-recursivity.\")\n",
    "\n",
    "        self.name = str(name)\n",
    "        self.defaults = defaults\n",
    "        self.contents = OrderedDict()\n",
    "\n",
    "    def bear_dirs(self):\n",
    "        bear_dirs = path_list(self.get(\"bear_dirs\", \"\"))\n",
    "        for bear_dir in bear_dirs:\n",
    "            sys.path.append(bear_dir)\n",
    "        bear_dir_globs = [\n",
    "            os.path.join(glob_escape(bear_dir), \"**\")\n",
    "            for bear_dir in bear_dirs]\n",
    "        bear_dir_globs += [\n",
    "            os.path.join(glob_escape(bear_dir), \"**\")\n",
    "            for bear_dir in collect_registered_bears_dirs('coalabears')]\n",
    "        return bear_dir_globs\n",
    "\n",
    "    def is_enabled(self, targets):\n",
    "        \"\"\"\n",
    "        Checks if this section is enabled or, if targets is not empty, if it is\n",
    "        included in the targets list.\n",
    "\n",
    "        :param targets: List of target section names, all lower case.\n",
    "        :return:        True or False\n",
    "        \"\"\"\n",
    "        if len(targets) == 0:\n",
    "            return bool(self.get(\"enabled\", \"true\"))\n",
    "\n",
    "        return self.name.lower() in targets\n",
    "\n",
    "    def append(self, setting, custom_key=None):\n",
    "        if not isinstance(setting, Setting):\n",
    "            raise TypeError\n",
    "        if custom_key is None:\n",
    "            key = self.__prepare_key(setting.key)\n",
    "        else:\n",
    "            key = self.__prepare_key(custom_key)\n",
    "\n",
    "        # Setting asserts key != \"\" for us\n",
    "        self.contents[key] = setting\n",
    "\n",
    "    def add_or_create_setting(self,\n",
    "                              setting,\n",
    "                              custom_key=None,\n",
    "                              allow_appending=True):\n",
    "        \"\"\"\n",
    "        Adds the value of the setting to an existing setting if there is\n",
    "        already a setting  with the key. Otherwise creates a new setting.\n",
    "        \"\"\"\n",
    "        if custom_key is None:\n",
    "            key = setting.key\n",
    "        else:\n",
    "            key = custom_key\n",
    "\n",
    "        if self.__contains__(key, ignore_defaults=True) and allow_appending:\n",
    "            val = self[key]\n",
    "            val.value = str(val.value) + \"\\n\" + setting.value\n",
    "        else:\n",
    "            self.append(setting, custom_key=key)\n",
    "\n",
    "    @enforce_signature\n",
    "    def __setitem__(self, key: str, value: (str, Setting)):\n",
    "        \"\"\"\n",
    "        Creates a Setting object from the given value if needed and assigns the\n",
    "        setting to the key:\n",
    "\n",
    "        >>> section = Section('section_name')\n",
    "        >>> section['key'] = 'value'\n",
    "        >>> section['key'].value\n",
    "        'value'\n",
    "\n",
    "        :param key:   Argument whose value is to be set\n",
    "        :param value: The value of the given key\n",
    "        :return:      Returns nothing.\n",
    "        \"\"\"\n",
    "        if isinstance(value, Setting):\n",
    "            self.append(value, custom_key=key)\n",
    "        else:  # It must be a string since signature is enforced\n",
    "            self.append(Setting(key, value))\n",
    "\n",
    "    def __iter__(self, ignore_defaults=False):\n",
    "        joined = self.contents.copy()\n",
    "        if self.defaults is not None and not ignore_defaults:\n",
    "            # Since we only return the iterator of joined (which doesnt contain\n",
    "            # values) it's ok to override values here\n",
    "            joined.update(self.defaults.contents)\n",
    "\n",
    "        return iter(joined)\n",
    "\n",
    "    def __contains__(self, item, ignore_defaults=False):\n",
    "        try:\n",
    "            self.__getitem__(item, ignore_defaults)\n",
    "\n",
    "            return True\n",
    "        except IndexError:\n",
    "            return False\n",
    "\n",
    "    def __getitem__(self, item, ignore_defaults=False):\n",
    "        key = self.__prepare_key(item)\n",
    "        if key == \"\":\n",
    "            raise IndexError(\"Empty keys are invalid.\")\n",
    "\n",
    "        res = self.contents.get(key, None)\n",
    "        if res is not None:\n",
    "            return res\n",
    "\n",
    "        if self.defaults is None or ignore_defaults:\n",
    "            raise IndexError(\"Required index is unavailable.\")\n",
    "\n",
    "        return self.defaults[key]\n",
    "\n",
    "    def __str__(self):\n",
    "        value_list = \", \".join(key + \" : \" + repr(str(self.contents[key]))\n",
    "                               for key in self.contents)\n",
    "        return self.name + \" {\" + value_list + \"}\"\n",
    "\n",
    "    def get(self, key, default=\"\", ignore_defaults=False):\n",
    "        \"\"\"\n",
    "        Retrieves the item without raising an exception. If the item is not\n",
    "        available an appropriate Setting will be generated from your provided\n",
    "        default value.\n",
    "\n",
    "        :param key:             The key of the setting to return.\n",
    "        :param default:         The default value\n",
    "        :param ignore_defaults: Whether or not to ignore the default section.\n",
    "        :return:                The setting.\n",
    "        \"\"\"\n",
    "        try:\n",
    "            return self.__getitem__(key, ignore_defaults)\n",
    "        except IndexError:\n",
    "            return Setting(key, str(default))\n",
    "\n",
    "    def copy(self):\n",
    "        \"\"\"\n",
    "        :return: a deep copy of this object\n",
    "        \"\"\"\n",
    "        result = copy.copy(self)\n",
    "        result.contents = copy.deepcopy(self.contents)\n",
    "        if self.defaults is not None:\n",
    "            result.defaults = self.defaults.copy()\n",
    "\n",
    "        return result\n",
    "\n",
    "    def update(self, other_section, ignore_defaults=False):\n",
    "        \"\"\"\n",
    "        Incorporates all keys and values from the other section into this one.\n",
    "        Values from the other section override the ones from this one.\n",
    "\n",
    "        Default values from the other section override the default values from\n",
    "        this only.\n",
    "\n",
    "        :param other_section:   Another Section\n",
    "        :param ignore_defaults: If set to true, do not take default values from\n",
    "                                other\n",
    "        :return:                self\n",
    "        \"\"\"\n",
    "        if not isinstance(other_section, Section):\n",
    "            raise TypeError(\"other_section has to be a Section\")\n",
    "\n",
    "        self.contents.update(other_section.contents)\n",
    "\n",
    "        if not ignore_defaults and other_section.defaults is not None:\n",
    "            if self.defaults is None:\n",
    "                self.defaults = other_section.defaults.copy()\n",
    "            else:\n",
    "                self.defaults.update(other_section.defaults)\n",
    "\n",
    "        return self\n",
    "\n",
    "    def update_setting(self,\n",
    "                       key,\n",
    "                       new_key=None,\n",
    "                       new_value=None):\n",
    "        \"\"\"\n",
    "        Updates a setting with new values.\n",
    "        :param key:       The old key string.\n",
    "        :param new_key:   The new key string.\n",
    "        :param new_value: The new value for the setting\n",
    "        \"\"\"\n",
    "        if new_key is not None:\n",
    "            self.contents[key].key = new_key\n",
    "            self.contents = update_ordered_dict_key(self.contents,\n",
    "                                                    key,\n",
    "                                                    new_key)\n",
    "        if new_value is not None:\n",
    "            if new_key is not None:\n",
    "                self.contents[new_key].value = new_value\n",
    "            else:\n",
    "                self.contents[key].value = new_value\n",
    "\n",
    "    def delete_setting(self, key):\n",
    "        \"\"\"\n",
    "        Delete a setting\n",
    "        :param key: The key of the setting to be deleted\n",
    "        \"\"\"\n",
    "        del self.contents[key]\n"
  ],
  "/home/tushar/coala/coalib/settings/SectionFilling.py": [
    "import copy\n",
    "\n",
    "from coalib.bears.BEAR_KIND import BEAR_KIND\n",
    "from coalib.collecting.Collectors import collect_bears\n",
    "from coalib.output.printers.LOG_LEVEL import LOG_LEVEL\n",
    "from coalib.settings.Setting import Setting\n",
    "\n",
    "\n",
    "def fill_settings(sections, acquire_settings, log_printer):\n",
    "    \"\"\"\n",
    "    Retrieves all bears and requests missing settings via the given\n",
    "    acquire_settings method.\n",
    "\n",
    "    :param sections:         The sections to fill up, modified in place.\n",
    "    :param acquire_settings: The method to use for requesting settings. It will\n",
    "                             get a parameter which is a dictionary with the\n",
    "                             settings name as key and a list containing a\n",
    "                             description in [0] and the names of the bears\n",
    "                             who need this setting in all following indexes.\n",
    "    :param log_printer:      The log printer to use for logging.\n",
    "    :return:                 A tuple containing (local_bears, global_bears),\n",
    "                             each of them being a dictionary with the section\n",
    "                             name as key and as value the bears as a list.\n",
    "    \"\"\"\n",
    "    local_bears = {}\n",
    "    global_bears = {}\n",
    "\n",
    "    for section_name, section in sections.items():\n",
    "        bear_dirs = section.bear_dirs()\n",
    "        bears = list(section.get(\"bears\", \"\"))\n",
    "        section_local_bears, section_global_bears = collect_bears(\n",
    "            bear_dirs,\n",
    "            bears,\n",
    "            [BEAR_KIND.LOCAL, BEAR_KIND.GLOBAL],\n",
    "            log_printer)\n",
    "        all_bears = copy.deepcopy(section_local_bears)\n",
    "        all_bears.extend(section_global_bears)\n",
    "        fill_section(section, acquire_settings, log_printer, all_bears)\n",
    "\n",
    "        local_bears[section_name] = section_local_bears\n",
    "        global_bears[section_name] = section_global_bears\n",
    "\n",
    "    return local_bears, global_bears\n",
    "\n",
    "\n",
    "def fill_section(section, acquire_settings, log_printer, bears):\n",
    "    \"\"\"\n",
    "    Retrieves needed settings from given bears and asks the user for\n",
    "    missing values.\n",
    "\n",
    "    If a setting is requested by several bears, the help text from the\n",
    "    latest bear will be taken.\n",
    "\n",
    "    :param section:          A section containing available settings. Settings\n",
    "                             will be added if some are missing.\n",
    "    :param acquire_settings: The method to use for requesting settings. It will\n",
    "                             get a parameter which is a dictionary with the\n",
    "                             settings name as key and a list containing a\n",
    "                             description in [0] and the names of the bears\n",
    "                             who need this setting in all following indexes.\n",
    "    :param log_printer:      The log printer for logging.\n",
    "    :param bears:            All bear classes or instances.\n",
    "    :return:                 The new section.\n",
    "    \"\"\"\n",
    "    # Retrieve needed settings.\n",
    "    prel_needed_settings = {}\n",
    "    for bear in bears:\n",
    "        if not hasattr(bear, \"get_non_optional_settings\"):\n",
    "            log_printer.log(\n",
    "                LOG_LEVEL.WARNING,\n",
    "                \"One of the given bears ({}) has no attribute \"\n",
    "                \"get_non_optional_settings.\".format(bear))\n",
    "        else:\n",
    "            needed = bear.get_non_optional_settings()\n",
    "            for key in needed:\n",
    "                if key in prel_needed_settings:\n",
    "                    prel_needed_settings[key].append(bear.name)\n",
    "                else:\n",
    "                    prel_needed_settings[key] = [needed[key][0],\n",
    "                                                 bear.name]\n",
    "\n",
    "    # Strip away existent settings.\n",
    "    needed_settings = {}\n",
    "    for setting, help_text in prel_needed_settings.items():\n",
    "        if not setting in section:\n",
    "            needed_settings[setting] = help_text\n",
    "\n",
    "    # Get missing ones.\n",
    "    if len(needed_settings) > 0:\n",
    "        new_vals = acquire_settings(log_printer, needed_settings)\n",
    "        for setting, help_text in new_vals.items():\n",
    "            section.append(Setting(setting, help_text))\n",
    "\n",
    "    return section\n"
  ],
  "/home/tushar/coala/coalib/settings/Setting.py": [
    "import os\n",
    "from collections import OrderedDict\n",
    "\n",
    "from coala_decorators.decorators import generate_repr\n",
    "from coalib.misc.StringConverter import StringConverter\n",
    "from coalib.parsing.Globbing import glob_escape\n",
    "\n",
    "\n",
    "def path(obj, *args, **kwargs):\n",
    "    return obj.__path__(*args, **kwargs)\n",
    "\n",
    "\n",
    "def path_list(obj, *args, **kwargs):\n",
    "    return obj.__path_list__(*args, **kwargs)\n",
    "\n",
    "\n",
    "def url(obj, *args, **kwargs):\n",
    "    return obj.__url__(*args, **kwargs)\n",
    "\n",
    "\n",
    "def glob(obj, *args, **kwargs):\n",
    "    \"\"\"\n",
    "    Creates a path in which all special glob characters in all the\n",
    "    parent directories in the given setting are properly escaped.\n",
    "\n",
    "    :param obj: The ``Setting`` object from which the key is obtained.\n",
    "    :return:    Returns a path in which special glob characters are escaped.\n",
    "    \"\"\"\n",
    "    return obj.__glob__(*args, **kwargs)\n",
    "\n",
    "\n",
    "def glob_list(obj, *args, **kwargs):\n",
    "    \"\"\"\n",
    "    Creates a list of paths in which all special glob characters in all the\n",
    "    parent directories of all paths in the given setting are properly escaped.\n",
    "\n",
    "    :param obj: The ``Setting`` object from which the key is obtained.\n",
    "    :return:    Returns a list of paths in which special glob characters are\n",
    "                escaped.\n",
    "    \"\"\"\n",
    "    return obj.__glob_list__(*args, **kwargs)\n",
    "\n",
    "\n",
    "def typed_list(conversion_func):\n",
    "    \"\"\"\n",
    "    Creates a function that converts a setting into a list of elements each\n",
    "    converted with the given conversion function.\n",
    "\n",
    "    :param conversion_func: The conversion function that converts a string into\n",
    "                            your desired list item object.\n",
    "    :return:                A conversion function.\n",
    "    \"\"\"\n",
    "    return lambda setting: [\n",
    "        conversion_func(StringConverter(elem)) for elem in setting]\n",
    "\n",
    "\n",
    "def typed_dict(key_type, value_type, default):\n",
    "    \"\"\"\n",
    "    Creates a function that converts a setting into a dict with the given\n",
    "    types.\n",
    "\n",
    "    :param key_type:   The type conversion function for the keys.\n",
    "    :param value_type: The type conversion function for the values.\n",
    "    :param default:    The default value to use if no one is given by the user.\n",
    "    :return:           A conversion function.\n",
    "    \"\"\"\n",
    "    return lambda setting: {\n",
    "        key_type(StringConverter(key)):\n",
    "        value_type(StringConverter(value)) if value != \"\" else default\n",
    "        for key, value in dict(setting).items()}\n",
    "\n",
    "\n",
    "def typed_ordered_dict(key_type, value_type, default):\n",
    "    \"\"\"\n",
    "    Creates a function that converts a setting into an ordered dict with the\n",
    "    given types.\n",
    "\n",
    "    :param key_type:   The type conversion function for the keys.\n",
    "    :param value_type: The type conversion function for the values.\n",
    "    :param default:    The default value to use if no one is given by the user.\n",
    "    :return:           A conversion function.\n",
    "    \"\"\"\n",
    "    return lambda setting: OrderedDict(\n",
    "        (key_type(StringConverter(key)),\n",
    "         value_type(StringConverter(value)) if value != \"\" else default)\n",
    "        for key, value in OrderedDict(setting).items())\n",
    "\n",
    "\n",
    "@generate_repr(\"key\", \"value\", \"origin\", \"from_cli\")\n",
    "class Setting(StringConverter):\n",
    "    \"\"\"\n",
    "    A Setting consists mainly of a key and a value. It mainly offers many\n",
    "    conversions into common data types.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self,\n",
    "                 key,\n",
    "                 value,\n",
    "                 origin=\"\",\n",
    "                 strip_whitespaces=True,\n",
    "                 list_delimiters=(\",\", \";\"),\n",
    "                 from_cli=False,\n",
    "                 remove_empty_iter_elements=True):\n",
    "        \"\"\"\n",
    "        Initializes a new Setting,\n",
    "\n",
    "        :param key:                        The key of the Setting.\n",
    "        :param value:                      The value, if you apply conversions\n",
    "                                           to this object these will be applied\n",
    "                                           to this value.\n",
    "        :param origin:                     The originating file. This will be\n",
    "                                           used for path conversions and the\n",
    "                                           last part will be stripped of. If\n",
    "                                           you want to specify a directory as\n",
    "                                           origin be sure to end it with a\n",
    "                                           directory separator.\n",
    "        :param strip_whitespaces:          Whether to strip whitespaces from\n",
    "                                           the value or not\n",
    "        :param list_delimiters:            Delimiters for list conversion\n",
    "        :param from_cli:                   True if this setting was read by the\n",
    "                                           CliParser.\n",
    "        :param remove_empty_iter_elements: Whether to remove empty elements in\n",
    "                                           iterable values.\n",
    "        \"\"\"\n",
    "        if not isinstance(from_cli, bool):\n",
    "            raise TypeError(\"from_cli needs to be a boolean value.\")\n",
    "\n",
    "        StringConverter.__init__(\n",
    "            self,\n",
    "            value,\n",
    "            strip_whitespaces=strip_whitespaces,\n",
    "            list_delimiters=list_delimiters,\n",
    "            remove_empty_iter_elements=remove_empty_iter_elements)\n",
    "\n",
    "        self.from_cli = from_cli\n",
    "        self.key = key\n",
    "        self.origin = str(origin)\n",
    "\n",
    "    def __path__(self, origin=None, glob_escape_origin=False):\n",
    "        \"\"\"\n",
    "        Determines the path of this setting.\n",
    "\n",
    "        Note: You can also use this function on strings, in that case the\n",
    "        origin argument will be taken in every case.\n",
    "\n",
    "        :param origin:             The origin file to take if no origin is\n",
    "                                   specified for the given setting. If you\n",
    "                                   want to provide a directory, make sure it\n",
    "                                   ends with a directory separator.\n",
    "        :param glob_escape_origin: When this is set to true, the origin of\n",
    "                                   this setting will be escaped with\n",
    "                                   ``glob_escape``.\n",
    "        :return:                   An absolute path.\n",
    "        :raises ValueError:        If no origin is specified in the setting\n",
    "                                   nor the given origin parameter.\n",
    "        \"\"\"\n",
    "        strrep = str(self).strip()\n",
    "        if os.path.isabs(strrep):\n",
    "            return strrep\n",
    "\n",
    "        if hasattr(self, \"origin\") and self.origin != \"\":\n",
    "            origin = self.origin\n",
    "\n",
    "        if origin is None:\n",
    "            raise ValueError(\"Cannot determine path without origin.\")\n",
    "\n",
    "        # We need to get full path before escaping since the full path\n",
    "        # may introduce unintended glob characters\n",
    "        origin = os.path.abspath(os.path.dirname(origin))\n",
    "\n",
    "        if glob_escape_origin:\n",
    "            origin = glob_escape(origin)\n",
    "\n",
    "        return os.path.normpath(os.path.join(origin, strrep))\n",
    "\n",
    "    def __glob__(self, origin=None):\n",
    "        \"\"\"\n",
    "        Determines the path of this setting with proper escaping of its\n",
    "        parent directories.\n",
    "\n",
    "        :param origin:      The origin file to take if no origin is specified\n",
    "                            for the given setting. If you want to provide a\n",
    "                            directory, make sure it ends with a directory\n",
    "                            separator.\n",
    "        :return:            An absolute path in which the parent directories\n",
    "                            are escaped.\n",
    "        :raises ValueError: If no origin is specified in the setting nor the\n",
    "                            given origin parameter.\n",
    "        \"\"\"\n",
    "        return Setting.__path__(self, origin, glob_escape_origin=True)\n",
    "\n",
    "    def __path_list__(self):\n",
    "        \"\"\"\n",
    "        Splits the value into a list and creates a path out of each item taking\n",
    "        the origin of the setting into account.\n",
    "\n",
    "        :return: A list of absolute paths.\n",
    "        \"\"\"\n",
    "        return [Setting.__path__(elem, self.origin) for elem in self]\n",
    "\n",
    "    def __glob_list__(self):\n",
    "        \"\"\"\n",
    "        Splits the value into a list and creates a path out of each item in\n",
    "        which the special glob characters in origin are escaped.\n",
    "\n",
    "        :return: A list of absolute paths in which the special characters in\n",
    "                 the parent directories of the setting are escaped.\n",
    "        \"\"\"\n",
    "        return [Setting.__glob__(elem, self.origin) for elem in self]\n",
    "\n",
    "    @property\n",
    "    def key(self):\n",
    "        return self._key\n",
    "\n",
    "    @key.setter\n",
    "    def key(self, key):\n",
    "        newkey = str(key)\n",
    "        if newkey == \"\":\n",
    "            raise ValueError(\"An empty key is not allowed for a setting.\")\n",
    "\n",
    "        self._key = newkey\n"
  ],
  "/home/tushar/coala/coalib/settings/__init__.py": [],
  "/home/tushar/coala/conftest.py": [
    "import os\n",
    "import webbrowser\n",
    "\n",
    "\n",
    "def pytest_unconfigure(config):\n",
    "    htmlcov_path = os.path.join(\"htmlcov\", \"index.html\")\n",
    "    if (hasattr(config.option, \"cov_report\") and\n",
    "            'html' in config.option.cov_report and\n",
    "            os.path.isfile(htmlcov_path)):\n",
    "        try:\n",
    "            webbrowser.open_new_tab(htmlcov_path)\n",
    "        except webbrowser.Error:\n",
    "            pass\n"
  ],
  "/home/tushar/coala/docs/General_Dev_Info/git_tutorial_1.rst": [
    "A Hitchhiker's Guide to Git(1): Genesis\n",
    "#######################################\n",
    "\n",
    "Introduction\n",
    "============\n",
    "\n",
    "What is This?\n",
    "-------------\n",
    "\n",
    "This post tries to provide a **gentle introduction** to git. While it is\n",
    "aimed at **newcomers** it is also meant to give a rather **good overview\n",
    "and understanding** of what one can do with git and thus **is\n",
    "extensive**. It follows the premise:\n",
    "\n",
    "    If you know how a thing works, you can make it do what you want it\n",
    "    to.\n",
    "\n",
    "Please don't be afraid as I'm trying to use **light language** and\n",
    "**many examples** so you can **read fast** through it and understand\n",
    "anyway (if I succeed). I'm also trying to **highlight important things**\n",
    "at least for long texts to ease reading a bit more. However, at some\n",
    "points this tutorial *may* require you to **think for yourselves** a bit\n",
    "- it's a feature, not a bug.\n",
    "\n",
    "For Whom is This?\n",
    "-----------------\n",
    "\n",
    "This tutorial is meant for everyone willing to learn git - it does not\n",
    "matter if you are a **developer** who never really got the hang of it or\n",
    "a **student** wanting to learn. Even if you are doing non coding tasks\n",
    "like **design** or **documentation** git can be a gift from heaven. This\n",
    "tutorial is **for everyone** - don't be scared by its length and believe\n",
    "me, **it pays off**! The only **requirement** is that you have **git\n",
    "installed**, know ``cd``, ``ls`` and ``mkdir`` and **have something to\n",
    "commit** - and who doesn't have any digital data!?\n",
    "\n",
    "What's in There?\n",
    "----------------\n",
    "\n",
    "This tutorial is the **first out of three** tutorials which are meant to\n",
    "**free your mind** from a **traditional view on filesystems**.\n",
    "\n",
    "Genesis\n",
    "~~~~~~~\n",
    "\n",
    "This tutorial, **Genesis (i.e. \"Creation\" or \"Beginning\")**, will cover\n",
    "some very basic things:\n",
    "\n",
    "-  **Configuring** git so you can use it how you want. (Basic, aliases)\n",
    "-  **Creating** your git **repository** (play god once!)\n",
    "-  **Creating** your first git **commits**.\n",
    "-  **Learning** what the **repository** is and **where commits get\n",
    "   stored**.\n",
    "-  **Browsing** through **history**.\n",
    "-  **Ignoring files**.\n",
    "\n",
    "Exodus\n",
    "~~~~~~\n",
    "\n",
    "**Exodus (i.e. \"going out\")** will cover:\n",
    "\n",
    "-  **Store** temporary changes **without committing**.\n",
    "-  **Navigating** commits in git.\n",
    "-  **Sharing** commits to a **remote place**.\n",
    "-  **Locally** (huh, that's sharing?)\n",
    "-  Via **email**\n",
    "-  To a **server**\n",
    "-  To a **client**\n",
    "-  Working **with others** (i.e. **non-linear**).\n",
    "-  **Join** things.\n",
    "-  **Linearize** things.\n",
    "-  **Writing good** commits.\n",
    "-  **Editing** commits. (Actually not editing but it feels like that.)\n",
    "\n",
    "Apocalypse\n",
    "~~~~~~~~~~\n",
    "\n",
    "**Apocalypse (i.e. \"uncovering\")** will try to uncover some more\n",
    "advanced features of git, finally freeing your mind from your\n",
    "non-versioned filesystem:\n",
    "\n",
    "-  **Finding more information** about code.\n",
    "-  **Finding causes of bugs** in git.\n",
    "-  **Reverting** commits.\n",
    "-  **Reviewing** commits.\n",
    "-  **Travelling though time** and **changing history** (you want me to\n",
    "   believe you've never wanted to do that?)\n",
    "-  **Getting back** lost things.\n",
    "-  Let git **do things automatically**.\n",
    "\n",
    "Some Warnings\n",
    "-------------\n",
    "\n",
    "A short warning: If you ever really got the hang of git you will not be\n",
    "able to **use something else** without symptoms of **frustration and\n",
    "disappointment** - you'll end up writing every document versioned as an\n",
    "excuse to use git.\n",
    "\n",
    "A warning for windows users: you may need to use equivalent commands to\n",
    "some basic UNIX utilities or just install them with git. (Installer\n",
    "provides an option for that.) In general it's a bit like travelling with\n",
    "Vogons - avoid when possible.\n",
    "\n",
    "A warning for GUI users: **Don't use your GUI**. Be it the GitHub App or\n",
    "SourceTree or something else - they usually try to make things more\n",
    "abstract for us, thus they hinder us from understanding git and we can\n",
    "then not make git do what we want. Being able to communicate\n",
    "**directly** with git is a great thing and really bumps\n",
    "**productivity**!\n",
    "\n",
    "I wrote this tutorial to the best of my knowledge and experience, if you\n",
    "spot an error or find something important is missing, be sure to drop me\n",
    "a message!\n",
    "\n",
    "Preparation...\n",
    "--------------\n",
    "\n",
    "So go now, grab a cup of coffee (or any other drink), a towel, take your\n",
    "best keyboard and open a terminal beneath this window!\n",
    "\n",
    "What's Git for Anyway?\n",
    "======================\n",
    "\n",
    "Before we really get started it is important to know what git roughly\n",
    "does: git is a program that allows you to **manage files**. To be more\n",
    "specific git allows you to **define changes on files**. In the end your\n",
    "repository is just a **bunch of changes** that may be related to each\n",
    "other.\n",
    "\n",
    "Setting Up Git\n",
    "==============\n",
    "\n",
    "Before we can continue we'll have to set up a few tiny things for git.\n",
    "For this we will use the ``git config --global`` command which simply\n",
    "**stores** a **key value pair** into your **user-global git\n",
    "configuration file** (usually stored at ``~/.gitconfig``).\n",
    "\n",
    "WHOAMI\n",
    "------\n",
    "\n",
    "Let's tell git who we are! This is pretty straightforward:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git config --global user.name \"Ford Prefect\"\n",
    "    $ git config --global user.email ford@prefect.bg\n",
    "\n",
    "This makes git store values for \"name\" and \"email\" within the \"user\"\n",
    "section of the gitconfig.\n",
    "\n",
    "Editor\n",
    "------\n",
    "\n",
    "For some operations git will give you an **editor** so you can enter\n",
    "needed data. This editor is **vim by default**. Some people think vim is\n",
    "great (vim *is* great!), some do not. If you belong to the latter group\n",
    "or don't know what vim is and how to operate it, let's **change the\n",
    "editor**:\n",
    "\n",
    "::\n",
    "\n",
    "    $ # Take an editor of your choice instead of nano\n",
    "    $ git config --global core.editor nano\n",
    "\n",
    "Please make sure that the **command** you give to git always **starts as\n",
    "an own process** and ends only when you finished editing the file. (Some\n",
    "editors might detect running processes, pass the filename to them and\n",
    "exit immediately. Use ``-s`` argument for gedit, ``--wait`` argument for\n",
    "sublime.) Please **don't use notepad** on windows, this program is a\n",
    "perfect example of a text editor which is too dumb to show text unless\n",
    "the text is written by itself.\n",
    "\n",
    "Create a Repository\n",
    "===================\n",
    "\n",
    "So, lets get started - with nothing. Let's make an empty directory. You\n",
    "can do that from your usual terminal:\n",
    "\n",
    "::\n",
    "\n",
    "    $ mkdir git-tutorial\n",
    "    $ cd git-tutorial\n",
    "    $ ls -a\n",
    "    ./  ../\n",
    "\n",
    "So, lets do the first git command here:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git init\n",
    "    Initialized empty Git repository in /home/lasse/prog/git-tutorial/.git/\n",
    "    $ ls -a\n",
    "    ./  ../  .git/\n",
    "\n",
    "So now we've got the ``.git`` folder. Since we just created a repository\n",
    "with ``git init``, so we can deduce, that this **.git directory must in\n",
    "fact be the repository**!\n",
    "\n",
    "Creating a God Commit\n",
    "=====================\n",
    "\n",
    "So, let's create some content we can manage with git:\n",
    "\n",
    "::\n",
    "\n",
    "    $ echo 'Hello World!' >> README\n",
    "    $ cat README\n",
    "    Hello World!\n",
    "\n",
    "Since we know, that the .git directory is our repository, we also know\n",
    "that **we did not add this file to our repository** yet. So how do we do\n",
    "that?\n",
    "\n",
    "As I've hinted before, our git repository **does not contain files** but\n",
    "only **changes** - so how do we make a change out of our file?\n",
    "\n",
    "The answer lies in (1) ``git add`` and (2) ``git commit`` which allows us\n",
    "to (1) specify what files/file changes we want to add to the change and\n",
    "(2) that we want to pack those file changes into a so-called **commit**.\n",
    "Git also offers a helper command so we can see what will be added to our\n",
    "commit: ``git status``.\n",
    "\n",
    "Let's try it out:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git status\n",
    "    On branch master\n",
    "\n",
    "    Initial commit\n",
    "\n",
    "    Untracked files:\n",
    "      (use \"git add <file>...\" to include in what will be committed)\n",
    "\n",
    "        README\n",
    "\n",
    "    nothing added to commit but untracked files present (use \"git add\" to track)\n",
    "    $ git add README\n",
    "    $ git status\n",
    "    On branch master\n",
    "\n",
    "    Initial commit\n",
    "\n",
    "    Changes to be committed:\n",
    "      (use \"git rm --cached <file>...\" to unstage)\n",
    "\n",
    "        new file:   README\n",
    "\n",
    "So obviously with ``git add`` we can **stage** files. What does that\n",
    "mean?\n",
    "\n",
    "As we know, when we're working in our directory **any actions on files\n",
    "won't affect our repository**. So in order to **add a file** to the\n",
    "repository, we'll have to **put it into a commit**. In order to do that,\n",
    "we need to **specify, what files/changes should go into our commit**,\n",
    "i.e. stage them. When we did ``git add README``, we **staged** the file\n",
    "README, thus every change we did until now to it will be **included in\n",
    "our next commit**. (You can also partially stage files so if you edit\n",
    "README now the change won't be committed.)\n",
    "\n",
    "Now we'll do something very special in git - **creating the first\n",
    "commit**! (We'll pass the ``-v`` argument to get a bit more info from\n",
    "git on what we're doing.)\n",
    "\n",
    "::\n",
    "\n",
    "    $ git commit -v\n",
    "\n",
    "You should now get your editor with contents similar to this:\n",
    "\n",
    "::\n",
    "\n",
    "\n",
    "    # Please enter the commit message for your changes. Lines starting\n",
    "    # with '#' will be ignored, and an empty message aborts the commit.\n",
    "    # On branch master\n",
    "    #\n",
    "    # Initial commit\n",
    "    #\n",
    "    # Changes to be committed:\n",
    "    #   new file:   README\n",
    "    #ref: refs/heads/master\n",
    "\n",
    "    # ------------------------ >8 ------------------------\n",
    "    # Do not touch the line above.\n",
    "    # Everything below will be removed.\n",
    "    diff --git a/README b/README\n",
    "    new file mode 100644\n",
    "    index 0000000..c57eff5\n",
    "    --- /dev/null\n",
    "    +++ b/README\n",
    "    @@ -0,0 +1 @@\n",
    "    +Hello World!\n",
    "\n",
    "Since we're about to create a change, git asks us for a **description**.\n",
    "\n",
    ".. note::\n",
    "    Git actually allows creating commits without a description with\n",
    "    a special argument. This is not recommended for productive\n",
    "    collaborative work!)\n",
    "\n",
    "Since we passed the ``-v`` parameter, git also shows us below what will\n",
    "be included in our change. We'll look at this later.\n",
    "\n",
    "**Commit messages** are usually written in **imperative present tense**\n",
    "and should follow certain guidelines. We'll come to this later.\n",
    "\n",
    "So, let's enter: ``Add README`` as our commit message, save and exit the\n",
    "editor.\n",
    "\n",
    "Now, let's take a look at what we've created, ``git show`` is the\n",
    "command that shows us the **most recent commit**:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git show\n",
    "    commit ec6c903a0a18960cd73df18897e56738c4c6bb51\n",
    "    Author: Lasse Schuirmann <lasse.schuirmann@gmail.com>\n",
    "    Date:   Fri Feb 27 14:12:01 2015 +0100\n",
    "\n",
    "        Add README\n",
    "\n",
    "    diff --git a/README b/README\n",
    "    new file mode 100644\n",
    "    index 0000000..980a0d5\n",
    "    --- /dev/null\n",
    "    +++ b/README\n",
    "    @@ -0,0 +1 @@\n",
    "    +Hello World!\n",
    "\n",
    "So what do we see here:\n",
    "\n",
    "-  It seems that commits have an **ID**, in this case\n",
    "   ``ec6c903a0a18960cd73df18897e56738c4c6bb51``.\n",
    "-  Commits also have an **author** and a **creation date**.\n",
    "-  Of course they hold the **message** we wrote and **changes** to some\n",
    "   files.\n",
    "\n",
    "What we see below the ``diff ...`` line is obviously the change. Let's\n",
    "take a look at it: since **git can only describe changes**, it takes\n",
    "``/dev/null`` (which is a bit special, kind of an empty file, not\n",
    "important here), **renames** it to ``README`` and **fills** it with our\n",
    "contents.\n",
    "\n",
    "So, this commit is pretty godish: It exists purely on it's own, has no\n",
    "relations to any other commit (yet, it's based on an empty repository,\n",
    "right?) and **creates a file out of nothing** (/dev/null is somehow all\n",
    "*and* nothing, kind of a unix black hole).\n",
    "\n",
    "Inspecting What Happened\n",
    "========================\n",
    "\n",
    "So, let's look in our repository!\n",
    "\n",
    "::\n",
    "\n",
    "    $ ls -la .git\n",
    "    total 52\n",
    "    drwxrwxr-x. 8 lasse lasse 4096 Feb 27 16:05 ./\n",
    "    drwxrwxr-x. 3 lasse lasse 4096 Feb 27 14:11 ../\n",
    "    drwxrwxr-x. 2 lasse lasse 4096 Feb 27 14:11 branches/\n",
    "    -rw-rw-r--. 1 lasse lasse  486 Feb 27 14:12 COMMIT_EDITMSG\n",
    "    -rwxrw-r--. 1 lasse lasse   92 Feb 27 14:11 config*\n",
    "    -rw-rw-r--. 1 lasse lasse   73 Feb 27 14:11 description\n",
    "    -rw-rw-r--. 1 lasse lasse   23 Feb 27 14:11 HEAD\n",
    "    drwxrwxr-x. 2 lasse lasse 4096 Feb 27 14:11 hooks/\n",
    "    -rw-rw-r--. 1 lasse lasse  104 Feb 27 14:11 index\n",
    "    drwxrwxr-x. 2 lasse lasse 4096 Feb 27 14:11 info/\n",
    "    drwxrwxr-x. 3 lasse lasse 4096 Feb 27 14:12 logs/\n",
    "    drwxrwxr-x. 7 lasse lasse 4096 Feb 27 14:12 objects/\n",
    "    drwxrwxr-x. 4 lasse lasse 4096 Feb 27 14:11 refs/\n",
    "    $\n",
    "\n",
    "Now let's look into it further to get to know what it is a bit more. I\n",
    "will try to cover only important parts here, if you're interested even\n",
    "deeper, you can try DuckDuckGo or take a look at this:\n",
    "http://git-scm.com/docs/gitrepository-layout\n",
    "\n",
    "The config file\n",
    "---------------\n",
    "\n",
    "The **config file** is a similar file to the one where our **settings**\n",
    "in the beginning got stored. (User and editor configuration, remember?)\n",
    "You can use it to store settings **per repository**.\n",
    "\n",
    "The objects directory\n",
    "---------------------\n",
    "\n",
    "The objects directory is an important one: It contains our commits.\n",
    "\n",
    "One could do a full tutorial on those things but that's not covered\n",
    "here. If you want that, check out:\n",
    "http://git-scm.com/book/en/v2/Git-Internals-Git-Objects\n",
    "\n",
    "We just saw the **ID** of the commit we made:\n",
    "``ec6c903a0a18960cd73df18897e56738c4c6bb51``\n",
    "\n",
    "Now let's see if we find it in the objects directory:\n",
    "\n",
    "::\n",
    "\n",
    "    $ ls .git/objects\n",
    "    98/  b4/  ec/  info/  pack/\n",
    "    $ ls .git/objects/ec\n",
    "    6c903a0a18960cd73df18897e56738c4c6bb51\n",
    "\n",
    "So, when we create a commit, the contents (including metadata) are\n",
    "**hashed** and git stores it finely into the objects directory.\n",
    "\n",
    "That isn't so complicated at all, is it?\n",
    "\n",
    "Task: Objects\n",
    "~~~~~~~~~~~~~\n",
    "\n",
    "``git show`` accepts a commit ID as an argument. So you could e.g. do\n",
    "``git show ec6c903a0a18960cd73df18897e56738c4c6bb51`` instead of\n",
    "``git show`` if this hash is the current commit.\n",
    "\n",
    "Investigate what the other two objects are, which are stored in the\n",
    "objects directory. (Ignore the info and pack subdirectory.)\n",
    "\n",
    "Do ``git show`` again and take a look at the line beginning with\n",
    "\"index\". I'm sure you can make sense out of it!\n",
    "\n",
    "The HEAD File\n",
    "-------------\n",
    "\n",
    "The HEAD file is here so git knows what the current commit is, i.e. with\n",
    "which objects it has to compare the files in the file system to e.g.\n",
    "generate a diff. Let's look into it:\n",
    "\n",
    "::\n",
    "\n",
    "    $ cat .git/HEAD\n",
    "    ref: refs/heads/master\n",
    "\n",
    "So it actually only references to something else.\n",
    "\n",
    "So let's take a look into refs/heads/master - what ever this is:\n",
    "\n",
    "::\n",
    "\n",
    "    $ cat .git/refs/heads/master\n",
    "    ec6c903a0a18960cd73df18897e56738c4c6bb51\n",
    "\n",
    "So this ``HEAD`` file refers to this ``master`` file which refers to our\n",
    "current commit. We'll see how that makes sense later.\n",
    "\n",
    "Creating a Child Commit\n",
    "=======================\n",
    "\n",
    "Now, let's go on and create another commit. Let's add something to our\n",
    "README. You can do that by yourself, I'm sure!\n",
    "\n",
    "Let's see what we've done:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git diff\n",
    "    diff --git a/README b/README\n",
    "    index 980a0d5..c9b319e 100644\n",
    "    --- a/README\n",
    "    +++ b/README\n",
    "    @@ -1 +1,2 @@\n",
    "     Hello World!\n",
    "    +Don't panic!\n",
    "\n",
    "Let's commit it. However, since we're a bit lazy we **don't** want to\n",
    "**add** the README **manually** again; the commit command has an\n",
    "argument that allows you to **auto-stage all changes** to all files that\n",
    "are in our **repository**. (So if you added **another file** which is\n",
    "**not in the repository** yet it **won't be staged**!)\n",
    "\n",
    "::\n",
    "\n",
    "    $ git commit -a -v\n",
    "\n",
    "Well, you know the game. Can you come up with a **good message** on your\n",
    "own?\n",
    "\n",
    "::\n",
    "\n",
    "    $ git show\n",
    "    commit 7b4977cdfb3f304feffa6fc22de1007dd2bebf26\n",
    "    Author: Lasse Schuirmann <lasse.schuirmann@gmail.com>\n",
    "    Date:   Fri Feb 27 16:39:11 2015 +0100\n",
    "\n",
    "        README: Add usage instructions\n",
    "\n",
    "    diff --git a/README b/README\n",
    "    index 980a0d5..c9b319e 100644\n",
    "    --- a/README\n",
    "    +++ b/README\n",
    "    @@ -1 +1,2 @@\n",
    "     Hello World!\n",
    "    +Don't panic!\n",
    "\n",
    "So this **commit** obviously represents the **change** from a file named\n",
    "README which **contents** are **stored in object** ``980a0d5`` to a file\n",
    "also named README which **contents** are **stored in object**\n",
    "``c9b319e``.\n",
    "\n",
    "A Glance At Our History\n",
    "=======================\n",
    "\n",
    "Let's see a timeline of what we've done:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git log\n",
    "    commit 7b4977cdfb3f304feffa6fc22de1007dd2bebf26\n",
    "    Author: Lasse Schuirmann <lasse.schuirmann@gmail.com>\n",
    "    Date:   Fri Feb 27 16:39:11 2015 +0100\n",
    "\n",
    "        README: Add usage instructions\n",
    "\n",
    "    commit ec6c903a0a18960cd73df18897e56738c4c6bb51\n",
    "    Author: Lasse Schuirmann <lasse.schuirmann@gmail.com>\n",
    "    Date:   Fri Feb 27 14:12:01 2015 +0100\n",
    "\n",
    "        Add README\n",
    "\n",
    "That looks fairly easy. However I cannot withstand to point out that\n",
    "despite commits look so fine, linearly **arranged** here, they are\n",
    "actually **nothing more than commit objects, floating around** in the\n",
    "**.git/objects/ directory**. So ``git log`` just **looks where HEAD\n",
    "points to** and recursively asks each commit **what it's parent is** (if\n",
    "it has one).\n",
    "\n",
    "Since every good hitchhiker does know how to travel through time and\n",
    "change events, we'll learn to do that in the next chapter ;)\n",
    "\n",
    "Configuring Git Even Better\n",
    "===========================\n",
    "\n",
    "Better staging\n",
    "--------------\n",
    "\n",
    "It is worth to mention that ``git add`` also **accepts directories** as\n",
    "an argument. I.e. ``git add .`` **recursively adds all files** from the\n",
    "**current directory**.\n",
    "\n",
    "In order to generally **ignore certain patterns** of files (e.g. it's\n",
    "**bad practice** to **commit any generated stuff**), one can write a\n",
    "``.gitignore`` file. This file can look as follows:\n",
    "\n",
    "::\n",
    "\n",
    "    README~  # Ignore gedit temporary files\n",
    "    *.o  # Ignore compiled object files\n",
    "\n",
    "The **exact pattern** is defined here: http://git-scm.com/docs/gitignore\n",
    "\n",
    "Files matching this pattern will:\n",
    "\n",
    "-  Not be added with ``git add`` unless forced with ``-f``\n",
    "-  Not be shown in ``git status`` as unstaged\n",
    "\n",
    "It is usually a good idea to **commit** the ``.gitignore`` **to the\n",
    "repository** so all developers don't need to care about those files.\n",
    "\n",
    "Aliases\n",
    "-------\n",
    "\n",
    "So, we've learned quite some stuff. However git command's aren't as\n",
    "**intuitive** as they could be sometimes. They could be **shorter** too.\n",
    "So let's define us some **aliases** of the commands we know. The ones\n",
    "given here are **only suggestions**, you should **choose the aliases in\n",
    "a way that suits best for you**!\n",
    "\n",
    "Aliasing Git Itself\n",
    "~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "If you're using git much, you might want to add ``alias g=git`` to your\n",
    "``.bashrc`` or ``.zshrc`` or whatever. (On windows you're a bit screwed.\n",
    "But what did you expect? Really?)\n",
    "\n",
    "Aliasing Git Commands\n",
    "~~~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "Let's let git give us our editor since we don't want to edit just one\n",
    "value:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git config --global --edit\n",
    "\n",
    "You can add aliases through the ``[alias]`` section, here are the\n",
    "aliases I suggest:\n",
    "\n",
    "::\n",
    "\n",
    "    [alias]\n",
    "    a = add\n",
    "    c = commit -v\n",
    "    ca = commit -v -a\n",
    "    d = diff\n",
    "    dif = diff # Thats a typo :)\n",
    "    i = init\n",
    "    l = log\n",
    "    st = status\n",
    "    stat = status\n",
    "\n",
    "Conclusion\n",
    "==========\n",
    "\n",
    "So what did we learn?\n",
    "\n",
    "We did some basic git commands:\n",
    "\n",
    "-  ``git config``: accessing git configuration\n",
    "-  ``git init``: creating a repository\n",
    "-  ``git status``: getting the current status of files, staging and so on\n",
    "-  ``git add``: staging files for the commit\n",
    "-  ``git diff``: showing the difference between the current commit and\n",
    "   what we have on our file system\n",
    "-  ``git commit``: writing staged changes to a commit\n",
    "-  ``git log``: browsing history\n",
    "\n",
    "We also learned how git organizes commits, how it stores files and how\n",
    "we can make git ignore files explicitly.\n",
    "\n",
    "I hope this helped you **understanding** a bit **what git does** and\n",
    "**what it is**. The next tutorial will hopefully cover all the basics.\n",
    "(Some were already hinted here.)\n"
  ],
  "/home/tushar/coala/docs/Getting_Involved/Codestyle.rst": [
    "Codestyle for coala\n",
    "===================\n",
    "\n",
    "*coala* follows the `PEP8\n",
    "codestyle <https://www.python.org/dev/peps/pep-0008/>`__ with a maximum\n",
    "line length of 80 characters including newline. Invoke ``coala`` to let\n",
    "it correct your code automatically.\n",
    "\n",
    "Additional Style Guidelines\n",
    "---------------------------\n",
    "\n",
    "Documentation Comments\n",
    "~~~~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "A documentation comment consists of 2 parts - the description of what\n",
    "the function/class/module does followed by the parameters it takes in,\n",
    "the return value it gives out and the exceptions it can raise.\n",
    "\n",
    "Nothing should be written on the first and last line where the docstring\n",
    "begins and ends, and a newline should separate the description and the\n",
    "rest. Each message in the documentation comment must end with a\n",
    "full-stop. Also the description of all arguments and the return value\n",
    "should begin at the same column.\n",
    "\n",
    "Example:\n",
    "\n",
    "::\n",
    "\n",
    "    def area(length, breadth):\n",
    "        \"\"\"\n",
    "        Finds the area of a rectangle of the given length and breadth.\n",
    "\n",
    "        :param length:      The length of the rectangle.\n",
    "        :param breadth:     The breadth of the rectangle.\n",
    "        :return:            The area of the rectangle.\n",
    "        :raises ValueError: Raises ValueError if the arguments are not of type\n",
    "                            float or int.\n",
    "        \"\"\"\n",
    "\n",
    "If the description for a param or other keywords exceeds 1 line,\n",
    "continue it in the next. Make sure that the second line is aligned Below\n",
    "the first line.\n",
    "\n",
    "Example :\n",
    "\n",
    "::\n",
    "\n",
    "    :param something: A very long line describing the variable something\n",
    "                      in great detail.\n",
    "    :return:          This message also started in the same column and it\n",
    "                      starts again at the same column as the rest of the\n",
    "                      messages.\n",
    "\n",
    "Type Checking\n",
    "~~~~~~~~~~~~~\n",
    "\n",
    "If you want to assure that parameters have a certain type, you can use\n",
    "the ``enforce_signature`` decorator and simply annotate your function\n",
    "with the allowed types:\n",
    "\n",
    ".. code:: python\n",
    "\n",
    "    @enforce_signature\n",
    "    def concatenate_strings(a: str, b: str, c: (str, None)=None):\n",
    "        if c is None:\n",
    "            c = \"\"\n",
    "        return a + b + c\n",
    "\n",
    "This will raise a ``TypeError`` if ``a``, ``b`` or ``c`` are no strings\n",
    "and ``c`` is not ``None``.\n"
  ],
  "/home/tushar/coala/docs/Getting_Involved/MAC_Hints.rst": [
    "Coverage Installation Hints for OSX Users:\n",
    "==========================================\n",
    "\n",
    "1. Make sure you have installed Xcode and Homebrew.\n",
    "---------------------------------------------------\n",
    "\n",
    "2. Install Python3.\n",
    "-------------------\n",
    "\n",
    "::\n",
    "\n",
    "    $ brew search python  # This should display python3\n",
    "    $ brew install python3\n",
    "    $ python3 --version   # To check the installed version\n",
    "\n",
    "3. Create Virtual environments with pyvenv\n",
    "------------------------------------------\n",
    "\n",
    "::\n",
    "\n",
    "    # Create Virtual Env named myenv\n",
    "    $ pyvenv myenv\n",
    "\n",
    "    # This will create a folder named myenv in the\n",
    "    # current directory. To activate this environment just type\n",
    "    $ source myenv/bin/activate\n",
    "\n",
    "    # You can start Python3 by typing:\n",
    "    $ python\n",
    "\n",
    "4. Virtualenvwrapper with Python 3:\n",
    "-----------------------------------\n",
    "\n",
    "::\n",
    "\n",
    "    # Installation\n",
    "    $ pip3 install virtualenv\n",
    "    $ pip3 install virtualenvwrapper\n",
    "\n",
    "    # Folder to contain Virtual Environments\n",
    "    $ mkdir ~/.virtualenvs\n",
    "\n",
    "    # Add the following in ~/.bash_profile\n",
    "    $ export WORKON_HOME=~/.virtualenvs\n",
    "    $ source /usr/local/bin/virtualenvwrapper.sh\n",
    "\n",
    "    # Activate Changes\n",
    "    $ source ~/.bash_profile\n",
    "\n",
    "    # Get Python3 path (python3_pth)\n",
    "    $ where python3\n",
    "\n",
    "    # Create a new virtual environment with Python3\n",
    "    $ mkvirtualenv --python=python3_path myenv\n",
    "\n",
    "Finally!\n",
    "--------\n",
    "\n",
    "::\n",
    "\n",
    "    # Install python-coverage3 by\n",
    "    $ easy_install coverage\n",
    "\n"
  ],
  "/home/tushar/coala/docs/Getting_Involved/Newcomers.rst": [
    "Welcome to the Newcomers guide!\n",
    "===============================\n",
    "\n",
    "This guide will help you to get involved and teach you how to make your first\n",
    "contribution to *coala*!\n",
    "\n",
    "Meet the community!\n",
    "-------------------\n",
    "\n",
    "To get started, the first step is to meet the community. We use gitter to\n",
    "communicate, and there the helpful community will guide you. Join us at `coala gitter <https://gitter.im/coala-analyzer/coala/>`_.\n",
    "The newcomers should ping us \"Hello World\" to let us know they are here\n",
    "because we care!\n",
    "\n",
    "**Congratulations!** You are now part of our community.\n",
    "\n",
    "Start working\n",
    "-------------\n",
    "\n",
    "Let us know that you are interested in contributing on gitter and ask for an\n",
    "invitation to our org. This is your first step towards contributing.\n",
    "The invitation will be sent by mail and you will have to accept\n",
    "it to join. If you don't find the invitation, accept it `here <https://github.com/coala-analyzer>`_.\n",
    "\n",
    "Now that you are part of our organization, you can start working on issues.\n",
    "If you are familiar with git, you can skip the next section and pick an issue.\n",
    "\n",
    "\n",
    "Get help with git\n",
    "-----------------\n",
    "\n",
    "We use github to manage our repository. If you're not familiar with git, we\n",
    "strongly recommend following a tutorial, such as `this one <https://try.github.io/levels/1/challenges/1>`_.\n",
    "\n",
    "If there's anything unclear, or you are encountering problems, feel free\n",
    "to contact us on gitter, and we will help you!\n",
    "\n",
    "Start working\n",
    "-------------\n",
    "\n",
    "Now is the time to pick an issue.\n",
    "Here is the link that will lead you to `Newcomers issues <http://tinyurl.com/coala-new>`_.\n",
    "\n",
    ".. seealso::\n",
    "\n",
    "    For more information about what bears are, please check the following link: `Writing bears <http://coala.readthedocs.org/en/latest/Users/Tutorials/Writing_Bears.html>`_\n",
    "\n",
    "The easy issues that will help you get started are labeled as\n",
    "\"difficulty/newcomer\" and are only there to give you a glimpse of how it is\n",
    "to work with us.\n",
    "\n",
    "Now pick an issue which isn't assigned, and if you want to fix\n",
    "it, then leave a comment that you would like to get assigned. This way\n",
    "we don't have multiple people working on the same issue at the same time.\n",
    "Now you can start working on it.\n",
    "For more info on how to work correctly with git, try `this <http://coala.readthedocs.org/en/latest/Users/Tutorials/Git_Help.html>`_.\n",
    "\n",
    ".. note::\n",
    "\n",
    "    Before starting to write your first commit, check out this link:\n",
    "    `Writing good commits <http://coala.readthedocs.org/en/latest/Getting_Involved/Writing_Good_Commits.html>`_\n",
    "\n",
    "Things to do before pushing\n",
    "---------------------------\n",
    "\n",
    "Now you need to make sure your change is actually working. For this, you will\n",
    "need to test it locally before pushing it to your fork, and checking it with\n",
    "concrete examples. So basically, run tests and run *coala* by simply typing\n",
    "\n",
    "::\n",
    "\n",
    "    $ coala\n",
    "\n",
    "into your bash. This will analyze your code and help you fix it.\n",
    "\n",
    ".. seealso::\n",
    "\n",
    "    `Executing tests <http://coala.readthedocs.org/en/latest/Getting_Involved/Testing.html>`_\n",
    "\n",
    "Sending your changes\n",
    "--------------------\n",
    "\n",
    "Now that you've fixed the issue, you've tested it and you think it is ready\n",
    "to be used, create a commit and push it to your fork, using:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git push origin fix-branch\n",
    "\n",
    "Creating a ``Pull Request``\n",
    "---------------------------\n",
    "\n",
    "Now that your commit has been sent to your fork, it is time\n",
    "to do a ``Pull Request``. It can be done by accessing your fork on github and\n",
    "clicking ``New Pull Request``.\n",
    "\n",
    "**Congratulations!** You have now created your first ``Pull Request``!\n",
    "\n",
    "What to do after creating a ``Pull Request``\n",
    "--------------------------------------------\n",
    "\n",
    "After creating your ``Pull Request``, there's two options:\n",
    "\n",
    "- your ``Pull Request`` gets accepted, and your commit will get merged into the\n",
    "  master branch\n",
    "- your ``Pull Request`` doesn't, and therefore you will need to to modify it as\n",
    "  per the review comments\n",
    "\n",
    "It's highly unlikely that your ``Pull Request`` will be accepted on the first\n",
    "attempt - but don't worry, that's just how it works. It helps us keep *coala*\n",
    "**clean** and **stable**.\n",
    "\n",
    ".. seealso::\n",
    "\n",
    "    `Review Process <http://coala.readthedocs.org/en/latest/Getting_Involved/Review.html>`_.\n",
    "\n",
    "Now if you need to modify your code, you can simply edit it again, add it and\n",
    "commit it using\n",
    "\n",
    "::\n",
    "\n",
    "    $ git commit -a --amend\n",
    "\n",
    "This will edit your last commit message. If your commit message was considered\n",
    "fine by our reviewers, you can simply send it again like this. If not, edit it\n",
    "and send it. You have successfully edited your last commit!\n",
    "\n",
    ".. note::\n",
    "\n",
    "    Don't forget! After editing your commit, you will have to push it again.\n",
    "    This can be done using:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git push --force origin\n",
    "\n",
    "**Congratulations!** Your PR just got accepted! You're awesome.\n",
    "Now try `writing a bear <http://coala.readthedocs.org/en/latest/Users/Tutorials/Writing_Bears.html>`_,\n",
    "they are really rewarding!\n"
  ],
  "/home/tushar/coala/docs/Getting_Involved/README.rst": [
    "Getting Involved\n",
    "================\n",
    "\n",
    "We are working hard to make *coala* reality. If you want to help us you\n",
    "can do the following things:\n",
    "\n",
    "-  Join us on our mailing list.\n",
    "-  *coala* developer list:\n",
    "   https://groups.google.com/forum/#!forum/coala-devel\n",
    "\n",
    "   -  coala-devel@googlegroups.com\n",
    "\n",
    "-  *coala* announcement list:\n",
    "   https://groups.google.com/forum/#!forum/coala-announcements\n",
    "\n",
    "   -  coala-announcements@googlegroups.com\n",
    "\n",
    "-  Join us on our developer chatroom:\n",
    "   https://gitter.im/coala-analyzer/coala\n",
    "-  Run our tests. Just follow the instructions on the\n",
    "   :doc:`Testing <../Getting_Involved/Testing>` page. Report back to us if\n",
    "   anything goes wrong unexpectedly.\n",
    "-  Give us feedback. If you think we're doing something useless or\n",
    "   useful with some specific things, please write us! We are interested\n",
    "   in your needs and favors so you get the highest possible quality.\n",
    "-  Drive bug discussions. Just state your opinion, everywhere!\n",
    "-  Review code. Get a glance at what we're doing and say something if\n",
    "   you don't understand something or think we're doing something wrong.\n",
    "-  Write documentation. If you need some additional information for\n",
    "   documenting feel free to ask us!\n",
    "-  Write code. Usually code we need is indicated through bug reports.\n",
    "   Please get in contact with us so we can coordinate coding together.\n",
    "\n",
    "Please take a look at the other files in this directory for getting\n",
    "started with specific parts of *coala*.\n",
    "\n",
    "We appreciate any help. (Partially with words, partially with chocolate\n",
    "if you live near hamburg.)\n",
    "\n",
    "Modularity, clean good code as well as a high usability for both users\n",
    "and developers of analyse routines (called bears) stand in the\n",
    "foreground of the development. We will not speed up our development if\n",
    "it needs sacrificing any aspect of quality.\n"
  ],
  "/home/tushar/coala/docs/Getting_Involved/Review.rst": [
    "Reviewing\n",
    "=========\n",
    "\n",
    "This document is a guide to *coala*'s review process. It will be extended\n",
    "over time.\n",
    "\n",
    "Review Process\n",
    "--------------\n",
    "\n",
    "The review process for *coala* is as follows:\n",
    "\n",
    "1. Anyone can submit commits for review. This usually happens on WIP\n",
    "   branches, submitting goes via GitHub Pull Requests.\n",
    "2. A reviewer reviews every commit by its own and validates that every\n",
    "   commit is a good change and does not destroy anything.\n",
    "3. If a commit does not fulfill the expectations of the reviewer, go to\n",
    "   step one.\n",
    "4. If the commits are not linearly mergeable into master, rebase and go\n",
    "   to step one.\n",
    "5. All commits are acknowledged and fit linearly onto master. All\n",
    "   continuous integration services (as described below) pass. Anyone\n",
    "   with collaborator permission may leave the ``@rultor merge`` command\n",
    "   to get the PR merged automatically.\n",
    "\n",
    "Continous Integration\n",
    "---------------------\n",
    "\n",
    "It is only allowed to merge a pull request into master if all of the\n",
    "following apply:\n",
    "\n",
    "-  The build/tests pass on all services. (circleci, appveyor)\n",
    "-  Scrutinizer shows passed. (That is: no new issues, no new classes\n",
    "   with rating D or worse, project quality metric may only get better.)\n",
    "-  All statements and branches are covered by your tests. (codecov.io)\n",
    "\n",
    "The coverage values may go down by a commit, however this is to be\n",
    "avoided. Tests must work for every commit.\n",
    "\n",
    "Continuous integration is always done for the last commit on a pull\n",
    "request.\n",
    "\n",
    "Reviewing Commits\n",
    "-----------------\n",
    "\n",
    "-  Generated code is not intended to be reviewed. Instead rather try to\n",
    "   verify that the generation was done right. The commit message should\n",
    "   expose that.\n",
    "-  Every commit is reviewed independently from the other commits.\n",
    "-  Tests should pass for each commit. If you suspect that tests might\n",
    "   not pass and a commit is not checked by continuous integration, try\n",
    "   running the tests locally.\n",
    "-  Check the surroundings. In many cases people forget to remove the\n",
    "   import when removing the use of something or similar things. It is\n",
    "   usually good to take a look at the whole file to see if it's still\n",
    "   consistent.\n",
    "-  Check the commit message.\n",
    "-  Take a look at continuous integration results in the end even if they\n",
    "   pass:\n",
    "-  Coverage shall not fall.\n",
    "-  Scrutinizer oftentimes yields helpful results.\n"
  ],
  "/home/tushar/coala/docs/Getting_Involved/Testing.rst": [
    "Testing\n",
    "=======\n",
    "\n",
    "You can help us testing *coala* in several ways.\n",
    "\n",
    "Executing our Tests\n",
    "-------------------\n",
    "\n",
    "*coala* has a big test suite. It is meant to work on every platform on\n",
    "every PC. If you just execute our tests you are doing us a favor.\n",
    "\n",
    "To run tests, you first need to install some dependencies. This can be\n",
    "done by executing:\n",
    "\n",
    "::\n",
    "\n",
    "    $ pip3 install -r test-requirements.txt\n",
    "\n",
    "You can then execute our tests with\n",
    "\n",
    "::\n",
    "\n",
    "    $ py.test\n",
    "\n",
    ".. note::\n",
    "    If ``py.test`` seems to give errors, try running ``python3 -m pytest``\n",
    "    instead.\n",
    "\n",
    "and report any errors you get!\n",
    "\n",
    "To run our tests, you can also use ``python3 setup.py test``\n",
    "\n",
    ".. note::\n",
    "\n",
    "    If you need to customize test running, you can get more options\n",
    "    about allowing skipped tests, getting code coverage displayed\n",
    "    or omitting/selecting tests using ``py.test`` directly.\n",
    "\n",
    "    ::\n",
    "\n",
    "        $ py.test --help\n",
    "\n",
    ".. note::\n",
    "\n",
    "    You will not get a test coverage of 100% - the coverage on the\n",
    "    website is merged for several python versions.\n",
    "\n",
    "Using test coverage\n",
    "-------------------\n",
    "\n",
    "To get coverage information, you can run:\n",
    "\n",
    "::\n",
    "\n",
    "    $ py.test --cov\n",
    "\n",
    "You can view the coverage report as html by running:\n",
    "\n",
    "::\n",
    "\n",
    "    $ py.test --cov --cov-report html\n",
    "\n",
    "The html report will be saved ``.htmlreport`` inside the *coala* repository.\n"
  ],
  "/home/tushar/coala/docs/Getting_Involved/Writing_Documentation.rst": [
    "Writing Documentation\n",
    "=====================\n",
    "\n",
    "This document gives a short introduction on how to write documentation\n",
    "for the *coala* project.\n",
    "\n",
    "Documentation is written in reStructuredText and rendered by readthedocs.org to\n",
    "our lovely users. You can view the current documentation on\n",
    "http://coala.rtfd.org.\n",
    "\n",
    "After getting the *coala* source code (see :doc:`Installation\n",
    "Instructions <../Users/Install>`), you can start hacking on\n",
    "existent documentation files. They reside in the ``docs`` directory and\n",
    "are written in reStructuredText.\n",
    "\n",
    "If you want to add new pages, you need to alter the ``index.rst`` file\n",
    "in the *coala* ``docs`` directory. Please read\n",
    "http://www.sphinx-doc.org/en/stable/markup/toctree.html#toctree-directive\n",
    "for an explanation of the syntax.\n",
    "\n",
    "You can test the documentation locally through simply running\n",
    "``make html`` in the *coala* ``docs`` directory. This generates\n",
    "``docs\\_build\\html\\index.html`` that you can view on your browser. (Use\n",
    "``pip3 install sphinx`` if you do not have ``sphinx`` yet.)\n"
  ],
  "/home/tushar/coala/docs/Getting_Involved/Writing_Good_Commits.rst": [
    "Introduction\n",
    "============\n",
    "\n",
    "At *coala* we are looking heavily at the maintainability of the code.\n",
    "\n",
    "    Code is more often read than written!\n",
    "\n",
    "It is obvious that we need good code. In order to do that we are\n",
    "verifying that every change to our code (i.e. the commits) is making it\n",
    "better.\n",
    "\n",
    "What Makes a Good Commit\n",
    "------------------------\n",
    "\n",
    "A good commit is atomic. It describes but only one logical change and\n",
    "not more. Why do we do that? Because we find more bugs if we do! Also it\n",
    "features a good commit message.\n",
    "\n",
    "How to Write Good Commit Messages\n",
    "---------------------------------\n",
    "\n",
    "A commit message consists of 3 parts - The shortlog (short description),\n",
    "the long description and the issue reference. There should have an empty\n",
    "line between each section.\n",
    "\n",
    "::\n",
    "\n",
    "    This is the shortlog - one line only\n",
    "\n",
    "    This is the long description which can extend to multiple lines\n",
    "    of text.\n",
    "\n",
    "    And can have multiple paragraphs which explain things in more\n",
    "    detail too.\n",
    "\n",
    "    Next is the issue reference\n",
    "\n",
    "Shortlog\n",
    "~~~~~~~~\n",
    "\n",
    "Example:\n",
    "\n",
    "::\n",
    "\n",
    "    setup: Install .coafile via package_data\n",
    "\n",
    "-  Maximum of 50 characters.\n",
    "-  Should describe the *change* - the action being done in the commit.\n",
    "-  Should have a tag and and a short description separated by a colon (``:``)\n",
    "\n",
    "   -  **Tag**\n",
    "\n",
    "      -  The file or class or package being modified.\n",
    "      -  Not mandatory.\n",
    "\n",
    "   -  **Short Description**\n",
    "\n",
    "      - Starts with a capital letter.\n",
    "      - Written in imperative present tense (i.e. ``Add something``, not\n",
    "        ``Adding something`` or ``Added something``).\n",
    "      - No trailing period.\n",
    "\n",
    "Long Description\n",
    "~~~~~~~~~~~~~~~~\n",
    "\n",
    "Example:\n",
    "\n",
    "::\n",
    "\n",
    "    When installing the .coafile to distutils.sysconfig.get_python_lib, we\n",
    "    ignore that this is not the installation directory in every case. Thus\n",
    "    it is easier, more reliable and platform independent to let distutils\n",
    "    install it by itself.\n",
    "\n",
    "-  Maximum of 72 chars excluding newline for *each* line.\n",
    "-  Not mandatory - but helps explain what you're doing.\n",
    "-  Should describe the reasoning for your changes. This is especially\n",
    "   important for complex changes that are not self explanatory. This is also\n",
    "   the right place to write about related bugs.\n",
    "\n",
    "Issue reference\n",
    "~~~~~~~~~~~~~~~\n",
    "\n",
    "Example:\n",
    "\n",
    "::\n",
    "\n",
    "    Fixes https://github.com/coala-analyzer/coala/issues/269\n",
    "\n",
    "-  Should use the ``Fixes`` keyword.\n",
    "-  Should use full URL to the issue.\n",
    "-  There should be a single space between the ``Fixes`` and the URL.\n",
    "\n",
    ".. note::\n",
    "\n",
    "    -  The issue reference will automatically add the link of the commit in\n",
    "       the issue.\n",
    "    -  It will also automatically close the issue when the commit is\n",
    "       accepted into *coala*.\n",
    "\n",
    ".. seealso::\n",
    "\n",
    "    https://wiki.gnome.org/Git/CommitMessages\n",
    "\n",
    "Example\n",
    "~~~~~~~\n",
    "Example 1:\n",
    "::\n",
    "\n",
    "    setup: Install .coafile via package_data\n",
    "\n",
    "    When installing the .coafile to distutils.sysconfig.get_python_lib, we\n",
    "    ignore that this is not the installation directory in every case. Thus\n",
    "    it is easier, more reliable and platform independent to let distutils\n",
    "    install it by itself.\n",
    "\n",
    "    Fixes https://github.com/coala-analyzer/coala/issues/269\n",
    "\n",
    "Example 2:\n",
    "::\n",
    "\n",
    "    Readme: Fix typo begining -> beginning\n",
    "\n",
    "    Fix a minor typo in the file for better readability.\n",
    "\n",
    "    Fixes https://github.com/coala-analyzer/coala/issues/xxx\n",
    "\n",
    "Why Do We Need Good Commits?\n",
    "----------------------------\n",
    "\n",
    "-  An atomic commit is way easier to review. The reviewer thus will be\n",
    "   able to review faster and find more bugs due to the lower complexity\n",
    "   of the change.\n",
    "-  Atomic commits are like good objects in object oriented programming -\n",
    "   you can split up a bigger thing into many small objects. Reducing\n",
    "   complexity is the key to developing good software and finding its bug\n",
    "   before they occur.\n",
    "-  Good commit messages make it easy to check at a glance what happened\n",
    "   in a time range.\n",
    "-  It is way easier to revert single changes without side effects.\n",
    "   Reverting multiple commits at a time is easy, reverting a part of a\n",
    "   commit is not.\n",
    "-  ``git blame`` will be much more effective. It is the best\n",
    "   documentation you can get. The older your code is, the more\n",
    "   documentation it has. The better the commit messages are, the better\n",
    "   is your hidden documentation. Your commit messages document the\n",
    "   reason for every single change you did to any line.\n",
    "-  ``git bisect`` will be much more effective. If you bisect through\n",
    "   atomic commits to find the commit which caused a bug, you should be\n",
    "   able to identify the real cause of the bug fastly. Good commit\n",
    "   messages and atomicity of commits are key to that ability.\n"
  ],
  "/home/tushar/coala/docs/Getting_Involved/Writing_Tests.rst": [
    "Introduction\n",
    "============\n",
    "\n",
    "Tests are an essential element to check if your written components in\n",
    "*coala* really do work like they should. Even when you think \"I really\n",
    "looked over my code, no need for tests\" you are wrong! Bugs introduced\n",
    "when not writing tests are often the most horrible ones, they have the\n",
    "characteristic to be undiscoverable (or only discoverable after dozens\n",
    "of hours of searching). Try to test as much as possible! The more tests\n",
    "you write the more you can be sure you did everything correct.\n",
    "Especially if someone else modifies your component, he can be sure with\n",
    "your tests that he doesn't introduce a bug. Keep these points in your mind\n",
    "when you're writing a test:\n",
    "\n",
    "- 100% test-coverage\n",
    "- zero redundancy\n",
    "\n",
    "A patch will not be accepted unless there is a 100% branch coverage.\n",
    "Redundant tests are a waste of effort because you are testing the same piece\n",
    "of code again and again, which is unnecessary.\n",
    "\n",
    "Actually Writing a Test\n",
    "-----------------------\n",
    "\n",
    "So how do you implement a test in *coala*? First up, tests are placed into\n",
    "the ``coala-bears/tests`` (if you want to write a test for a bear) or\n",
    "``coala/tests`` (if you test a component written for the coalib)\n",
    "directory. They are also written in python (version 3) and get\n",
    "automatically executed by running:\n",
    "\n",
    "::\n",
    "\n",
    "    $ py.test\n",
    "\n",
    "There's only one constraint:\n",
    "The name of the test file has to end with ``Test.py`` (for example\n",
    "``MyCustomTest.py``, but not ``MyCustomTestSuite.py``).\n",
    "\n",
    ".. note::\n",
    "    If ``py.test`` seems to give errors, try running ``python3 -m pytest``\n",
    "    instead.\n",
    "\n",
    ".. note::\n",
    "\n",
    "    Often you don't want to run all available tests. To run your\n",
    "    specific one, type (in the *coala* root folder):\n",
    "\n",
    "    .. code:: shell\n",
    "\n",
    "        $ py.test -k <your-test>\n",
    "\n",
    "    You can even give partial names or queries like \"not MyCustomTest\"\n",
    "    to not run a specific test. More information can be got with\n",
    "    ``py.test -h``\n",
    "\n",
    "Coming to the test file structure. Every test script starts with your\n",
    "imports. According to the *coala* code style (and pep8 style) we first do\n",
    "system imports (like ``re`` or ``subprocessing``), followed by first party\n",
    "imports (like ``coalib.result.Result``).\n",
    "\n",
    "Then the actual test suite class follows, that contains the tests. Each\n",
    "test suite is made up of test cases, where the test suite checks the\n",
    "overall functionality of your component by invoking each test case.\n",
    "\n",
    "The basic declaration for a test suite class is as follows:\n",
    "\n",
    ".. code:: python\n",
    "\n",
    "    class YourComponentTest(unittest.TestCase):\n",
    "        # Your test cases.\n",
    "        pass\n",
    "\n",
    "You should derive your test suite from ``unittest.TestCase`` to have\n",
    "access to the ``setUp()`` and ``tearDown()`` functions (covered in\n",
    "section below: **``setUp()`` and ``tearDown()``**) and also to the\n",
    "assertion functions.\n",
    "\n",
    "Now to the test cases: To implement a test case, just declare a class\n",
    "member function without parameters, starting with ``test_``. Easy, isn't\n",
    "it?\n",
    "\n",
    ".. code:: python\n",
    "\n",
    "    class YourComponentTest(unittest.TestCase):\n",
    "        # Tests somethin'.\n",
    "        def test_case1(self):\n",
    "            pass\n",
    "\n",
    "        # Doesn't test, this is just a member function, since the function name\n",
    "        # does not start with 'test_'.\n",
    "        def not_testing(self):\n",
    "            pass\n",
    "\n",
    "But how do you actually test if your component is correct? For that\n",
    "purpose you have asserts. Asserts check whether a condition is fulfilled\n",
    "and pass the result to the overall test-suite-invoking-instance, that\n",
    "manages all tests in *coala*. The result is processed and you get a\n",
    "message if something went wrong in your test.\n",
    "\n",
    ".. seealso::\n",
    "\n",
    "    `unittest assert-methods <https://docs.python.org/3/library/unittest.html#assert-methods>`_\n",
    "        Documentation on the assert functions from python's inbuilt unittest.\n",
    "\n",
    "So an example test that succeeds would be:\n",
    "\n",
    ".. code:: python\n",
    "\n",
    "    # The sys import and setup is not needed here because this example doesn't\n",
    "    # use coala components.\n",
    "    import unittest\n",
    "\n",
    "\n",
    "    class YourComponentTest(unittest.TestCase):\n",
    "        # Tests somethin'.\n",
    "        def test_case1(self):\n",
    "            # Does '1' equal '1'? Interestingly it does... mysterious...\n",
    "            self.assertEqual(1, 1)\n",
    "            # Hm yeah, True is True.\n",
    "            self.assertTrue(True)\n",
    "\n",
    ".. note::\n",
    "\n",
    "    Tests in *coala* are evaluated against their coverage, means how many\n",
    "    statements will be executed from your component when invoking your\n",
    "    test cases. A branch coverage of 100% is needed for any commit in\n",
    "    order to be pushed to master - please ask us on gitter if you need\n",
    "    help raising your coverage!\n",
    "\n",
    "\n",
    "    The branch coverage can be measured locally with the\n",
    "    ``py.test --cov`` command.\n",
    "\n",
    "    .. seealso::\n",
    "\n",
    "        Module :doc:`Executing Tests <Testing>`\n",
    "            Documentation of running Tests with coverage\n",
    "\n",
    "    As our coverage is measured across builds against several python\n",
    "    versions (we need version specific branches here and there) you will\n",
    "    not get the full coverage locally! Simply make a pull request to get\n",
    "    the coverage measured automatically.\n",
    "\n",
    "    If some code is untestable, you need to mark your component code\n",
    "    with ``# pragma: no cover``. Important: Provide a reason why your\n",
    "    code is untestable. Code coverage is measured using python 3.3 and\n",
    "    3.4 on linux.\n",
    "\n",
    "    .. code:: python\n",
    "\n",
    "        # Reason why this function is untestable.\n",
    "        def untestable_func(): # pragma: no cover\n",
    "            # Untestable code.\n",
    "            pass\n",
    "\n",
    "``setUp()`` and ``tearDown()``\n",
    "------------------------------\n",
    "\n",
    "Often you reuse components or need to make an inital setup for your\n",
    "tests. For that purpose the function ``setUp()`` exists. Just declare it\n",
    "inside your test suite and it is invoked automatically once at test\n",
    "suite startup:\n",
    "\n",
    ".. code:: python\n",
    "\n",
    "    class YourComponentTest(unittest.TestCase):\n",
    "        def setUp(self):\n",
    "            # Your initialization of constants, operating system API calls etc.\n",
    "            pass\n",
    "\n",
    "The opposite from this is the ``tearDown()`` function. It gets invoked\n",
    "when the test suite finished running all test cases. Declare it like\n",
    "``setUp()`` before:\n",
    "\n",
    ".. code:: python\n",
    "\n",
    "    class YourComponentTest(unittest.TestCase):\n",
    "        def tearDown(self):\n",
    "            # Deinitialization, release calls etc.\n",
    "            pass\n",
    "\n",
    "Kickstart\n",
    "---------\n",
    "\n",
    "This section contains a concluding and simple example that you can use\n",
    "as a kickstart for test-writing.\n",
    "\n",
    "Put the code under the desired folder inside ``tests``,\n",
    "modify it to let it test your stuff and run the test from\n",
    "the *coala* root folder ``py.test``.\n",
    "\n",
    ".. code:: python\n",
    "\n",
    "    # Import here your needed system components.\n",
    "    import sys\n",
    "    import unittest\n",
    "\n",
    "    # Import here your needed coala components.\n",
    "\n",
    "\n",
    "    # Your test unit. The name of this class is displayed in the test\n",
    "    # evaluation.\n",
    "    class YourTest(unittest.TestCase):\n",
    "        def setUp(self):\n",
    "            # Here you can set up your stuff. For example constant values,\n",
    "            # initializations etc.\n",
    "            pass\n",
    "\n",
    "        def tearDown(self):\n",
    "            # Here you clean up your stuff initialized in setUp(). For example\n",
    "            # deleting arrays, call operating system API etc.\n",
    "            pass\n",
    "\n",
    "        def test_case1(self):\n",
    "            # A test method. Put your test code here.\n",
    "            pass\n"
  ],
  "/home/tushar/coala/docs/Users/Exit_Codes.rst": [
    "Exit Codes\n",
    "==========\n",
    "\n",
    "The following is a list of ``coala``'s exit codes and their meanings:\n",
    "\n",
    "-  ``0`` - ``coala`` executed successfully but yielded no results.\n",
    "-  ``1`` - ``coala`` executed successfully but yielded results.\n",
    "-  ``2`` - Invalid arguments were passed to ``coala`` in the command line.\n",
    "-  ``3`` - The file collector exits with this code if an invalid pattern\n",
    "   is passed to it.\n",
    "-  ``4`` - ``coala`` was executed with an unsupported version of python\n",
    "-  ``5`` - ``coala`` executed successfully. Results were found but patches\n",
    "   to the results were applied successfully\n",
    "-  ``13`` - There is a conflict in the version of a dependency you have\n",
    "   installed and the requirements of ``coala``.\n",
    "-  ``130`` - A ``KeyboardInterrupt`` (``Ctrl+C``) was pressed during the\n",
    "   execution of ``coala``.\n",
    "-  ``255`` - Any other general errors.\n"
  ],
  "/home/tushar/coala/docs/Users/External_APIs.rst": [
    "External APIs\n",
    "=============\n",
    "\n",
    "Use *coala* to make your application better.\n",
    "\n",
    "DBus\n",
    "----\n",
    "\n",
    "The *coala* DBus API essentially creates a server which can have multiple\n",
    "clients connected to it. The clients communicate to the *coala* server\n",
    "using DBus. To start the server, first install *coala* and then simple run\n",
    "``coala-dbus``.\n",
    "\n",
    "This spawns a bus with the name ``org.coala_analyzer.v1`` as a\n",
    "SessionBus and can be verified and tested using a DBus debugger like\n",
    "`DFeet <https://wiki.gnome.org/Apps/DFeet>`__. The bus has 1 object-path\n",
    "by default - ``/org/coala_analyzer/v1``. This is the first point of\n",
    "contact with *coala* for any client.\n",
    "\n",
    "The object-path ``/org/coala_analyzer/v1`` has the interface\n",
    "``org.coala_analyzer.v1`` which contains the two methods -\n",
    "``CreateDocument`` and ``DisposeDocument``. These are used to tell *coala*\n",
    "about the documents you wish to analyze.\n",
    "\n",
    "``CreateDocument``\n",
    "~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "**Args**: the path of the document\n",
    "\n",
    "**Returns**: object-path for the document\n",
    "\n",
    "A document is defined by it's path. The path should be a absolute path,\n",
    "not a relative one. This method returns an object-path which will be\n",
    "hence forth used to interact with that document.\n",
    "\n",
    "``DisposeDocument``\n",
    "~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "**Args**: the path to the document\n",
    "\n",
    "**Returns**: none\n",
    "\n",
    "It disposes the object-path corresponding to the given path.\n",
    "\n",
    "Now, the object-path returned by the ``CreateDocument`` method also has\n",
    "the interface ``org.coala_analyzer.v1``. This interface is used to\n",
    "handle which config file *coala* will use to analyze the document, and the\n",
    "function to get analysis results. It contains 4 functions:\n",
    "\n",
    "``GetConfigFile``\n",
    "~~~~~~~~~~~~~~~~~\n",
    "\n",
    "**Args**: none\n",
    "\n",
    "**Returns**: the config file path\n",
    "\n",
    "``SetConfigFile``\n",
    "~~~~~~~~~~~~~~~~~\n",
    "\n",
    "**Args**: the config file path\n",
    "\n",
    "**Returns**: the config path which is set after it executes.\n",
    "\n",
    "``FindConfigFile``\n",
    "~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "**Args**: the config file path\n",
    "\n",
    "**Returns**: the config path which is set after it executes.\n",
    "\n",
    "It attempts to find the config file related to the file by searching in\n",
    "parent directories till it finds a ``.coafile``.\n",
    "\n",
    "``Analyze``\n",
    "~~~~~~~~~~~\n",
    "\n",
    "**Args**: none\n",
    "\n",
    "**Returns**: an array of DBus structures containing:\n",
    "\n",
    "* The name of the section\n",
    "* Boolean which is true if all bears in the section executed successfully\n",
    "* List of results where each result is a list which contains:\n",
    "  (str)origin, (str)message, (str)file, (str)line\\_nr, (str)severity\n"
  ],
  "/home/tushar/coala/docs/Users/Git_Hooks.rst": [
    "\ufeffGit Hooks\n",
    "=========\n",
    "\n",
    "This document is a guide on how to add *coala* as a git hook. Using git hooks\n",
    "*coala* can be executed automatically, ensuring your code follows your quality\n",
    "requirements.\n",
    "\n",
    "Pre Commit Hooks\n",
    "----------------\n",
    "\n",
    "The pre-commit hook can be used to run *coala* before every commit action.\n",
    "Hence, this does not allow any code not following the quality standars\n",
    "specified unless it's done by force.\n",
    "\n",
    "To enable this, just create the file ``.git/hooks/pre-commit`` under your\n",
    "repository and add the lines:\n",
    "\n",
    ".. code:: bash\n",
    "\n",
    "    $ #!/bin/sh\n",
    "    $ set -e\n",
    "    $ coala\n",
    "\n",
    "You can also specify arguments like ``-S autoapply=false`` which tells\n",
    "*coala* to not apply any patch by itself. Or you can run specific sections with\n",
    "``coala <section_name>``.\n",
    "\n",
    ".. seealso::\n",
    "\n",
    "    Module :doc:`Tutorial for Users <Tutorials/Tutorial>`\n",
    "        Documentation on how to run *coala* which introduces the CLI arguments.\n",
    "\n",
    "    Module :doc:`coafile Specification <coafile>`\n",
    "        Documentation on how to configure *coala* using the coafile\n",
    "        specification.\n",
    "\n",
    ".. note::\n",
    "\n",
    "    If you allow *coala* to auto apply patches, it's recommended to add\n",
    "    `*.orig` to your .gitignore. *coala* creates these files while applying\n",
    "    patches and they could be erroneously added to your commit.\n",
    "\n",
    "This file needs to be executable. If it is not (or if you aren't sure), you\n",
    "can make it executable by:\n",
    "\n",
    ".. code:: bash\n",
    "\n",
    "    $ chmod +x .git/hooks/pre-commit\n",
    "\n",
    "and you\u2019re done! It will run every time before you commit, and prevent\n",
    "you from committing if the code has any errors.\n"
  ],
  "/home/tushar/coala/docs/Users/Glob_Patterns.rst": [
    "Glob - Extended unix style pathname expansion\n",
    "=============================================\n",
    "\n",
    "In *coala*, files and directories are specified by file name. To allow\n",
    "input of multiple files without requiring a large number of filenames,\n",
    "*coala* supports a number of wildcards. These are based on the unix-style\n",
    "glob syntax and they are *not* the same as regular expressions.\n",
    "\n",
    ".. note::\n",
    "\n",
    "    Any glob that does not start with a ``/`` in Linux or a drive letter\n",
    "    ``X:`` in Windows will be interpreted as a relative path. Please use comma\n",
    "    separated values instead of absolute path globs that start with a\n",
    "    glob expression.\n",
    "\n",
    "Syntax\n",
    "------\n",
    "\n",
    "The special characters used in shell-style wildcards are:\n",
    "\n",
    "+-------------------+---------------------------------------------------------+\n",
    "| PATTERN           | MEANING                                                 |\n",
    "+===================+=========================================================+\n",
    "| ``[seq]``         | Matches any character in seq. Cannot be empty. Any      |\n",
    "|                   | special character looses its special meaning in a set.  |\n",
    "+-------------------+---------------------------------------------------------+\n",
    "| ``[!seq]``        | Matches any character not in seq. Cannot be empty. Any  |\n",
    "|                   | special character looses its special meaning in a set.  |\n",
    "+-------------------+---------------------------------------------------------+\n",
    "| ``(seq_a|seq_b)`` | Matches either sequence_a or sequence_b as a whole. More|\n",
    "|                   | than two or just one sequence can be given.             |\n",
    "+-------------------+---------------------------------------------------------+\n",
    "| ``?``             | Matches any single character.                           |\n",
    "+-------------------+---------------------------------------------------------+\n",
    "| ``*``             | Matches everything but the directory separator.         |\n",
    "+-------------------+---------------------------------------------------------+\n",
    "| ``**``            | Matches everything.                                     |\n",
    "+-------------------+---------------------------------------------------------+\n",
    "\n",
    "Examples\n",
    "--------\n",
    "\n",
    "``[seq]``\n",
    "~~~~~~~~~\n",
    "\n",
    "    Matches any character in seq. Cannot be empty. Any special character\n",
    "    looses its special meaning in a set.\n",
    "\n",
    "Opening and closing brackets can be part of a set, although closing\n",
    "brackets have to be placed at the first position.\n",
    "\n",
    "::\n",
    "\n",
    "    >>> from coalib.parsing.Globbing import fnmatch\n",
    "    >>> fnmatch(\"aaa\", \"a[abc]a\")\n",
    "    True\n",
    "    >>> fnmatch(\"aaa\", \"a[bcd]a\")\n",
    "    False\n",
    "    >>> fnmatch(\"aaa\", \"a[a]]a\")\n",
    "    False\n",
    "    >>> fnmatch(\"aa]a\", \"a[a]]a\")\n",
    "    True\n",
    "    >>> fnmatch(\"aaa\", \"a[]abc]a\")\n",
    "    True\n",
    "    >>> fnmatch(\"aaa\", \"a[[a]a\")\n",
    "    True\n",
    "    >>> fnmatch(\"a[a\", \"a[[a]a\")\n",
    "    True\n",
    "    >>> fnmatch(\"a]a\", \"a[]]a\")\n",
    "    True\n",
    "    >>> fnmatch(\"aa\", \"a[]a\")\n",
    "    False\n",
    "    >>> fnmatch(\"a[]a\", \"a[]a\")\n",
    "    True\n",
    "\n",
    "``[!seq]``\n",
    "~~~~~~~~~~\n",
    "\n",
    "    Matches any character not in seq. Cannot be empty. Any special\n",
    "    character looses its special meaning in a set.\n",
    "\n",
    "::\n",
    "\n",
    "    >>> fnmatch(\"aaa\", \"a[!a]a\")\n",
    "    False\n",
    "    >>> fnmatch(\"aaa\", \"a[!b]a\")\n",
    "    True\n",
    "    >>> fnmatch(\"aaa\", \"a[b!b]a\")\n",
    "    False\n",
    "    >>> fnmatch(\"a!a\", \"a[b!b]a\")\n",
    "    True\n",
    "    >>> fnmatch(\"a!a\", \"a[!]a\")\n",
    "    False\n",
    "    >>> fnmatch(\"aa\", \"a[!]a\")\n",
    "    False\n",
    "    >>> fnmatch(\"a[!]a\", \"a[!]a\")\n",
    "    True\n",
    "\n",
    "``(seq\\_a\\|seq\\_b)``\n",
    "~~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "    Matches either sequence\\_a or sequence\\_b as a whole. More than two\n",
    "    or just one sequence can be given.\n",
    "\n",
    "Parentheses cannot be part of an alternative, unless they are escaped by\n",
    "brackets. Parentheses that have no match are ignored as well as\n",
    "``|``-separators that are not inside matching parentheses.\n",
    "\n",
    "::\n",
    "\n",
    "    >>> fnmatch(\"aXb\", \"a(X|Y)b\")\n",
    "    True\n",
    "    >>> fnmatch(\"aYb\", \"a(X|Y)b\")\n",
    "    True\n",
    "    >>> fnmatch(\"aZb\", \"a(X|Y)b\")\n",
    "    False\n",
    "    >>> fnmatch(\"aXb\", \"(a(X|Y)b|c)\")\n",
    "    True\n",
    "    >>> fnmatch(\"c\", \"(a(X|Y)b|c)\")\n",
    "    True\n",
    "    >>> fnmatch(\"a\", \"a|b\")\n",
    "    False\n",
    "    >>> fnmatch(\"a|b\", \"a|b\")\n",
    "    True\n",
    "    >>> fnmatch(\"(a|b\", \"(a|b\")\n",
    "    True\n",
    "    >>> fnmatch(\"(aa\", \"(a(a|b)\")\n",
    "    True\n",
    "    >>> fnmatch(\"a(a\", \"(a(a|b)\")\n",
    "    False\n",
    "    >>> fnmatch(\"a(a\", \"(a[(]a|b)\")\n",
    "    True\n",
    "    >>> fnmatch(\"aa\", \"a()a\")\n",
    "    True\n",
    "    >>> fnmatch(\"\", \"(abc|)\")\n",
    "    True\n",
    "\n",
    "``?``\n",
    "~~~~~\n",
    "\n",
    "    Matches any single character.\n",
    "\n",
    "::\n",
    "\n",
    "    >>> fnmatch(\"abc\", \"a?c\")\n",
    "    True\n",
    "    >>> fnmatch(\"abbc\", \"a?c\")\n",
    "    False\n",
    "    >>> fnmatch(\"a/c\", \"a?c\")\n",
    "    True\n",
    "    >>> fnmatch(\"a\\\\c\", \"a?c\")\n",
    "    True\n",
    "    >>> fnmatch(\"a?c\", \"a?c\")\n",
    "    True\n",
    "    >>> fnmatch(\"ac\", \"a?c\")\n",
    "    False\n",
    "\n",
    "``\\*``\n",
    "~~~~~~\n",
    "\n",
    "    Matches everything but the directory separator.\n",
    "\n",
    ".. note::\n",
    "\n",
    "    The directory separator is platform specific. ``/`` is never\n",
    "    matched by ``\\*``. ``\\\\`` is matched on Linux, but not on Windows.\n",
    "\n",
    "::\n",
    "\n",
    "    >>> fnmatch(\"abc\", \"a*c\")\n",
    "    True\n",
    "    >>> fnmatch(\"abbc\", \"a*c\")\n",
    "    True\n",
    "    >>> fnmatch(\"a/c\", \"a*c\")\n",
    "    False\n",
    "    >>> fnmatch(\"a?c\", \"a*c\")\n",
    "    True\n",
    "    >>> fnmatch(\"ac\", \"a*c\")\n",
    "    True\n",
    "\n",
    "``\\*\\*``\n",
    "~~~~~~~~\n",
    "\n",
    "    Matches everything.\n",
    "\n",
    "::\n",
    "\n",
    "    >>> fnmatch(\"abc\", \"a**c\")\n",
    "    True\n",
    "    >>> fnmatch(\"abbc\", \"a**c\")\n",
    "    True\n",
    "    >>> fnmatch(\"a/c\", \"a**c\")\n",
    "    True\n",
    "    >>> fnmatch(\"a?c\", \"a**c\")\n",
    "    True\n",
    "    >>> fnmatch(\"ac\", \"a**c\")\n",
    "    True\n"
  ],
  "/home/tushar/coala/docs/Users/Install.rst": [
    "\ufeffcoala Installation\n",
    "==================\n",
    "\n",
    "This document contains information on how to install *coala*. Supported\n",
    "platforms are Linux and Windows. *coala* is known to work on OS X as well.\n",
    "*coala* is tested against CPython 3.3, 3.4 and 3.5.\n",
    "\n",
    "In order to run *coala* you need to install Python. It is recommended,\n",
    "that you install Python3 >= 3.3 from http://www.python.org.\n",
    "\n",
    "The easiest way to install *coala* is using pip (Pip Installs Packages).\n",
    "If you don't already have pip, you can install it like described on\n",
    "https://pip.pypa.io/en/stable/installing.html. Note that pip is shipped\n",
    "with recent python versions by default.\n",
    "\n",
    "System wide installation\n",
    "------------------------\n",
    "\n",
    "The simplest way to install *coala* is to do it system-wide. But, This is\n",
    "generally discouraged in favor or using a virtualenv.\n",
    "\n",
    "To install the latest most stable version of *coala* and supported bears\n",
    "system-wide, use:\n",
    "\n",
    "::\n",
    "\n",
    "    $ pip3 install coala-bears\n",
    "\n",
    ".. note::\n",
    "\n",
    "    For this and all future steps, some steps require root access\n",
    "    (also known as administrative privileges in Windows).\n",
    "\n",
    "    **Unix based** (Mac, Linux) - This can be achieved by using ``sudo``\n",
    "    in front of the command ``sudo command_name`` instead of\n",
    "    ``command_name``\n",
    "\n",
    "    **Windows** - The easiest way on windows is to start a\n",
    "    command prompt as an administrator and start ``setup.py``.\n",
    "\n",
    "To install the nightly build from our master branch, you can do:\n",
    "\n",
    "::\n",
    "\n",
    "    $ pip3 install coala-bears --pre\n",
    "\n",
    "To install only *coala* (without any bears), you can do:\n",
    "\n",
    "::\n",
    "\n",
    "    $ pip3 install coala\n",
    "\n",
    "With ``--pre`` you can install the nightly build of the *coala* base\n",
    "without bears.\n",
    "\n",
    "Installing inside a virtualenv\n",
    "------------------------------\n",
    "\n",
    "Virtualenv is probably what you want to use during development,\n",
    "you\u2019ll probably want to use it there, too. You can read more about\n",
    "it at their documentation - http://virtualenv.readthedocs.org\n",
    "\n",
    "First, we need to install virtualenv to the system. This can be done\n",
    "with ``pip3`` easily:\n",
    "\n",
    "::\n",
    "\n",
    "    $ pip3 install virtualenv\n",
    "\n",
    "Once you have virtualenv installed, just fire up a shell and create\n",
    "your own environment. I usually create a project folder and a ``venv``\n",
    "folder:\n",
    "\n",
    "::\n",
    "\n",
    "    $ virtualenv venv\n",
    "\n",
    "Now, whenever you want to work on the project, you only have to activate\n",
    "the corresponding environment.\n",
    "\n",
    "    On **Unix based** systems (OSX and Linux) this can be done with:\n",
    "\n",
    "    ::\n",
    "\n",
    "        $ source venv/bin/activate\n",
    "\n",
    "    And on **Windows** this is done with:\n",
    "\n",
    "    ::\n",
    "\n",
    "        $ venv\\scripts\\activate\n",
    "\n",
    "Finally, you install *coala* and supported bears inside the activated\n",
    "virtualenv with:\n",
    "\n",
    "::\n",
    "\n",
    "    $ pip3 install coala-bears\n",
    "\n",
    "Installing coala from source\n",
    "----------------------------\n",
    "\n",
    "In order to install *coala* from source, it is recommended to install git.\n",
    "See http://git-scm.com/ for further information and a downloadable\n",
    "installer or use your package manager on linux to get it.\n",
    "\n",
    ".. note::\n",
    "\n",
    "    Again, here it is recommended to install *coala* inside a virtualenv.\n",
    "    This can be done by creating a virtualenv and running the installation\n",
    "    commands after the virtualenv has been activated.\n",
    "\n",
    "After having git installed, you can download the source code of *coala*\n",
    "with the following command:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git clone https://github.com/coala-analyzer/coala-bears/\n",
    "    $ cd coala-bears\n",
    "\n",
    "You can now install *coala* with a simple:\n",
    "\n",
    "::\n",
    "\n",
    "    $ python3 setup.py install\n",
    "\n",
    "For the above to work, you may also need to install `setuptools` which can be\n",
    "installed by running\n",
    "\n",
    "::\n",
    "\n",
    "    $ pip3 install setuptools\n",
    "\n",
    "You will have *coala* installed into your python scripts directory. On an\n",
    "unixoid system it is probably already available on your command line\n",
    "globally.\n",
    "\n",
    "You may also install a development version of *coala* to test and make\n",
    "changes easily. To do this run:\n",
    "\n",
    "::\n",
    "\n",
    "    $ python3 setup.py develop\n",
    "\n",
    "This essentially lets you install *coala* in a way that allows you to make\n",
    "changes to the code and see the changes take effect immediately.\n",
    "\n",
    "Alternate installation\n",
    "~~~~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "If you want to install coala to an alternate location you can e.g. call\n",
    "``python3 setup.py install --prefix=/your/prefix/location``. Other\n",
    "options are documented on\n",
    "https://docs.python.org/3.3/install/#alternate-installation.\n",
    "\n",
    ".. note::\n",
    "\n",
    "    If you are using a proxy, follow these steps:\n",
    "\n",
    "    -  Set up your system-wide proxy.\n",
    "    -  Use ``sudo -E pip3 install coala`` (the ``-E`` flag takes the\n",
    "       existing environment variables into the ``sudo`` environment).\n",
    "\n",
    "    You could also set your pip.conf file to use a proxy, to know more\n",
    "    read\n",
    "    http://stackoverflow.com/questions/14149422/using-pip-behind-a-proxy\n",
    "    for further clarification.\n",
    "\n",
    "Error handling\n",
    "~~~~~~~~~~~~~~~~\n",
    "\n",
    "In case you are getting\n",
    "``ValueError:('Expected version spec in', 'appdirs ~=1.4.0', 'at', ' ~=1.4.0')``\n",
    "then don't panic. It happens when you are using an outdated version of pip\n",
    "that doesn't support our version specifiers yet.\n",
    "\n",
    "\n",
    "    Ideally, you have to create a virtual environment with a newer pip:\n",
    "\n",
    "    ::\n",
    "\n",
    "        $ pip3 install virtualenv\n",
    "        $ virtualenv -p python3 ~/venvs/coala\n",
    "        $ . ~/venv/coala/bin/activate\n",
    "        $ pip install -U pip\n",
    "        $ pip install coala-bears\n",
    "\n",
    "You have to activate this virtualenv on every terminal session you want to use\n",
    "coala though (tip: add it to bashrc!)\n",
    "\n",
    "Dependencies\n",
    "------------\n",
    "\n",
    "This section lists dependencies of *coala* that are not automatically\n",
    "installed. On Windows, you can get many with ``nuget``\n",
    "(https://www.nuget.org/), on Mac Homebrew will help you installing\n",
    "dependencies (http://brew.sh/).\n",
    "\n",
    "JS Dependencies\n",
    "~~~~~~~~~~~~~~~\n",
    "\n",
    "coala features a lot of bears that use linters written in JavaScript. In\n",
    "order for them to be usable, you need to install them via ``npm``\n",
    "(http://nodejs.org/):\n",
    "\n",
    "::\n",
    "\n",
    "    $ npm install -g jshint alex remark dockerfile_lint csslint coffeelint\n",
    "\n",
    "If a bear still doesn't work for you, please make sure that you have a\n",
    "recent version of ``npm`` installed. Many linux distributions ship a\n",
    "very old one.\n",
    "\n",
    ".. note::\n",
    "\n",
    "    If using *coala* from source you can just do ``npm install`` or\n",
    "    ``npm install -g`` to use the ``package.json`` which is shipped with\n",
    "    coala.\n",
    "\n",
    "Binary Dependencies\n",
    "~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "Some bears need some dependencies available:\n",
    "\n",
    "-  PHPLintBear: Install ``php``\n",
    "-  GNUIndentBear: Install ``indent`` (be sure to use GNU Indent, Mac ships\n",
    "   a non-GNU version that lacks some functionality.)\n",
    "-  CSharpLintBear: Install ``mono-mcs``\n",
    "\n",
    "Clang\n",
    "~~~~~\n",
    "\n",
    "*coala* features some bears that make use of Clang. In order for them to\n",
    "work, you need to install libclang:\n",
    "\n",
    "-  Ubuntu: ``apt-get install libclang1``\n",
    "-  Fedora: ``dnf install clang-libs`` (Use ``yum`` instead of ``dnf`` on\n",
    "   Fedora 21 or lower.)\n",
    "-  ArchLinux: ``pacman -Sy clang``\n",
    "-  Windows: ``nuget install ClangSharp``\n",
    "-  OSX: ``brew install llvm --with-clang``\n",
    "\n",
    "If those do not help you, search for a package that contains\n",
    "``libclang.so``.\n",
    "\n",
    "On windows, you need to execute this command to add the libclang path to\n",
    "the *PATH* variable permanently (you need to be an administrator):\n",
    "\n",
    "``setx PATH \"%PATH%;%cd%\\ClangSharp.XXX\\content\\x86\" \\M``\n",
    "\n",
    "For x86 python or for x64 python:\n",
    "\n",
    "``setx PATH \"%PATH%;%cd%\\ClangSharp.XXX\\content\\x64\" \\M``\n",
    "\n",
    "Replace \"XXX\" with the ClangSharp version you received from nuget.\n",
    "\n",
    "Generating Documentation\n",
    "~~~~~~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "*coala* documentation can be generated by fetching the documentation\n",
    "requirements. This can be achieved by\n",
    "\n",
    "::\n",
    "\n",
    "    $ pip3 install -r docs-requirements.txt\n",
    "\n",
    "To generate the documentation coala uses `sphinx`. Documentation can be\n",
    "generated by running the following command:\n",
    "\n",
    "::\n",
    "\n",
    "    $ python3 setup.py docs\n",
    "\n",
    "You can then open ``docs\\_build\\html\\index.html`` in your favourite\n",
    "browser.\n",
    "\n",
    "See :doc:`Writing Documentation <../Getting_Involved/Writing_Documentation>`\n",
    "for more information.\n"
  ],
  "/home/tushar/coala/docs/Users/Tutorials/Auto_Completion.rst": [
    "Auto completion\n",
    "===============\n",
    "\n",
    "If you're using bash or zsh you can setup them to have coala auto command\n",
    "completion.\n",
    "\n",
    "Bash\n",
    "----\n",
    "\n",
    "You have to install ``argcomplete``\n",
    "\n",
    "::\n",
    "\n",
    "    $ pip install argcomplete\n",
    "\n",
    "After this you have to either activate it\n",
    "`globally <https://github.com/kislyuk/argcomplete#activating-global-completion>`__\n",
    "or add\n",
    "\n",
    "::\n",
    "\n",
    "    eval \"$(register-python-argcomplete `which coala`)\"\n",
    "\n",
    "to your ``.bashrc``. Just make sure that coala is added to the path at that\n",
    "point. If you want, or you are unsure if coala is in the PATH, you can expand\n",
    "``\\`which coala\\``` to the path of your coala executable (you can find where it\n",
    "is by running ``which coala``.\n",
    "\n",
    "Zsh\n",
    "---\n",
    "\n",
    "You have to take the same steps as with bash (only add setting to your\n",
    "``.zshrc`` instead of ``.bashrc``). Also, add to your ``.zshrc``:\n",
    "\n",
    "::\n",
    "\n",
    "    autoload bashcompinit\n",
    "    bashcompinit\n"
  ],
  "/home/tushar/coala/docs/Users/Tutorials/Git_Help.rst": [
    "Git tutorial\n",
    "============\n",
    "\n",
    "This tutorial will help you understand how git works and how to use git to\n",
    "submit your commit on Github.\n",
    "\n",
    ".. note::\n",
    "    This tutorial is about using Git in bash/cmd, which we highly recommend,\n",
    "    as it's cleaner.\n",
    "    Github is a totally different thing, it is the web interface or app.\n",
    "\n",
    "How to install Git\n",
    "------------------\n",
    "\n",
    "First step is installing Git. Supposing you are on a Debian based distribution,\n",
    "this will do:\n",
    "\n",
    "::\n",
    "\n",
    "    $ sudo apt-get install git-all\n",
    "\n",
    "Getting started with coala\n",
    "--------------------------\n",
    "\n",
    "First of all, you have to fork the repository you are going to contribute to.\n",
    "This will basically give you a clone of the repository to your own repository.\n",
    "You can do this by opening `this to fork the *coala* website <https://github.com/coala-analyzer/coala>`_\n",
    "or `this to fork the *coala-bears* website <https://github.com/coala-analyzer/coala-bears>`_\n",
    "and then clicking 'Fork' in the upper right corner.\n",
    "\n",
    "Grabbing coala on your local machine\n",
    "------------------------------------\n",
    "\n",
    "Now you should clone the repository to your local machine so that you can have\n",
    "access to all the code and start fixing issues!\n",
    "To do this, you can use these to clone the *coala* / *coala-bears* repositories:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git clone https://github.com/coala-analyzer/coala\n",
    "\n",
    "or\n",
    "\n",
    "::\n",
    "\n",
    "    $ git clone https://github.com/coala-analyzer/coala-bears\n",
    "\n",
    "You should ideally clone the fork so that gets set to 'origin' automatically.\n",
    "Now you have all your code on your local machine!\n",
    "\n",
    "Getting to work\n",
    "---------------\n",
    "\n",
    "First let's talk about remotes. To communicate with the outside world, git uses\n",
    "what are called remotes. These are repositories other than the one on your local\n",
    "disk which you can push your changes into (so that other people can see them) or\n",
    "pull from (so that you can get others changes).\n",
    "Now you should add a remote to your local machine so that you can ``pull`` and\n",
    "``push`` your commits. This can be simply done by using the command:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git remote add myfork <your_fork_link>\n",
    "\n",
    ".. note::\n",
    "  **myfork** is just a name we used for simplicity. You can\n",
    "  name it however you want.\n",
    "\n",
    "Creating a new branch\n",
    "---------------------\n",
    "\n",
    "To start working on an issue, you first need to create a new branch where you\n",
    "will work.\n",
    "\n",
    "::\n",
    "\n",
    "    $ git checkout -b branchname\n",
    "\n",
    ".. note::\n",
    "\n",
    "    ``checkout`` will switch to the newly created branch.\n",
    "\n",
    "    ``-b`` will create a new branch if the branch doesn't already exist.\n",
    "\n",
    "Checking your work\n",
    "------------------\n",
    "\n",
    "After the issue is fixed and you have tested it (tests are very important!\n",
    "never submit a change that isn't tested), you should check your progress. Type:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git status\n",
    "\n",
    "It will give you an idea about what files are currently modified.\n",
    "\n",
    ".. note::\n",
    "\n",
    "    Tip: If there's something you don't find, you can always use:\n",
    "\n",
    "    ``$ git grep \"syntax\"``\n",
    "\n",
    "    This will search through the whole repository and show you the files\n",
    "    that contain the syntax.\n",
    "\n",
    ".. seealso::\n",
    "    For more information about tests, check `this link <http://coala.readthedocs.org/en/latest/Getting_Involved/Writing_Tests.html>`_.\n",
    "\n",
    "Adding the files and commiting\n",
    "------------------------------\n",
    "\n",
    "Now you can add your files/folders to the current commit:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git add <file/folder_name>\n",
    "\n",
    "Do this until you have added all the files needed for your commit.\n",
    "Then type:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git commit\n",
    "\n",
    "This will lead you to a text editor. Now you need to write your commit message.\n",
    "We are very strict about writing commit messages as they help us keep *coala*\n",
    "**clean** and **stable**. Commit messages usually consists of three main\n",
    "parts. They should have a newline between them.\n",
    "\n",
    "- **The header**\n",
    "\n",
    "  The header should have the name of the file that you have made the change on,\n",
    "  followed by \":\", a space, and then a short title that explains the change\n",
    "  made.\n",
    "\n",
    "  Example: `.gitignore: Add a new Constants variable`\n",
    "\n",
    "- **The body**\n",
    "\n",
    "  The body should have a short paragraph that briefly describes the change\n",
    "  that was made, and the reason why this change was needed in imperative.\n",
    "  Its maximum length is 50 characters.\n",
    "\n",
    "- **The issue that is being fixed**\n",
    "\n",
    "  This part will usually have \"Fixes <issue_link>\", so the issue gets referenced\n",
    "  on github.\n",
    "\n",
    ".. seealso::\n",
    "\n",
    "  For more information about writing commit messages, check this\n",
    "  `link <http://coala.readthedocs.org/en/latest/Getting_Involved/Writing_Good_Commits.html>`_.\n",
    "\n",
    "Now that your message is written, you will have to save the file. Press escape\n",
    "to exit insert mode, and save the file (in Vim that is being done by pressing\n",
    "shift + Z twice).\n",
    "\n",
    "Pushing the commit\n",
    "------------------\n",
    "\n",
    "Now you will need to push the commit to the fork. All you have to do is:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git push myfork\n",
    "\n",
    "It will most likely ask for your login credentials from github. Type them in,\n",
    "and your commit will be pushed online.\n",
    "\n",
    "Creating a Pull Request\n",
    "-----------------------\n",
    "\n",
    "Now you would like to get your commit into the actual master branch. Making\n",
    "your changes available to all future users of the project. For this, you will\n",
    "have to create a Pull Request. To do this, you will have to go on github, on\n",
    "your fork page. You should change to branch to the one you have worked on and\n",
    "submitted the commit on. Now you can create a Pull Request by clicking\n",
    "``New Pull Request`` button in the pull request tab.\n",
    "\n",
    "**Congratulations!** You have just created your first Pull Request!\n",
    "You are awesome!\n",
    "\n",
    ".. note::\n",
    "    If you see any error like ``1 commit ahead of the master branch`` you need\n",
    "    to sync your local fork with the remote repository before sending\n",
    "    a pull request.\n",
    "\n",
    "    More information regarding syncing can be found `here <http://coala.readthedocs.org/en/latest/Users/Tutorials/Git_Help.html#keeping-your-fork-in-sync>`_.\n",
    "\n",
    "Follow-up\n",
    "---------\n",
    "\n",
    "Now after you have created the Pull Request, there are two possibilities:\n",
    "\n",
    "- your PR will get accepted, and your commit will get merged into the master\n",
    "  branch - sadly, this rarely happens on the first Pull Request\n",
    "\n",
    "- your PR will be rejected. There are 2 cases when a PR is rejected:\n",
    "\n",
    "      - Test fails\n",
    "      - Reviewer wants something changed (This also causes gitmate to fail)\n",
    "\n",
    "It's highly unlikely that your PR will be accepted on the first attempt - but\n",
    "don't worry that's just how it works. It helps us keeping *coala*\n",
    "**clean** and **stable**.\n",
    "\n",
    ".. seealso::\n",
    "\n",
    "     `Review Process <http://coala.readthedocs.org/en/latest/Getting_Involved/Review.html>`_.\n",
    "\n",
    "Now if you need to modify your code, you can simply edit it again, add it and\n",
    "commit it using\n",
    "\n",
    "::\n",
    "\n",
    "    $ git commit -a --amend\n",
    "\n",
    "This will edit your last commit message. If your commit message was considered\n",
    "fine by our reviewers, you can simply send it again like this. If not, edit it\n",
    "and send it.\n",
    "Now you have successfully edited your last commit!\n",
    "\n",
    "Keeping your fork in sync\n",
    "-------------------------\n",
    "\n",
    "As people work on *coala* new commits will be added. This will result in your\n",
    "local fork going out of sync with the remote repository.\n",
    "To sync your changes with the remote repository run the following commands in\n",
    "the desired branch:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git fetch origin\n",
    "    $ git rebase origin/master\n",
    "\n",
    "This will fetch the commits from the remote repository and will merge it into\n",
    "the branch where you are currently working, and move all of the local commits\n",
    "that are ahead of the rebased branch to the top of the history on that branch.\n",
    "\n",
    ".. note::\n",
    "\n",
    "    After following these instructions when you try to push to remote you may\n",
    "    get fast-forwarding error. If that is the case, then you will have to\n",
    "    force push since you are attempting to rewrite the git commit history.\n",
    "    To do that append the ``--force`` argument in the push command:\n",
    "\n",
    "    ``$ git push myfork --force``\n",
    "\n",
    "    **Warning:** Never force-push on the master branch, or any branch not\n",
    "    owned by you.\n",
    "\n",
    "Squashing your commits\n",
    "-------------------------\n",
    "\n",
    "It's possible that you have more than one commits which you want them to be\n",
    "squashed into single commit. You can take your series of commits and squash\n",
    "them down into a single commit with the interactive rebasing tool. To squash\n",
    "your commits run the following command:\n",
    "\n",
    "::\n",
    "\n",
    "    $ git rebase -i master\n",
    "\n",
    ".. note::\n",
    "\n",
    "    master is the SHA1 hash of the commit before which you want to squash all\n",
    "    the commits and make sure that rebase is done onto master branch.\n",
    "\n",
    "An editor will be fired up with all the commits in your current branch (ignoring\n",
    "merge commits), which come after the given commit. Keep the first one as \"pick\"\n",
    "and on the second and subsequent commits with \"squash\". After saving, another\n",
    "editor will be fired up with all the messages of commits which you want to\n",
    "squash. Clean up all the messages and add a new message which you want to be\n",
    "displayed for the single commit.\n",
    "\n",
    "Useful Git commands\n",
    "-------------------\n",
    "\n",
    "This section will briefly explain some other Git commands you will most likely\n",
    "use and will really make your work easier.\n",
    "\n",
    "::\n",
    "\n",
    "    $ git config\n",
    "\n",
    "The ``git config`` command lets you configure your Git installation (or an\n",
    "individual repository) from the command line. This command can define\n",
    "everything from user info to preferences to the behavior of a repository.\n",
    "\n",
    "::\n",
    "\n",
    "    $ git log\n",
    "\n",
    "The ``git log`` command displays committed snapshots. It lets you list the\n",
    "project history, filter it, and search for specific changes. While git status\n",
    "lets you inspect the working directory and the staging area, git log only\n",
    "operates on the committed history.\n",
    "\n",
    "::\n",
    "\n",
    "    $ git push --force myfork\n",
    "\n",
    "While we normally use ``git push myfork`` to push your commit to your fork,\n",
    "after further editing and work on your commit, you will need to use the\n",
    "``--force`` parameter to your push to automatically update your Pull Request.\n",
    "\n",
    "::\n",
    "\n",
    "    $ git reset --hard\n",
    "\n",
    "Reset the staging area and the working directory to match the most recent\n",
    "commit. In addition to unstaging changes, the ``--hard`` flag tells Git to\n",
    "overwrite all changes in the working directory, too. Put another way: this\n",
    "obliterates all uncommitted changes, so make sure you really want to throw\n",
    "away your local developments before using it.\n",
    "\n",
    "::\n",
    "\n",
    "    $ git clean\n",
    "\n",
    "The ``git clean`` command removes untracked files from your working directory.\n",
    "This is really more of a convenience command, since it\u2019s trivial to see which\n",
    "files are untracked with git status and remove them manually. Like an ordinary\n",
    "rm command, ``git clean`` is not undoable, so make sure you really want to\n",
    "delete the untracked files before you run it.\n",
    "\n",
    "::\n",
    "\n",
    "    $ git checkout <branch>\n",
    "\n",
    "The ``git checkout`` command is used to switch to another branch in the\n",
    "repository. Here <branch> is the name of the branch you want to switch to.\n",
    "\n",
    "::\n",
    "\n",
    "    $ git rebase\n",
    "\n",
    "Rebasing is the process of moving a branch to a new base commit. From a content\n",
    "perspective, rebasing really is just moving a branch from one commit to another.\n",
    "But internally, Git accomplishes this by creating new commits and applying them\n",
    "to the specified base\u2014it\u2019s literally rewriting your project history. It\u2019s very\n",
    "important to understand that, even though the branch looks the same, it\u2019s\n",
    "composed of entirely new commits.\n",
    "\n",
    "\n",
    "::\n",
    "\n",
    "    $ git rebase -i\n",
    "\n",
    "Running ``git rebase`` with the -i flag begins an interactive rebasing session.\n",
    "Instead of blindly moving all of the commits to the new base, interactive\n",
    "rebasing gives you the opportunity to alter individual commits in the process.\n",
    "This lets you clean up history by removing, splitting, and altering an existing\n",
    "series of commits. It\u2019s like ``git commit --amend`` on steroids.\n",
    "Usage is ``$ git rebase -i <base>``. Rebase the current branch onto <base>, but\n",
    "use an interactive rebasing session. This opens an editor where you can enter\n",
    "commands (described below) for each commit to be rebased. These commands\n",
    "determine how individual commits will be transferred to the new base. You can\n",
    "also reorder the commit listing to change the order of the commits themselves.\n"
  ],
  "/home/tushar/coala/docs/Users/Tutorials/Linter_Bears.rst": [
    "Linter Bears\n",
    "============\n",
    "\n",
    "Welcome. This tutorial aims to show you how to use the ``@linter`` decorator in\n",
    "order to integrate linters in your bears.\n",
    "\n",
    "Why is This Useful?\n",
    "-------------------\n",
    "\n",
    "A lot of programming languages already have linters implemented, so if your\n",
    "project uses a language that does not already have a linter Bear you might\n",
    "need to implement it on your own. Don't worry, it's easy!\n",
    "\n",
    "What do we Need?\n",
    "----------------\n",
    "\n",
    "First of all, we need the linter executable that we are going to use.\n",
    "In this tutorial we will build the PylintTutorialBear so we need Pylint, a\n",
    "common linter for Python. It can be found `here <https://www.pylint.org/>`__.\n",
    "Since it is a python package we can go ahead and install it with\n",
    "\n",
    "::\n",
    "\n",
    "    $ pip3 install pylint\n",
    "\n",
    "Writing the Bear\n",
    "----------------\n",
    "\n",
    "To write a linter bear, we need to create a class that interfaces with our\n",
    "linter-bear infrastructure, that is provided via the ``@linter`` decorator.\n",
    "\n",
    "::\n",
    "\n",
    "    from coalib.bearlib.abstractions.Linter import linter\n",
    "\n",
    "    @linter(executable='pylint')\n",
    "    class PylintTutorialBear:\n",
    "        pass\n",
    "\n",
    "As you can see ``pylint`` is already provided as an executable name which gets\n",
    "invoked on the files you are going to lint. This is a mandatory argument for\n",
    "the decorator.\n",
    "\n",
    "The linter class is only capable of processing one file at a time, for this\n",
    "purpose ``pylint`` or the external tool needs to be invoked every time with the\n",
    "appropriate parameters. This is done inside ``create_arguments``,\n",
    "\n",
    "::\n",
    "\n",
    "    @linter(executable='pylint')\n",
    "    class PylintTutorialBear:\n",
    "        @staticmethod\n",
    "        def create_arguments(filename, file, config_file):\n",
    "            pass\n",
    "\n",
    "``create_arguments`` accepts three parameters:\n",
    "\n",
    "- ``filename``: The absolute path to the file that gets processed.\n",
    "- ``file``: The contents of the file to process, given as a list of lines\n",
    "  (including the return character).\n",
    "- ``config_file``: The absolute path to a config file to use. If no config file\n",
    "  is used, this parameter is ``None``. More on that later.\n",
    "\n",
    "You can use these parameters to construct the command line arguments. The\n",
    "linter expects from you to return an argument sequence here. A tuple is\n",
    "preferred. We will do this soon for ``PylintTutorialBear``.\n",
    "\n",
    "So which are the exact command line arguments we need to provide? It depends on\n",
    "the output format of the linter. The ``@linter`` decorator is capable of\n",
    "handling different output formats:\n",
    "\n",
    "- ``regex``: This parses issue messages yielded by the underlying executable.\n",
    "- ``corrected``: Auto-generates results from a fixed/corrected file provided by\n",
    "  the tool.\n",
    "\n",
    "In this tutorial we are going to use the ``regex`` output format. But before we\n",
    "continue with modifying our bear, we need to figure out how exactly output from\n",
    "Pylint looks like so we can parse it accordingly.\n",
    "\n",
    "We get some promising output when invoking Pylint with\n",
    "\n",
    "::\n",
    "\n",
    "    $ pylint --msg-template=\"L{line}C{column}: {msg_id} - {msg}\" --reports=n\n",
    "\n",
    "Sample output looks like this:\n",
    "\n",
    "::\n",
    "\n",
    "    No config file found, using default configuration\n",
    "    ************* Module coalib.bearlib.abstractions.Linter\n",
    "    L1C0: C0111 - Missing module docstring\n",
    "    L42C48: E1101 - Class 'Enum' has no 'reverse' member\n",
    "    L77C32: E1101 - Class 'Enum' has no 'reverse' member\n",
    "    L21C0: R0912 - Too many branches (16/12)\n",
    "    L121C28: W0613 - Unused argument 'filename'\n",
    "\n",
    "This is something we can parse easily with a regex. So let's implement\n",
    "everything we've found out so far:\n",
    "\n",
    "::\n",
    "\n",
    "    @linter(executable='pylint',\n",
    "            output_format='regex',\n",
    "            output_regex=r'L(?P<line>\\d+)C(?P<column>\\d+): (?P<message>.*)')\n",
    "    class PylintTutorialBear:\n",
    "        @staticmethod\n",
    "        def create_arguments(filename, file, config_file):\n",
    "            return ('--msg_template=\"L{line}C{column}: {msg_id} - {msg}\"',\n",
    "                    '--reports=n', filename)\n",
    "\n",
    "As you can see, the ``output_regex`` parameter consists of named groups. These\n",
    "are important to construct a meaningful result that contains the information\n",
    "that is printed out.\n",
    "\n",
    "For the exact list of named groups ``@linter`` recognizes, see the API\n",
    "documentation.\n",
    "\n",
    "For more info generally on regexes, see `Python re module\n",
    "<https://docs.python.org/3/library/re.html>`_.\n",
    "\n",
    "Let's brush up our ``output_regex`` a bit to use even more information:\n",
    "\n",
    "::\n",
    "\n",
    "    @linter(...\n",
    "            output_regex=r'L(?P<line>\\d+)C(?P<column>\\d+): '\n",
    "                         r'(?P<message>(?P<origin>.\\d+) - .*)'),\n",
    "            ...)\n",
    "\n",
    "Now we use the issue identification as the origin so we are able to deactivate\n",
    "single rules via ignore statements inside code.\n",
    "\n",
    "This class is already fully functional and allows to parse issues yielded by\n",
    "Pylint!\n",
    "\n",
    "Using Severities\n",
    "----------------\n",
    "\n",
    "*coala* uses three types of severities, that categorize the importance of a\n",
    "result:\n",
    "\n",
    "-  INFO\n",
    "-  NORMAL\n",
    "-  MAJOR\n",
    "\n",
    "which are defined in ``coalib.results.RESULT_SEVERITY``. Pylint output contains\n",
    "severity information we can use:\n",
    "\n",
    "::\n",
    "\n",
    "    L1C0: C0111 - Missing module docstring\n",
    "\n",
    "The letter before the error code is the severity. In order to make use of the\n",
    "severity, we need to define it inside the ``output_regex`` parameter using the\n",
    "named group ``severity``:\n",
    "\n",
    "::\n",
    "\n",
    "    @linter(...\n",
    "            output_regex=r'L(?P<line>\\d+)C(?P<column>\\d+): (?P<message>'\n",
    "                         r'(?P<origin>(?P<severity>[WFECRI])\\d+) - .*)',\n",
    "            ...)\n",
    "\n",
    "So we want to take up the severities denoted by the letters ``W``, ``F``,\n",
    "``E``, ``C``, ``R`` or ``I``. In order to use this severity value, we will\n",
    "first have to provide a map that takes the matched severity letter and maps it\n",
    "to a severity value of ``coalib.results.RESULT_SEVERITY`` so *coala*\n",
    "understands it. This is possible via the ``severity_map`` parameter of\n",
    "``@linter``:\n",
    "\n",
    "::\n",
    "\n",
    "    from coalib.results.RESULT_SEVERITY import RESULT_SEVERITY\n",
    "\n",
    "    @linter(...\n",
    "            severity_map={'W': RESULT_SEVERITY.NORMAL,\n",
    "                          'F': RESULT_SEVERITY.MAJOR,\n",
    "                          'E': RESULT_SEVERITY.MAJOR,\n",
    "                          'C': RESULT_SEVERITY.NORMAL,\n",
    "                          'R': RESULT_SEVERITY.NORMAL,\n",
    "                          'I': RESULT_SEVERITY.INFO},\n",
    "            ...)\n",
    "\n",
    "``coalib.results.RESULT_SEVERITY`` contains three different values, ``Info``,\n",
    "``Warning`` and ``Error`` you can use.\n",
    "\n",
    "We can test our bear like this\n",
    "\n",
    "::\n",
    "\n",
    "    $ coala --bear-dirs=. --bears=PylintTutorialBear --files=sample.py\n",
    "\n",
    ".. note::\n",
    "\n",
    "    In order for the above command to work we should have 2 files in\n",
    "    our current dir: ``PylintTutorialBear.py`` and our ``sample.py``.\n",
    "    Naming is **very** important in *coala*. *coala* will look for bears\n",
    "    by their **filename** and display them based on their\n",
    "    **classname**.\n",
    "\n",
    "Using the ``corrected`` Output Format\n",
    "-------------------------------------\n",
    "\n",
    "This output format is very simple to use and doesn't require further setup from\n",
    "your side inside the bear:\n",
    "\n",
    "::\n",
    "\n",
    "    @linter(...\n",
    "            output_format='corrected')\n",
    "\n",
    "If your underlying tool generates a corrected file, the class automatically\n",
    "generates patches for the changes made and yields results accordingly.\n",
    "\n",
    "Adding Settings to our Bear\n",
    "---------------------------\n",
    "\n",
    "If we run\n",
    "\n",
    "::\n",
    "\n",
    "    $ pylint --help\n",
    "\n",
    "We can see that there is a ``--rcfile`` option which lets us specify a\n",
    "configuration file for Pylint. Let's add that functionality to our bear.\n",
    "\n",
    "::\n",
    "\n",
    "    import os\n",
    "\n",
    "    from coalib.bearlib.abstractions.Linter import linter\n",
    "    from coalib.results.RESULT_SEVERITY import RESULT_SEVERITY\n",
    "\n",
    "    @linter(executable='pylint',\n",
    "            output_format='regex',\n",
    "            output_regex=r'L(?P<line>\\d+)C(?P<column>\\d+): '\n",
    "                         r'(?P<message>(?P<severity>[WFECRI]).*)',\n",
    "            severity_map={'W': RESULT_SEVERITY.NORMAL,\n",
    "                          'F': RESULT_SEVERITY.MAJOR,\n",
    "                          'E': RESULT_SEVERITY.MAJOR,\n",
    "                          'C': RESULT_SEVERITY.NORMAL,\n",
    "                          'R': RESULT_SEVERITY.NORMAL,\n",
    "                          'I': RESULT_SEVERITY.INFO})\n",
    "    class PylintTutorialBear:\n",
    "        @staticmethod\n",
    "        def create_arguments(filename, file, config_file,\n",
    "                             pylint_rcfile: str=os.devnull):\n",
    "            return ('--msg_template=\"L{line}C{column}: {msg_id} - {msg}\"',\n",
    "                    '--reports=n', '--rcfile=' + pylint_rcfile, filename)\n",
    "\n",
    "Just adding the needed parameter to the ``create_arguments`` signature\n",
    "suffices, like you would do for other bears inside ``run``! Additional\n",
    "parameters are automatically queried from the coafile. Let's add also some\n",
    "documentation together with the ``LANGUAGE`` attribute:\n",
    "\n",
    "::\n",
    "\n",
    "    @linter(...)\n",
    "    class PylintTutorialBear:\n",
    "        \"\"\"\n",
    "        Lints your Python files!\n",
    "\n",
    "        Check for codings standards (like well-formed variable names), detects\n",
    "        semantical errors (like true implementation of declared interfaces or\n",
    "        membership via type inference), duplicated code.\n",
    "\n",
    "        See http://pylint-messages.wikidot.com/all-messages for a list of all\n",
    "        checks and error codes.\n",
    "        \"\"\"\n",
    "\n",
    "        LANGUAGE = (\"Python\", \"Python 2\", \"Python 3\")\n",
    "\n",
    "        @staticmethod\n",
    "        def create_arguments(filename, file, config_file,\n",
    "                             pylint_rcfile: str=os.devnull):\n",
    "            \"\"\"\n",
    "            :param pylint_rcfile:\n",
    "                The configuration file Pylint shall use.\n",
    "            \"\"\"\n",
    "            ...\n",
    "\n",
    ".. note::\n",
    "\n",
    "    The documentation of the param is parsed by *coala* and it will be used\n",
    "    as help to the user for that specific setting.\n",
    "\n",
    "Finished Bear\n",
    "-------------\n",
    "\n",
    "Well done, you made it this far! Now you should have built a fully\n",
    "functional Python linter Bear. If you followed the code from this tutorial\n",
    "it should look something like this\n",
    "\n",
    "::\n",
    "\n",
    "    import os\n",
    "\n",
    "    from coalib.bearlib.abstractions.Linter import linter\n",
    "    from coalib.results.RESULT_SEVERITY import RESULT_SEVERITY\n",
    "\n",
    "    @linter(executable='pylint',\n",
    "            output_format='regex',\n",
    "            output_regex=r'L(?P<line>\\d+)C(?P<column>\\d+): '\n",
    "                         r'(?P<message>(?P<severity>[WFECRI]).*)',\n",
    "            severity_map={'W': RESULT_SEVERITY.NORMAL,\n",
    "                          'F': RESULT_SEVERITY.MAJOR,\n",
    "                          'E': RESULT_SEVERITY.MAJOR,\n",
    "                          'C': RESULT_SEVERITY.NORMAL,\n",
    "                          'R': RESULT_SEVERITY.NORMAL,\n",
    "                          'I': RESULT_SEVERITY.INFO})\n",
    "    class PylintTutorialBear:\n",
    "        \"\"\"\n",
    "        Lints your Python files!\n",
    "\n",
    "        Check for codings standards (like well-formed variable names), detects\n",
    "        semantical errors (like true implementation of declared interfaces or\n",
    "        membership via type inference), duplicated code.\n",
    "\n",
    "        See http://pylint-messages.wikidot.com/all-messages for a list of all\n",
    "        checks and error codes.\n",
    "\n",
    "        https://pylint.org/\n",
    "        \"\"\"\n",
    "\n",
    "        LANGUAGE = (\"Python\", \"Python 2\", \"Python 3\")\n",
    "\n",
    "        @staticmethod\n",
    "        def create_arguments(filename, file, config_file,\n",
    "                             pylint_rcfile: str=os.devnull):\n",
    "            \"\"\"\n",
    "            :param pylint_rcfile:\n",
    "                The configuration file Pylint shall use.\n",
    "            \"\"\"\n",
    "            return ('--msg_template=\"L{line}C{column}: {msg_id} - {msg}\"',\n",
    "                    '--reports=n', '--rcfile=' + pylint_rcfile, filename)\n",
    "\n",
    "Running and Testing our Bear\n",
    "----------------------------\n",
    "\n",
    "By running\n",
    "\n",
    "::\n",
    "\n",
    "    $ coala --bear-dirs=. --bears=PylintTutorialBear -B\n",
    "\n",
    "We can see that our Bear setting is documented properly. To use *coala*\n",
    "with our Bear on `sample.py` we run\n",
    "\n",
    "::\n",
    "\n",
    "    $ coala --bear-dirs=. --bears=PylintTutorialBear --files=sample.py\n",
    "\n",
    "To use our `pylint_rcfile` setting we can do\n",
    "\n",
    "::\n",
    "\n",
    "    $ coala --bear-dirs=. --bears=PythonTutorialBear \\\n",
    "    > -S rcfile=my_rcfile --files=sample.py\n",
    "\n",
    "You now know how to write a linter Bear and also how to use it in your\n",
    "project.\n",
    "\n",
    "Congratulations!\n",
    "\n",
    "Where to Find More...\n",
    "---------------------\n",
    "\n",
    "If you need more information about the ``@linter`` decorator, refer to the API\n",
    "documentation. It's more versatile than described in this little tutorial.\n"
  ],
  "/home/tushar/coala/docs/Users/Tutorials/Self_Correcting_Bears.rst": [
    "Bears That Can Suggest And Make Corrections\n",
    "-------------------------------------------\n",
    "\n",
    "**Note**: Go through the `Linter Bears\n",
    "<http://coala.readthedocs.org/en/latest/Users/Tutorials/Linter_Bears.html>`_\n",
    "before reading this.\n",
    "\n",
    "Some executables (like ``indent`` or ``autopep8``) can generate a corrected\n",
    "file from the original. We can use such executables so that *coala*, using\n",
    "these bears, can suggest and also make automatic corrections. Here's an\n",
    "example bear. (GNUIndentBear)\n",
    "\n",
    "::\n",
    "\n",
    "    import platform\n",
    "\n",
    "    from coalib.bearlib.abstractions.Lint import Lint\n",
    "    from coalib.bearlib.spacing.SpacingHelper import SpacingHelper\n",
    "    from coalib.bears.LocalBear import LocalBear\n",
    "\n",
    "\n",
    "    class GNUIndentBear(Lint, LocalBear):\n",
    "        executable = \"indent\" if platform.system() != \"Darwin\" else \"gindent\"\n",
    "        diff_message = \"Indentation can be improved.\"\n",
    "        use_stdin = True\n",
    "        gives_corrected = True\n",
    "\n",
    "        def run(self,\n",
    "                filename,\n",
    "                file,\n",
    "                max_line_length: int=80,\n",
    "                use_spaces: bool=True,\n",
    "                tab_width: int=SpacingHelper.DEFAULT_TAB_WIDTH,\n",
    "                indent_cli_options: str=''):\n",
    "            \"\"\"\n",
    "            This bear checks and corrects spacing and indentation via the well\n",
    "            known Indent utility. It is designed to work with the C programming\n",
    "            language but may work reasonably with syntactically similar\n",
    "            languages.\n",
    "\n",
    "            :param max_line_length:    Maximum number of characters for a line.\n",
    "            :param use_spaces:         True if spaces are to be used, else\n",
    "                                       tabs.\n",
    "            :param tab_width:          Number of spaces per indent level.\n",
    "            :param indent_cli_options: Any command line options the indent\n",
    "                                       binary understands. They will be simply\n",
    "                                       passed through.\n",
    "            \"\"\"\n",
    "            self.arguments = \"--no-tabs\" if use_spaces else \"--use-tabs\"\n",
    "            self.arguments += (\" --line-length {0} --indent-level {1} \"\n",
    "                               \"--tab-size {1} {2}\".format(max_line_length,\n",
    "                                                           tab_width,\n",
    "                                                           indent_cli_options))\n",
    "            return self.lint(filename, file)\n",
    "\n",
    "\n",
    "In the example above, the important line is:\n",
    "\n",
    "::\n",
    "\n",
    "    gives_corrected = True\n",
    "\n",
    "This tells the ``Lint`` class that this bear can suggest corrections. When we\n",
    "do this, internally a ``diff`` of the original file and the generated\n",
    "'corrected file' along with some other not-important-for-this-tutorial magic\n",
    "is used to get the final output (which may be suggestions or\n",
    "auto-corrections).\n",
    "\n",
    "Let's try this bear out. Create a new file called ``sample.cpp``. Contents of\n",
    "``sample.cpp`` are:\n",
    "\n",
    "::\n",
    "\n",
    "    #include <iostream>\n",
    "    int main(){\n",
    "    if(1 == 1)\n",
    "    if(2 == 2)\n",
    "    if(3 != 4)\n",
    "    cout << \"Pun Indented.\" << endl;\n",
    "\n",
    "    return 0;\n",
    "    }\n",
    "\n",
    "And, run the following command:\n",
    "\n",
    "::\n",
    "\n",
    "    coala --bear-dirs=. --bears=GNUIndentBear --files=sample.cpp -s\n",
    "\n",
    "Make sure that both ``GNUIndentBear.py`` and ``sample.cpp`` are in your current\n",
    "folder. Also make sure that ``indent`` is installed (**not** the pip package,\n",
    "but the gnu one which can be installed using your system package manager).\n",
    "\n",
    "Now, we have a bear that is much more helpful than just a simple Linter Bear!\n"
  ],
  "/home/tushar/coala/docs/Users/Tutorials/Testing_Bears.rst": [
    "How to use LocalBearTestHelper to test your bears\n",
    "=================================================\n",
    "\n",
    "*coala* has an awesome testing framework to write tests for bears with ease.\n",
    "\n",
    "You can use the following to test your bears:\n",
    "\n",
    "- ``LocalBearTestHelper.check_validity``\n",
    "- ``LocalBearTestHelper.check_results``\n",
    "- ``verify_local_bears``\n",
    "\n",
    "Understanding through examples\n",
    "------------------------------\n",
    "\n",
    "Let us understand how to write tests for ``TooManyLinesBear`` in ``some_dir``.\n",
    "``TooManyLinesBear`` checks if a file has less than or equal to\n",
    "``max_number_of_lines`` lines. ``max_number_of_lines`` by default is 10.\n",
    "\n",
    ".. code::\n",
    "\n",
    "    from coalib.results.Result import Result\n",
    "    from coalib.bears.LocalBear import LocalBear\n",
    "\n",
    "\n",
    "    class TooManyLinesBear(LocalBear):\n",
    "\n",
    "        def run(file,\n",
    "                filename,\n",
    "                max_number_of_lines: int=10):\n",
    "            \"\"\"\n",
    "            Detects if a file has more than \"max_number_of_lines\" lines\n",
    "\n",
    "            :param max_number_of_lines    Maximum number of lines to be\n",
    "                                          allowed for a file. Default is 10.\n",
    "            \"\"\"\n",
    "\n",
    "            if(len(file)>max_number_of_lines):\n",
    "                yield Result(self, \"Too many lines\")\n",
    "\n",
    "**EXAMPLE 1** using ``verify_local_bear``\n",
    "\n",
    ".. code::\n",
    "\n",
    "    from bears.some_dir.TooManyLinesBear import TooManyLinesBear\n",
    "    from tests.LocalBearTestHelper import verify_local_bear\n",
    "\n",
    "    good_file = '1\\n2\\n3\\n4\\n'.splitlines()\n",
    "    bad_file = '1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n10\\n11\\n'.splitlines()\n",
    "\n",
    "    TooManyLinesBearTest = verify_local_bear(TooManyLinesBear,\n",
    "                                             valid_files=(good_file,),\n",
    "                                             invalid_files=(bad_file,))\n",
    "\n",
    "``good_file`` is a file which your bear considers as non-style-violating\n",
    "and a ``bad_file`` is one which has at least one error/warning/info.\n",
    "We need to write a ``good_file`` which has less than or equal to\n",
    "``max_number_of_lines`` lines and a ``bad_file`` which has more than\n",
    "``max_number_of_lines`` lines and feed them to ``verify_local_bear`` as input\n",
    "along with your bear (TooManyLinesBear in this case) and a few additional\n",
    "arguments.\n",
    "\n",
    ".. note::\n",
    "\n",
    "    ``good_file`` and ``bad_file`` are sequences just like ``file``. A ``file``\n",
    "    is a sequence of an input file.\n",
    "\n",
    "**EXAMPLE 2** using ``LocalBearTestHelper.check_validity``\n",
    "\n",
    ".. code::\n",
    "\n",
    "    from queue import Queue\n",
    "    from bears.some_dir.TooManyLinesBear import TooManyLinesBear\n",
    "\n",
    "    from tests.LocalBearTestHelper import LocalBearTestHelper\n",
    "    from coalib.settings.Section import Section\n",
    "    from coalib.settings.Setting import Setting\n",
    "\n",
    "\n",
    "    class TooManyLinesBearTest(LocalBearTestHelper):\n",
    "\n",
    "        def setUp(self):\n",
    "            self.section = Section('name')\n",
    "            self.section.append(Setting('max_number_of_lines', '10'))\n",
    "            self.uut = TooManyLinesBear(self.section, Queue())\n",
    "\n",
    "        def test_valid(self):\n",
    "            self.check_validity(self.uut, [\"import os\"])\n",
    "\n",
    "        def test_invalid(self):\n",
    "            self.check_validity(self.uut, bad_file, valid=False)\n",
    "\n",
    ".. note::\n",
    "\n",
    "    ``bad_file`` here is same as ``bad_file`` in the above example.\n",
    "\n",
    "``check_validity`` asserts if your bear yields any results for a particular\n",
    "check with a list of strings. First a *Section* and your Bear\n",
    "(in this case ``TooManyLinesBear``) is ``setUp``. Now your *Section* consists\n",
    "by default *Settings*. You can append any *Setting* depending on your test.\n",
    "Validate a check by passing your bear, lines to check as parameters\n",
    "(pass a few other parameters if necessary) to ``check_validity``. The method\n",
    "``self.check_validity(self.uut, [\"import os\"])`` asserts if your bear\n",
    "``self.uut`` yields a result when a list of strings ``[\"import os\"]`` is\n",
    "passed.\n",
    "\n",
    "**EXAMPLE 3** using ``LocalBearTestHelper.check_results``\n",
    "\n",
    ".. code::\n",
    "\n",
    "    from queue import Queue\n",
    "\n",
    "    from bears.some_dir.TooManyLinesBear import TooManyLinesBear\n",
    "    from tests.LocalBearTestHelper import LocalBearTestHelper\n",
    "    from coalib.results.Result import Result\n",
    "    from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "    class TooManyLinesBearTest(LocalBearTestHelper):\n",
    "\n",
    "        def setUp(self):\n",
    "            self.uut = TooManyLinesBear(Section('name'), Queue())\n",
    "\n",
    "        def test_run(self):\n",
    "            self.check_results(\n",
    "                self.uut,\n",
    "                file,\n",
    "                Result.from_values(\"TooManyLinesBear\",\n",
    "                                   \"Too many lines\"\n",
    "                                   settings={'max_number_of_lines': int=20}))\n",
    "\n",
    "``check_results`` asserts if your bear results match the actual\n",
    "results on execution on CLI. Just like the above example, we need to ``setUp``\n",
    "a *Section* and your Bear with some *Settings*. ``check_results`` validates\n",
    "your results by giving your local bear, lines to check and expected results\n",
    "as input. ``check_results`` asserts if your bear's results on checking the\n",
    "``file`` match with ``Results.from_values(...)``.\n",
    "\n",
    "A Final Note\n",
    "------------\n",
    "\n",
    "``LocalBearTestHelper`` is written to ease off testing for bears. Make sure\n",
    "that your tests have 100% coverage and zero redundancy. Use ``check_results``\n",
    "as much as possible to test your bears.\n"
  ],
  "/home/tushar/coala/docs/Users/Tutorials/Tutorial.rst": [
    "coala Tutorial\n",
    "==============\n",
    "\n",
    "Welcome to this little tutorial. It is meant to be a gentle introduction\n",
    "to the usage of *coala*.\n",
    "\n",
    "Prerequisites\n",
    "-------------\n",
    "\n",
    "In order to complete this tutorial you will need *coala* installed.\n",
    "(Installation is actually not required but it's more convenient and\n",
    "recommended.)\n",
    "\n",
    "Get Some Code\n",
    "-------------\n",
    "\n",
    "In order to perform a static code analysis on your code you will need\n",
    "some code to check. If you do not have own code you want to check, you\n",
    "can retrieve our tutorial samples:\n",
    "\n",
    "::\n",
    "\n",
    "    git clone https://github.com/coala-analyzer/coala-tutorial.git\n",
    "\n",
    "Please note that the commands given in this tutorial are intended for\n",
    "use with this sample code and may need minor adjustments.\n",
    "\n",
    "Let's Start!\n",
    "------------\n",
    "\n",
    "There are two options how to let *coala* know what kind of analysis it\n",
    "should perform on which code.\n",
    "\n",
    "Command Line Interface\n",
    "~~~~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "In order to specify the files to analyze, you can use the ``--files``\n",
    "argument of *coala* like demonstrated below. For all file paths, you can\n",
    "specify (recursive) globs.\n",
    "\n",
    "Because analysis routines can do many various things we named them\n",
    "*Bears*. A bear can check your code for potential problems, calculate metrics\n",
    "and even provide corrections for your code. Let's find out what bears are\n",
    "available for C:\n",
    "\n",
    "::\n",
    "\n",
    "    coala --show-language-bears C\n",
    "\n",
    "coala now lists all bears that can operate on C code. You can specify the\n",
    "kind of analysis with the ``--bears`` argument:\n",
    "\n",
    "::\n",
    "\n",
    "    cd coala-tutorial\n",
    "    coala --files=src/\\*.c --bears=SpaceConsistencyBear --save\n",
    "\n",
    "*coala* will now ask you for missing values that are needed to perform the\n",
    "analysis, which in this case is only the ``use_spaces`` setting. We\n",
    "recommend setting it to ``true``.\n",
    "\n",
    "*coala* will now check the code and, in case you use the tutorial code,\n",
    "yield two results. In the case of the SpaceConsistencyBear you will\n",
    "see trailing whitespace errors on your console.\n",
    "\n",
    "Feel free to experiment a bit. You've successfully analysed some code!\n",
    "But don't stop reading - you don't have to enter all those values again!\n",
    "\n",
    "Configuration Files\n",
    "~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "*coala* supports a very simple configuration file. If you've executed the\n",
    "instructions from the CLI section above, *coala* will already have such a\n",
    "file readily prepared for you. Go, take a look at it:\n",
    "\n",
    "::\n",
    "\n",
    "    cat .coafile\n",
    "\n",
    "This should yield something like this:\n",
    "\n",
    "::\n",
    "\n",
    "    [Default]\n",
    "    bears = SpaceConsistencyBear\n",
    "    files = src/*.c\n",
    "    use_spaces = yeah\n",
    "\n",
    "If you now invoke ``coala`` it will parse this ``.coafile`` from your\n",
    "current directory. This makes it easy to specify once for your project\n",
    "what is checked with which bears and make it available to all\n",
    "contributors.\n",
    "\n",
    "Feel free to play around with this file. You can either edit it manually\n",
    "or add/edit settings via ``coala --save ...`` invocations. If you want\n",
    "*coala* to save settings every time, you can add ``save = True`` manually\n",
    "into your ``.coafile``.\n",
    "\n",
    "Sections\n",
    "--------\n",
    "\n",
    "Thats all nice and well but we also have a Makefile for our project we\n",
    "want to check. So let us introduce another feature of our configuration\n",
    "syntax: *sections*.\n",
    "\n",
    "The line ``[Default]`` specifies that everything below will belong to\n",
    "the Default section. If nothing is specified, a setting will implicitly\n",
    "belong to this section.\n",
    "\n",
    "Let's check the line lengths of our Makefile:\n",
    "\n",
    "::\n",
    "\n",
    "    coala -S Makefiles.bears=LineLengthBear Makefiles.files=Makefile --save\n",
    "\n",
    "As you can see, the ``-S`` (or ``--settings``) option allows to specify\n",
    "arbitrary settings. Settings can be directly stored into a section with\n",
    "the ``section.setting`` syntax.\n",
    "\n",
    "By default the ``LineLengthBear`` checks whether each line contains\n",
    "``80`` chars or less in a line. To change this value, use the\n",
    "``max_line_length`` inside the ``.coafile``.\n",
    "\n",
    "*coala* will now yield any result you didn't correct last time plus a new\n",
    "one for the Makefile. This time *coala* (or better, the\n",
    "``LineLengthBear``) doesn't know how to fix the issue but still tries to\n",
    "provide as much helpful information as possible and provides you the\n",
    "option to directly open the file in an editor of your choice.\n",
    "\n",
    ".. note::\n",
    "\n",
    "    If your editor is already open this may not work, because the other\n",
    "    process will shortly communicate with the existent process and\n",
    "    return immediately. *coala* handles this for some editors\n",
    "    automatically, if your's does not work yet - please file a bug so we\n",
    "    can include it!\n",
    "\n",
    "If you changed one file in multiple results, *coala* will merge the\n",
    "changes if this is possible.\n",
    "\n",
    "*coala* should have appended something like this to your ``.coafile``:\n",
    "\n",
    "::\n",
    "\n",
    "    [Makefiles]\n",
    "    bears = LineLengthBear\n",
    "    files = Makefile\n",
    "\n",
    "As you see, sections provide a way to have different configurations for\n",
    "possibly different languages in one file. They are executed\n",
    "sequentially.\n",
    "\n",
    "Auto-applying results\n",
    "---------------------\n",
    "\n",
    "Often you don't want to look at trivial results like spacing issues. For\n",
    "that purpose *coala* includes a special setting called ``default_actions``\n",
    "that allows you to set the action for a bear that shall be automatically\n",
    "applied on run.\n",
    "\n",
    "Let's automatically fix python code. Take a look at our sample python\n",
    "code:\n",
    "\n",
    "::\n",
    "\n",
    "    $ cat src/add.py\n",
    "\n",
    "    \"\"\"\n",
    "    This is a simple library that provide a function that can add numbers.\n",
    "\n",
    "    Cheers!\n",
    "    \"\"\"\n",
    "\n",
    "\n",
    "\n",
    "    def add(a,b):\n",
    "        return a+b;\n",
    "\n",
    "    import sys\n",
    "\n",
    "That looks horrible, doesn't it? Let's fix it!\n",
    "\n",
    "::\n",
    "\n",
    "    $ coala -S python.bears=PEP8Bear python.files=\\*\\*/\\*.py \\\n",
    "    python.default_actions=PEP8Bear:ApplyPatchAction --save\n",
    "    # other output ...\n",
    "    Executing section python...\n",
    "    [INFO][11:03:37] Applied 'ApplyPatchAction' for 'PEP8Bear'.\n",
    "    [INFO][11:03:37] Applied 'ApplyPatchAction' for 'PEP8Bear'.\n",
    "\n",
    "*coala* would now fix all spacing issues and without bothering you again.\n",
    "\n",
    "Currently following actions are available:\n",
    "\n",
    "-  ``ApplyPatchAction``: Applies a given patch (if existent).\n",
    "-  ``ShowPatchAction``: Just displays a given patch (if existent)\n",
    "   without doing something.\n",
    "\n",
    "For debugging purposes:\n",
    "\n",
    "-  ``PrintDebugMessageAction``: Prints a debug message for the appearing\n",
    "   result.\n",
    "\n",
    "Setting Inheritance\n",
    "-------------------\n",
    "\n",
    "All settings in the default section are implicitly inherited to all\n",
    "other sections (if they do not override their values). We can use that\n",
    "to save a few lines!\n",
    "\n",
    "Lets add the following section to our ``.coafile``:\n",
    "\n",
    "::\n",
    "\n",
    "    [TODOS]\n",
    "    bears = KeywordBear\n",
    "\n",
    "And execute ``coala`` with the ``-s`` argument which is the same as\n",
    "``--save``. I recommend setting case insensitive keywords to\n",
    "``TODO, FIXME`` and case sensitive keywords empty.\n",
    "\n",
    "After the results we've already seen, we'll see a new informational one\n",
    "which informs us that we have a TODO in our code.\n",
    "\n",
    "Did you note that we didn't specify which files to check this time? This\n",
    "is because all settings, including ``files = src/*.c``, from the Default\n",
    "section are already available in every other section implicitly. Thus\n",
    "the default section is a good point to set things like logging and\n",
    "output settings or specifying a default set of files to check.\n",
    "\n",
    "Ignoring Issues\n",
    "---------------\n",
    "\n",
    "There are several ways to ignore certain issues, so you aren't lost if\n",
    "any routines yield false positives.\n",
    "\n",
    "Ignoring Files\n",
    "~~~~~~~~~~~~~~\n",
    "\n",
    "*coala* lets you ignore whole files through the ``ignore`` setting:\n",
    "\n",
    "::\n",
    "\n",
    "    files = **/*.h\n",
    "    ignore = **/resources.h\n",
    "\n",
    "This configuration would include all header (``.h``) files but leaves\n",
    "out resource headers.\n",
    "\n",
    "Ignoring code Inside Files\n",
    "~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "Sometimes you need finer-graded ignores. Imagine you have a\n",
    "``LineLengthBear`` that shall not run on some code segments, because you\n",
    "can't wrap them:\n",
    "\n",
    "::\n",
    "\n",
    "    code = \"that's checked normally\"\n",
    "\n",
    "    # Ignore LineLengthBear\n",
    "    unwrappable_string = \"some string that is long and would exceed the limit\"\n",
    "\n",
    "You can also skip an area:\n",
    "\n",
    "::\n",
    "\n",
    "    # Start ignoring LineLengthBear\n",
    "    unwrappable_string_2 = unwrappable_string + \"yeah it goes even further...\"\n",
    "    another_unwrappable_string = unwrappable_string + unwrappable_string_2\n",
    "    # Stop ignoring\n",
    "\n",
    "You can also conditionally combine ignore rules! Bear names will be\n",
    "split by comma and spaces, invalid bear names like ``and`` will be\n",
    "ignored.\n",
    "\n",
    "Also note that in the bear names delimited by commas and spaces, you may\n",
    "specify glob wildcards that match several bears:\n",
    "\n",
    "::\n",
    "\n",
    "    # Start ignoring Line*, Py*\n",
    "    unwrappable_string_2 = unwrappable_string + \"yeah it goes even further...\"\n",
    "    another_unwrappable_string = unwrappable_string + unwrappable_string_2\n",
    "    # Stop ignoring\n",
    "\n",
    "In the above example all bears matching the glob `Line*` and `Py*` will\n",
    "be ignored. You may also specify more complex globs here such as\n",
    "`# Start ignoring (Line*|P[yx]*)` which will ignore all bears start with\n",
    "`Line`, `Py`, and `Px`.\n",
    "\n",
    "::\n",
    "\n",
    "    # Ignore LineLengthBear and SpaceConsistencyBear\n",
    "        variable = \"Why the heck are spaces used instead of tabs...\" + \"so_long\"\n",
    "\n",
    "If you put an ``all`` instead of the bear names directly after the\n",
    "``ignore``/``ignoring`` keyword, the results of all bears affecting\n",
    "those lines will be ignored.\n",
    "\n",
    "Enabling/Disabling Sections\n",
    "---------------------------\n",
    "\n",
    "Now that we have sections we need some way to control, which sections\n",
    "are executed. *coala* provides two ways to do that:\n",
    "\n",
    "Manual Enabling/Disabling\n",
    "~~~~~~~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "If you add the line ``TODOS.enabled=False`` to some arbitrary place to\n",
    "your ``.coafile`` or just ``enabled=False`` into the ``TODOS`` section,\n",
    "*coala* will not show the TODOs on every run.\n",
    "\n",
    "Especially for those bears yielding informational messages which you\n",
    "might want to see from time to time this is a good way to silence them.\n",
    "\n",
    "Specifying Targets\n",
    "~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "If you provide positional arguments, like ``coala Makefiles``, *coala*\n",
    "will execute exclusively those sections that are specified. This will\n",
    "not get stored in your ``.coafile`` and will take precedence over all\n",
    "enabled settings. You can specify several targets seperated by a space.\n",
    "\n",
    "What was that TODO again?\n",
    "\n",
    "Show bears' information\n",
    "-----------------------\n",
    "\n",
    "To get help on using a bear or to get a description of the bear, use the\n",
    "``--show-bears`` argument:\n",
    "\n",
    "::\n",
    "\n",
    "    coala --bears=SpaceConsistencyBear --show-bears\n",
    "\n",
    "This will display a large amount of information regarding the bears that\n",
    "have been specified (in the ``.coafile`` of in the CLI arguments). It\n",
    "shows:\n",
    "\n",
    "-  A description of what the bear does\n",
    "-  The sections which uses it\n",
    "-  The settings it uses (optional and required)\n",
    "\n",
    "Continuing the Journey\n",
    "----------------------\n",
    "\n",
    "If you want to know about more options, take a look at our help with\n",
    "``coala -h``. If you liked or disliked this tutorial, feel free to drop\n",
    "us a note at our `bug tracker\n",
    "<https://github.com/coala-analyzer/coala/issues>`_ or `mailing list\n",
    "<https://groups.google.com/forum/#!forum/coala-devel>`_.\n",
    "\n",
    "If you need more flexibility, know that *coala* is extensible in many ways\n",
    "due to its modular design:\n",
    "\n",
    "-  If you want to write your own bears, take a look at sources lying in\n",
    "   ``bears`` and ``coalib/bearlib``.\n",
    "-  If you want to add custom actions for results, take a look at the\n",
    "   code in ``coalib/results/results_actions``.\n",
    "-  If you want to have some custom outputs (e.g. HTML pages, a GUI or\n",
    "   voice interaction) take a look at modules lying in ``coalib/output``.\n",
    "\n",
    "Happy coding!\n"
  ],
  "/home/tushar/coala/docs/Users/Tutorials/Writing_Bears.rst": [
    "Guide to Write a Bear\n",
    "=====================\n",
    "\n",
    "Welcome. This document presents information on how to write a bear for\n",
    "*coala*. It assumes you know how to use *coala*. If not please read our main\n",
    "tutorial!\n",
    "\n",
    "The sample sources for this tutorial lie at our *coala-tutorial*\n",
    "repository, go clone it with:\n",
    "\n",
    "::\n",
    "\n",
    "    git clone https://github.com/coala-analyzer/coala-tutorial.git\n",
    "\n",
    "All paths and commands given here are meant to be executed from the root\n",
    "directory of the *coala-tutorial* repository.\n",
    "\n",
    "What is a bear?\n",
    "---------------\n",
    "\n",
    "A bear is meant to do some analysis on source code. The source code will\n",
    "be provided by *coala* so the bear doesn't have to care where it comes from\n",
    "or where it goes.\n",
    "\n",
    "A bear can communicate with the user via two ways:\n",
    "\n",
    "-  Via log messages\n",
    "-  Via results\n",
    "\n",
    "Log messages will be logged according to the users settings and are\n",
    "usually used if something goes wrong. However you can use debug for\n",
    "providing development related debug information since it will not be\n",
    "shown to the user by default. If error/failure messages are used, the\n",
    "bear is expected not to continue analysis.\n",
    "\n",
    "A Hello World Bear\n",
    "------------------\n",
    "\n",
    "Below is the code given for a simple bear that sends a debug message for\n",
    "each file:\n",
    "\n",
    ".. code:: python\n",
    "\n",
    "    from coalib.bears.LocalBear import LocalBear\n",
    "\n",
    "\n",
    "    class HelloWorldBear(LocalBear):\n",
    "        def run(self,\n",
    "                filename,\n",
    "                file):\n",
    "            self.debug(\"Hello World! Checking file\", filename, \".\")\n",
    "\n",
    "This bear is stored at ``./bears/HelloWorldBear``\n",
    "\n",
    "In order to let *coala* execute this bear you need to let *coala* know where\n",
    "to find it. We can do that with the ``-d`` (``--bear-dirs``) argument:\n",
    "\n",
    "``coala -f src/*.c -d bears -b HelloWorldBear -L DEBUG``\n",
    "\n",
    ".. note::\n",
    "\n",
    "    The given bear directories must not have any glob expressions in them. Any\n",
    "    character that could be interpreted as a part of a glob expression will be\n",
    "    escaped. Please use comma separated values to give several such\n",
    "    directories instead.\n",
    "\n",
    "You should now see the debug message for our sample file.\n",
    "\n",
    "The Bear class also supports ``warn`` and ``err``.\n",
    "\n",
    "Communicating with the User\n",
    "---------------------------\n",
    "\n",
    "Now we can send messages through the queue, we can do the real work.\n",
    "Lets say:\n",
    "\n",
    "-  We want some information from the user (e.g. the tab width if we rely\n",
    "   on indentation)\n",
    "-  We've got some useful information for the user and want to show it to\n",
    "   him. This might be some issue with his code or just an information\n",
    "   like the number of lines.\n",
    "\n",
    "So let's extend our HelloWorldBear a bit, I've named the new bear with\n",
    "the creative name CommunicationBear:\n",
    "\n",
    ".. code:: python\n",
    "\n",
    "    from coalib.bears.LocalBear import LocalBear\n",
    "    from coalib.results.Result import Result\n",
    "\n",
    "\n",
    "    class CommunicationBear(LocalBear):\n",
    "\n",
    "        def run(self,\n",
    "                filename,\n",
    "                file,\n",
    "                user_input: str):\n",
    "            \"\"\"\n",
    "            Communicates with the user.\n",
    "\n",
    "            :param user_input: Arbitrary user input.\n",
    "            \"\"\"\n",
    "            self.debug(\"Got '{ui}' as user input of type {type}.\".format(\n",
    "                ui=user_input,\n",
    "                type=type(user_input)))\n",
    "\n",
    "            return [Result.from_values(message=\"A hello world result.\",\n",
    "                                       origin=self,\n",
    "                                       file=filename)]\n",
    "\n",
    "Try executing it:\n",
    "\n",
    "::\n",
    "\n",
    "    coala -f=src/\\*.c -d=bears -b=CommunicationBear -L=DEBUG\n",
    "\n",
    "Hey, we'll get asked for the user\\_input! Wasn't that easy? Go ahead,\n",
    "enter something and observe the output.\n",
    "\n",
    "So, what did *coala* do here?\n",
    "\n",
    "First, *coala* looked at the parameters of the run method and found that\n",
    "we need some value named user\\_input. Then it parsed our documentation\n",
    "comment and found a description for the parameter which was shown to us\n",
    "to help us choose the right value. After the needed values are provided,\n",
    "*coala* converts us the value into a string because we've provided the\n",
    "``str`` annotation for this parameter. If no annotation is given or the\n",
    "value isn't convertible into the desired data type, you will get a\n",
    "``coalib.settings.Setting.Setting``.\n",
    "\n",
    "Your docstring can also be used to tell the user what exactly your bear\n",
    "does.\n",
    "\n",
    "Try executing\n",
    "\n",
    "::\n",
    "\n",
    "    coala -d bears -b CommunicationBear --show-bears\n",
    "\n",
    "This will show the user a bunch of information related to the bear like:\n",
    "- A description of what the bear does - The sections which uses it - The\n",
    "settings it uses (optional and required)\n",
    "\n",
    "What Data Types are Supported?\n",
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "The Setting does support some very basic types:\n",
    "\n",
    "-  String (``str``)\n",
    "-  Float (``float``)\n",
    "-  Int (``int``)\n",
    "-  Boolean (``bool``, will accept values like ``true``, ``yes``,\n",
    "   ``yeah``, ``no``, ``nope``, ``false``)\n",
    "-  List of strings (``list``, values will be split by comma)\n",
    "-  Dict of strings (``dict``, values will be split by comma and colon)\n",
    "\n",
    "If you need another type, you can write the conversion function yourself\n",
    "and use this function as the annotation (if you cannot convert value, be\n",
    "sure to throw ``TypeError`` or ``ValueError``). We've provided a few\n",
    "advanced conversions for you:\n",
    "\n",
    "-  ``coalib.settings.Setting.path``, converts to an absolute file path\n",
    "   relative to the file/command where the setting was set\n",
    "-  ``coalib.settings.Setting.path_list``, converts to a list of absolute\n",
    "   file paths relative to the file/command where the setting was set\n",
    "-  ``coalib.settings.Setting.typed_list(typ)``, converts to a list and\n",
    "   applies the given conversion (``typ``) to each element.\n",
    "-  ``coalib.settings.Setting.typed_ordered_dict(key_type, value_type,\n",
    "   default)``, converts to a dict while applying the ``key_type``\n",
    "   conversion to all keys, the ``value_type`` conversion to all values\n",
    "   and uses the ``default`` value for all unset keys. Use ``typed_dict``\n",
    "   if the order is irrelevant for you.\n",
    "\n",
    "Results\n",
    "-------\n",
    "\n",
    "In the end we've got a result. If a file is provided, *coala* will show\n",
    "the file, if a line is provided, *coala* will also show a few lines before\n",
    "the affecting line. There are a few parameters to the Result\n",
    "constructor, so you can e.g. create a result that proposes a code change\n",
    "to the user. If the user likes it, *coala* will apply it automatically -\n",
    "you don't need to care.\n",
    "\n",
    "Your function needs to return an iterable of ``Result`` objects: that\n",
    "means you can either return a ``list`` of ``Result`` objects or simply\n",
    "yield them and write the method as a generator.\n",
    "\n",
    ".. note::\n",
    "\n",
    "    We are currently planning to simplify Bears for bear writers and us.\n",
    "    In order to make your Bear future proof, we recommend writing your\n",
    "    method in generator style.\n",
    "\n",
    "    Don't worry: in order to migrate your Bears to our new API, you will\n",
    "    likely only need to change two lines of code. For more information\n",
    "    about how bears will look in the future, please read up on\n",
    "    https://github.com/coala-analyzer/coala/issues/725 or ask us on\n",
    "    https://gitter.im/coala-analyzer/coala.\n",
    "\n",
    "Bears Depending on Other Bears\n",
    "------------------------------\n",
    "\n",
    "So we've got a result, but what if we need our Bear to depend on results from\n",
    "a different Bear?\n",
    "\n",
    "Well *coala* has an efficient dependency management system that would run the\n",
    "other Bear before your Bear and get its results for you. All you need to do is\n",
    "to tell *coala* which Bear(s) you want to run before your Bear.\n",
    "\n",
    "So let's see how you could tell *coala* which Bears to run before yours:\n",
    "\n",
    ".. code:: python\n",
    "\n",
    "    from coalib.bears.LocalBear import LocalBear\n",
    "    from bears.somePathTo.OtherBear import OtherBear\n",
    "\n",
    "    class DependentBear(LocalBear):\n",
    "\n",
    "        def run(self, filename, file, dependency_results):\n",
    "            results = dependency_results[OtherBear.name]\n",
    "\n",
    "        @staticmethod\n",
    "        def get_dependencies():\n",
    "            return [OtherBear]\n",
    "\n",
    "As you can see we have a :meth:`~coalib.bears.Bear.Bear.get_dependencies`\n",
    "method which returns a list of bears we wish to depend on.\n",
    "In this case it is a list with 1 item: \"OtherBear\".\n",
    "\n",
    ".. note::\n",
    "    The list must have classes of the bear itself, not the name as a string.\n",
    "\n",
    "*coala* searches for the ``get_dependencies`` function before executing\n",
    "the ``DependentBear`` and runs all the Bears which are returned by it.\n",
    "\n",
    "After running these bears, *coala* gives all the results returned by the Bears\n",
    "in the ``dependency_results`` dictionary, which has the Bear's name as a key\n",
    "and a list of results as the value. E.g. in this case, we would have\n",
    "``dependency_results ==\n",
    "{'OtherBear' : [list containing results of OtherBear]]}``.\n",
    "\n",
    ".. note::\n",
    "    ``dependency_results`` is a keyword here and it cannot be called by\n",
    "    any other name.\n",
    "\n",
    "Hidden Results\n",
    "--------------\n",
    "Apart from regular Results, *coala* provides HiddenResults, which are used\n",
    "to share data between Bears as well as giving results which are not shown to\n",
    "the user. This feature is specifically for Bears that are dependencies of other\n",
    "Bears, and do not want to return Results which would be displayed when the\n",
    "bear is run.\n",
    "\n",
    "Let's see how we can use HiddenResults in our Bear:\n",
    "\n",
    ".. code:: python\n",
    "\n",
    "    from coalib.bears.LocalBear import LocalBear\n",
    "    from coalib.results.HiddenResult import HiddenResult\n",
    "\n",
    "    class OtherBear(LocalBear):\n",
    "\n",
    "        def run(self, filename, file):\n",
    "            yield HiddenResult(self, [\"Some Content\", \"Some Other Content\"])\n",
    "\n",
    "Here we see that this Bear (unlike normal Bears) yields a\n",
    ":class:`~coalib.results.HiddenResult` instead of a ``Result``. The first\n",
    "parameter in ``HiddenResult`` should be the instance of the Bear that yields\n",
    "this result (in this case ``self``), and second argument should be the content\n",
    "we want to transfer between the Bears. Here we use a list of strings as content\n",
    "but it can be any object.\n"
  ],
  "/home/tushar/coala/docs/Users/coafile.rst": [
    "The .coafile Specification\n",
    "==========================\n",
    "\n",
    "This document gives a short introduction into the specification of a\n",
    "*coala* configuration file. It is meant to be rather factual, if you wish\n",
    "to learn by example, please take a look at the :doc:`Tutorials/Tutorial`.\n",
    "\n",
    "Naming, Scope and Location\n",
    "--------------------------\n",
    "\n",
    "You can use up to three coafiles to configure your project.\n",
    "\n",
    "1. A project-wide coafile.\n",
    "2. A user-wide coafile.\n",
    "3. A system-wide coafile.\n",
    "\n",
    "Project-Wide coafile\n",
    "~~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "It is a convention that the project-wide coafile is named ``.coafile``\n",
    "and lies in the project root directory. If you follow this convention,\n",
    "simply executing ``coala`` from the project root will execute the\n",
    "configuration specified in that file.\n",
    "\n",
    "Settings given in the project-wide coafile override all settings given\n",
    "by other files and can only be overridden by settings given via the\n",
    "command line interface.\n",
    "\n",
    "User-Wide and System-Wide coafile\n",
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "You can place a ``.coarc`` file in your home directory to set certain\n",
    "settings user wide. Those settings will automatically be taken for all\n",
    "projects executed with that user.\n",
    "\n",
    "All settings specified here override only settings given by the system\n",
    "wide coafile which has the lowest priority. The ``default_coafile`` must\n",
    "lie in the *coala* installation directory and is valid for everyone using\n",
    "this *coala* installation.\n",
    "\n",
    "Setting Inheritance\n",
    "-------------------\n",
    "\n",
    "Every coafile consists out of one or more sections. Section names are\n",
    "case insensitive. The ``default`` section is implicitly available and\n",
    "all settings which have no section specified belong to it. The\n",
    "``default`` section is special because all settings residing in it are\n",
    "automatically inherited to all other sections specified in the same\n",
    "coafile.\n",
    "\n",
    "This is an example coafile:\n",
    "\n",
    "::\n",
    "\n",
    "    enabled = True\n",
    "    overridable = 2\n",
    "\n",
    "    [section-1]\n",
    "    overridable = 3\n",
    "    other = 4\n",
    "\n",
    "    [section-2]\n",
    "    overridable = 5\n",
    "    other = 2\n",
    "\n",
    "This coafile would be interpreted the very same as this one, written a\n",
    "bit more explicitly:\n",
    "\n",
    "::\n",
    "\n",
    "    [default]\n",
    "    enabled = True\n",
    "    overridable = 2\n",
    "\n",
    "    [section-1]\n",
    "    enabled = True\n",
    "    overridable = 3\n",
    "    other = 4\n",
    "\n",
    "    [section-2]\n",
    "    enabled = True\n",
    "    overridable = 5\n",
    "    other = 2\n",
    "\n",
    "Comments, Escaping and Multiline Values and Keys\n",
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
    "\n",
    "Comments are simply done with a preceding ``#``. If you want to use a\n",
    "``#`` within a value, you can simply escape it:\n",
    "\n",
    "::\n",
    "\n",
    "    a_key = a\\#value # And a comment at the end!\n",
    "\n",
    "Any line not containing an unescaped ``=`` is simply appended to the\n",
    "value of the last key:\n",
    "\n",
    "::\n",
    "\n",
    "    a_key = a\n",
    "    value\n",
    "    # this is not part of the value\n",
    "    that /= is\n",
    "    very long!\n",
    "\n",
    "Similarly, you can also set a value to multiple keys:\n",
    "``key_1, key_2 = value`` is equivalent to ``key_1 = value`` and\n",
    "``key_2 = value`` in separate lines.\n",
    "\n",
    "As the backslash is the escape character it is recommended to use\n",
    "forward slashes as path seperator even on windows (to keep relative\n",
    "paths platform independent), use double-backslashes if you really mean a\n",
    "backslash in all places.\n"
  ],
  "/home/tushar/coala/docs/index.rst": [
    ".. coala documentation master file, created by\n",
    "   sphinx-quickstart on Wed Feb  3 16:49:01 2016.\n",
    "   You can adapt this file completely to your liking, but it should at least\n",
    "   contain the root `toctree` directive.\n",
    "\n",
    ".. meta::\n",
    "   :description: coala is a simple COde AnaLysis Application. Its goal is\n",
    "                 to make static code analysis easy while remaining completely\n",
    "                 modular and therefore extendable and language independent.\n",
    "   :keywords:    coala, code analysis, static code analysis, linter,\n",
    "                 language agnostic, python3, linux, unix, windows, bears,\n",
    "                 coala-bears\n",
    "\n",
    "Welcome to the coala documentation!\n",
    "===================================\n",
    "\n",
    ".. toctree::\n",
    "   :caption: Home\n",
    "   :hidden:\n",
    "\n",
    "   Welcome <self>\n",
    "\n",
    ".. toctree::\n",
    "   :caption: For Users\n",
    "   :hidden:\n",
    "\n",
    "   Installation <Users/Install>\n",
    "   coafile Specification <Users/coafile>\n",
    "   Glob Patterns <Users/Glob_Patterns>\n",
    "   Exit Codes <Users/Exit_Codes>\n",
    "   External APIs <Users/External_APIs>\n",
    "   Git Hooks <Users/Git_Hooks>\n",
    "\n",
    ".. toctree::\n",
    "   :caption: Tutorials\n",
    "   :hidden:\n",
    "\n",
    "   First Step <Users/Tutorials/Tutorial>\n",
    "   Writing Bears <Users/Tutorials/Writing_Bears>\n",
    "   Testing Bears <Users/Tutorials/Testing_Bears>\n",
    "   Linter Bears <Users/Tutorials/Linter_Bears>\n",
    "   Linter Bears - Suggest corrections <Users/Tutorials/Self_Correcting_Bears>\n",
    "   Git Help <Users/Tutorials/Git_Help>\n",
    "   Auto completion <Users/Tutorials/Auto_Completion>\n",
    "\n",
    ".. toctree::\n",
    "   :caption: Getting Involved\n",
    "   :hidden:\n",
    "\n",
    "   Newcomers <Getting_Involved/Newcomers>\n",
    "   Introduction <Getting_Involved/README>\n",
    "   Codestyle <Getting_Involved/Codestyle>\n",
    "   Commit Style <Getting_Involved/Writing_Good_Commits>\n",
    "   Executing Tests <Getting_Involved/Testing>\n",
    "   Review <Getting_Involved/Review>\n",
    "   Writing Tests <Getting_Involved/Writing_Tests>\n",
    "   Writing Documentation <Getting_Involved/Writing_Documentation>\n",
    "   MAC Hints <Getting_Involved/MAC_Hints>\n",
    "\n",
    ".. toctree::\n",
    "   :caption: General Developer Information\n",
    "   :hidden:\n",
    "\n",
    "   A Hitchhiker's Guide to Git (1): Genesis <General_Dev_Info/git_tutorial_1>\n",
    "\n",
    ".. toctree::\n",
    "   :caption: API Documentation\n",
    "   :hidden:\n",
    "\n",
    "   List of Modules<API/modules>\n",
    "\n",
    ".. Start ignoring LineLengthBear\n",
    "\n",
    "::\n",
    "\n",
    "                                                         .o88Oo._\n",
    "                                                        d8P         .ooOO8bo._\n",
    "                                                        88                  '*Y8bo.\n",
    "                                          __            YA                      '*Y8b   __\n",
    "                                        ,dPYb,           YA                        68o68**8Oo.\n",
    "                                        IP'`Yb            \"8D                       *\"'    \"Y8o\n",
    "                                        I8  8I             Y8     'YB                       .8D\n",
    "                                        I8  8P             '8               d8'             8D\n",
    "                                        I8  8'              8       d8888b          d      AY\n",
    "         ,gggo,    ,ggggo,    ,gggo,gg  I8 dP    ,gggo,gg   Y,     d888888         d'  _.oP\"\n",
    "        dP\"  \"Yb  dP\"  \"Y8go*8P\"  \"Y8I  I8dP    dP\"  \"Y8I    q.    Y8888P'        d8\n",
    "       i8'       i8'    ,8P i8'    ,8I  I8P    i8'    ,8I     \"q.  `Y88P'       d8\"\n",
    "      ,d8,_    _,d8,   ,d8' d8,   ,d8b,,d8b,_ ,d8,   ,d8b,       Y           ,o8P\n",
    "    ooP\"\"Y8888PP*\"Y8888P\"   \"Y8888P\"`Y88P'\"Y88P\"Y8888P\"`Y8            oooo888P\"\n",
    "\n",
    ".. Stop ignoring LineLengthBear\n",
    "\n",
    "What is coala?\n",
    "--------------\n",
    "\n",
    "coala is a simple COde AnaLysis Application. Its goal is to make static\n",
    "code analysis easy while remaining completely modular and therefore\n",
    "extendable and language independent. coala is written with a lower case\n",
    "\"c\".\n",
    "\n",
    "Code analysis happens in python scripts while coala manages these, tries\n",
    "to provide helpful libraries and provides multiple user interfaces.\n",
    "(Currently we support only Console output but others will follow.)\n",
    "\n",
    "One could say coala unites all language independent parts of a linter\n",
    "and is arbitrarily extensible.\n",
    "\n",
    "To get started, take a look at our :doc:`Installation\n",
    "Instructions <Users/Install>` and the\n",
    ":doc:`Tutorial <Users/Tutorials/Tutorial>`.\n",
    "\n",
    "What do I get?\n",
    "--------------\n",
    "\n",
    "As a User\n",
    "~~~~~~~~~\n",
    "\n",
    "coala allows you to simply check your code against certain quality\n",
    "requirements. The checking routines are named **Bears** in coala. You\n",
    "can easily define a simple project file to check your project with all\n",
    "bears either shipped with coala or ones you found in the internet and\n",
    "trust.\n",
    "\n",
    "As a Developer\n",
    "~~~~~~~~~~~~~~\n",
    "\n",
    "If you are not satisfied with the functionality given by the bears we\n",
    "provide, you can easily write own bears. coala is written with easiness\n",
    "of extension in mind. That means: no big boilerplate, just write one\n",
    "small object with one routine, add the parameters you like and see how\n",
    "coala automates the organization of settings, user interaction and\n",
    "execution parallelization. You shouldn't need to care about anything\n",
    "else than just writing your algorithm!\n",
    "\n",
    "See :doc:`Writing Bears <Users/Tutorials/Writing_Bears>` for more information on\n",
    "this.\n",
    "\n",
    "Also, coala provides an external API using the dbus message protocol.\n",
    "This allows other applications to easily use the code analysis\n",
    "functionalities coala provides in their applications.\n",
    "\n",
    "See :doc:`External APIs <Users/External_APIs>` for more information.\n",
    "\n",
    "Status and Stability of the Project\n",
    "-----------------------------------\n",
    "\n",
    "We are currently working hard to make this project reality. coala is currently\n",
    "usable, in beta stage and already provides more features than most\n",
    "language dependent alternatives. Every single commit is fully reviewed and\n",
    "checked with various automated methods including our testsuite covering all\n",
    "branches. Our master branch is continuously prereleased to our users so you can\n",
    "rely on the upcoming release being rock stable.\n",
    "\n",
    "If you want to see how the development progresses, check out\n",
    "\n",
    "https://github.com/coala-analyzer/coala\n",
    "\n",
    "Indices and tables\n",
    "------------------\n",
    "\n",
    "* :ref:`genindex`\n",
    "* :ref:`modindex`\n",
    "* :ref:`search`\n"
  ],
  "/home/tushar/coala/setup.py": [
    "#!/usr/bin/env python3\n",
    "\n",
    "# Start ignoring PyImportSortBear as imports below may yield syntax errors\n",
    "from coalib import assert_supported_version, VERSION, get_version, BUS_NAME\n",
    "\n",
    "assert_supported_version()\n",
    "# Stop ignoring\n",
    "\n",
    "import datetime\n",
    "import locale\n",
    "import sys\n",
    "from os import getenv\n",
    "from subprocess import call\n",
    "\n",
    "import setuptools.command.build_py\n",
    "from coalib.misc.BuildManPage import BuildManPage\n",
    "from coalib.output.dbus.BuildDbusService import BuildDbusService\n",
    "from setuptools import find_packages, setup\n",
    "from setuptools.command.test import test as TestCommand\n",
    "\n",
    "try:\n",
    "    locale.getlocale()\n",
    "except (ValueError, UnicodeError):\n",
    "    locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')\n",
    "\n",
    "\n",
    "class BuildPyCommand(setuptools.command.build_py.build_py):\n",
    "\n",
    "    def run(self):\n",
    "        self.run_command('build_manpage')\n",
    "        self.run_command('build_dbus')\n",
    "        setuptools.command.build_py.build_py.run(self)\n",
    "\n",
    "\n",
    "class PyTestCommand(TestCommand):\n",
    "\n",
    "    def run_tests(self):\n",
    "        # import here, cause outside the eggs aren't loaded\n",
    "        import pytest\n",
    "        errno=pytest.main([])\n",
    "        sys.exit(errno)\n",
    "\n",
    "\n",
    "class BuildDocsCommand(setuptools.command.build_py.build_py):\n",
    "    apidoc_command = ('sphinx-apidoc', '-f', '-o', 'docs/API/',\n",
    "                      'coalib')\n",
    "    doc_command = ('make', '-C', 'docs', 'html')\n",
    "\n",
    "    def run(self):\n",
    "        call(self.apidoc_command)\n",
    "        call(self.doc_command)\n",
    "\n",
    "\n",
    "# Generate API documentation only if we are running on readthedocs.org\n",
    "on_rtd = getenv('READTHEDOCS',None) != None\n",
    "if on_rtd:\n",
    "    call(BuildDocsCommand.apidoc_command)\n",
    "    if \"dev\" in VERSION:\n",
    "        current_version = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n",
    "        call(['python3', '.misc/adjust_version_number.py', 'coalib/VERSION',\n",
    "              '-b {}'.format(current_version)])\n",
    "        VERSION = get_version()\n",
    "\n",
    "with open('requirements.txt') as requirements:\n",
    "    required = requirements.read().splitlines()\n",
    "\n",
    "with open('test-requirements.txt') as requirements:\n",
    "    test_required = requirements.read().splitlines()\n",
    "\n",
    "with open(\"README.rst\") as readme:\n",
    "    long_description = readme.read()\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    data_files = [('.', ['coala.1']), ('.', [BUS_NAME + '.service'])]\n",
    "\n",
    "    setup(name='coala',\n",
    "          version=VERSION,\n",
    "          description='Code Analysis Application (coala)',\n",
    "          author=\"The coala developers\",\n",
    "          maintainer=\"Lasse Schuirmann, Fabian Neuschmidt, Mischa Kr\\xfcger\"\n",
    "                      if not on_rtd else \"L.S., F.N., M.K.\",\n",
    "          maintainer_email=('lasse.schuirmann@gmail.com, '\n",
    "                            'fabian@neuschmidt.de, '\n",
    "                            'makman@alice.de'),\n",
    "          url='http://coala-analyzer.org/',\n",
    "          platforms='any',\n",
    "          packages=find_packages(exclude=[\"build.*\", \"tests\", \"tests.*\"]),\n",
    "          install_requires=required,\n",
    "          tests_require=test_required,\n",
    "          package_data={'coalib': ['default_coafile', \"VERSION\",\n",
    "                                   'bearlib/languages/definitions/*.coalang']},\n",
    "          license=\"AGPL-3.0\",\n",
    "          data_files=data_files,\n",
    "          long_description=long_description,\n",
    "          entry_points={\n",
    "              \"console_scripts\": [\n",
    "                  \"coala = coalib.coala:main\",\n",
    "                  \"coala-ci = coalib.coala_ci:main\",\n",
    "                  \"coala-dbus = coalib.coala_dbus:main\",\n",
    "                  \"coala-json = coalib.coala_json:main\",\n",
    "                  \"coala-format = coalib.coala_format:main\",\n",
    "                  \"coala-delete-orig = coalib.coala_delete_orig:main\"]},\n",
    "          # from http://pypi.python.org/pypi?%3Aaction=list_classifiers\n",
    "          classifiers=[\n",
    "              'Development Status :: 4 - Beta',\n",
    "\n",
    "              'Environment :: Console',\n",
    "              'Environment :: MacOS X',\n",
    "              'Environment :: Win32 (MS Windows)',\n",
    "              'Environment :: X11 Applications :: Gnome',\n",
    "\n",
    "              'Intended Audience :: Science/Research',\n",
    "              'Intended Audience :: Developers',\n",
    "\n",
    "              'License :: OSI Approved :: GNU Affero General Public License '\n",
    "              'v3 or later (AGPLv3+)',\n",
    "\n",
    "              'Operating System :: OS Independent',\n",
    "\n",
    "              'Programming Language :: Python :: Implementation :: CPython',\n",
    "              'Programming Language :: Python :: 3.3',\n",
    "              'Programming Language :: Python :: 3.4',\n",
    "              'Programming Language :: Python :: 3.5',\n",
    "              'Programming Language :: Python :: 3 :: Only',\n",
    "\n",
    "              'Topic :: Scientific/Engineering :: Information Analysis',\n",
    "              'Topic :: Software Development :: Quality Assurance',\n",
    "              'Topic :: Text Processing :: Linguistic'],\n",
    "          cmdclass={'build_manpage': BuildManPage,\n",
    "                    'build_dbus': BuildDbusService,\n",
    "                    'build_py': BuildPyCommand,\n",
    "                    'docs': BuildDocsCommand,\n",
    "                    'test': PyTestCommand})\n"
  ],
  "/home/tushar/coala/tests/TestUtilities.py": [
    "from contextlib import contextmanager\n",
    "import os\n",
    "import sys\n",
    "import unittest.mock\n",
    "\n",
    "from coalib.misc.ContextManagers import retrieve_stdout\n",
    "\n",
    "\n",
    "def execute_coala(func, binary, *args):\n",
    "    \"\"\"\n",
    "    Executes the main function with the given argument string from given module.\n",
    "\n",
    "    :param function: A main function from coala_json, coala_ci module etc.\n",
    "    :param binary:   A binary to execute coala test\n",
    "    :return:         A tuple holding a return value first and\n",
    "                     a stdout output as second element.\n",
    "    \"\"\"\n",
    "    sys.argv = [binary] + list(args)\n",
    "    with retrieve_stdout() as stdout:\n",
    "        retval = func()\n",
    "        return retval, stdout.getvalue()\n",
    "\n",
    "\n",
    "@contextmanager\n",
    "def bear_test_module():\n",
    "    \"\"\"\n",
    "    This function mocks the ``pkg_resources.iter_entry_points()``\n",
    "    to use the testing bear module we have. Hence, it doesn't test\n",
    "    the collection of entry points.\n",
    "    \"\"\"\n",
    "    bears_test_module = os.path.join(os.path.dirname(__file__),\n",
    "                                     \"test_bears\", \"__init__.py\")\n",
    "\n",
    "    class EntryPoint:\n",
    "\n",
    "        @staticmethod\n",
    "        def load():\n",
    "            class PseudoPlugin:\n",
    "                __file__ = bears_test_module\n",
    "            return PseudoPlugin()\n",
    "\n",
    "    with unittest.mock.patch(\"pkg_resources.iter_entry_points\",\n",
    "                             return_value=[EntryPoint()]) as mocked:\n",
    "        yield\n",
    "\n",
    "\n",
    "def raise_error(error, *args, **kwargs):\n",
    "    raise error(*args, **kwargs)\n"
  ],
  "/home/tushar/coala/tests/__init__.py": [],
  "/home/tushar/coala/tests/bearlib/__init__.py": [],
  "/home/tushar/coala/tests/bearlib/abstractions/LintTest.py": [
    "import os\n",
    "import unittest\n",
    "\n",
    "from coalib.bearlib.abstractions.Lint import Lint, escape_path_argument\n",
    "from coalib.misc.ContextManagers import prepare_file\n",
    "from coalib.results.RESULT_SEVERITY import RESULT_SEVERITY\n",
    "from coalib.results.SourceRange import SourceRange\n",
    "from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "class LintTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        section = Section(\"some_name\")\n",
    "        self.uut = Lint(section, None)\n",
    "\n",
    "    def test_invalid_output(self):\n",
    "        out = list(self.uut.process_output(\n",
    "            [\"1.0|0: Info message\\n\",\n",
    "             \"2.2|1: Normal message\\n\",\n",
    "             \"3.4|2: Major message\\n\"],\n",
    "            \"a/file.py\",\n",
    "            ['original_file_lines_placeholder']))\n",
    "        self.assertEqual(len(out), 3)\n",
    "        self.assertEqual(out[0].origin, \"Lint\")\n",
    "\n",
    "        self.assertEqual(out[0].affected_code[0],\n",
    "                         SourceRange.from_values(\"a/file.py\", 1, 0))\n",
    "        self.assertEqual(out[0].severity, RESULT_SEVERITY.INFO)\n",
    "        self.assertEqual(out[0].message, \"Info message\")\n",
    "\n",
    "        self.assertEqual(out[1].affected_code[0],\n",
    "                         SourceRange.from_values(\"a/file.py\", 2, 2))\n",
    "        self.assertEqual(out[1].severity, RESULT_SEVERITY.NORMAL)\n",
    "        self.assertEqual(out[1].message, \"Normal message\")\n",
    "\n",
    "        self.assertEqual(out[2].affected_code[0],\n",
    "                         SourceRange.from_values(\"a/file.py\", 3, 4))\n",
    "        self.assertEqual(out[2].severity, RESULT_SEVERITY.MAJOR)\n",
    "        self.assertEqual(out[2].message, \"Major message\")\n",
    "\n",
    "    def test_custom_regex(self):\n",
    "        self.uut.output_regex = (r'(?P<origin>\\w+)\\|'\n",
    "                                 r'(?P<line>\\d+)\\.(?P<column>\\d+)\\|'\n",
    "                                 r'(?P<end_line>\\d+)\\.(?P<end_column>\\d+)\\|'\n",
    "                                 r'(?P<severity>\\w+): (?P<message>.*)')\n",
    "        self.uut.severity_map = {\"I\": RESULT_SEVERITY.INFO}\n",
    "        out = list(self.uut.process_output(\n",
    "            [\"info_msg|1.0|2.3|I: Info message\\n\"],\n",
    "            'a/file.py',\n",
    "            ['original_file_lines_placeholder']))\n",
    "        self.assertEqual(len(out), 1)\n",
    "        self.assertEqual(out[0].affected_code[0].start.line, 1)\n",
    "        self.assertEqual(out[0].affected_code[0].start.column, 0)\n",
    "        self.assertEqual(out[0].affected_code[0].end.line, 2)\n",
    "        self.assertEqual(out[0].affected_code[0].end.column, 3)\n",
    "        self.assertEqual(out[0].severity, RESULT_SEVERITY.INFO)\n",
    "        self.assertEqual(out[0].origin, 'Lint (info_msg)')\n",
    "\n",
    "    def test_valid_output(self):\n",
    "        out = list(self.uut.process_output(\n",
    "            [\"Random line that shouldn't be captured\\n\",\n",
    "             \"*************\\n\"],\n",
    "            'a/file.py',\n",
    "            ['original_file_lines_placeholder']))\n",
    "        self.assertEqual(len(out), 0)\n",
    "\n",
    "    def test_stdin_input(self):\n",
    "        with prepare_file([\"abcd\", \"efgh\"], None) as (lines, filename):\n",
    "            # Use more which is a command that can take stdin and show it.\n",
    "            # This is available in windows and unix.\n",
    "            self.uut.executable = \"more\"\n",
    "            self.uut.use_stdin = True\n",
    "            self.uut.use_stderr = False\n",
    "            self.uut.process_output = lambda output, filename, file: output\n",
    "\n",
    "            out = self.uut.lint(file=lines)\n",
    "            # Some implementations of `more` add an extra newline at the end.\n",
    "            self.assertTrue((\"abcd\\n\", \"efgh\\n\") == out or\n",
    "                            (\"abcd\\n\", \"efgh\\n\", \"\\n\") == out)\n",
    "\n",
    "    def test_stderr_output(self):\n",
    "        self.uut.executable = \"echo\"\n",
    "        self.uut.arguments = \"hello\"\n",
    "        self.uut.use_stdin = False\n",
    "        self.uut.use_stderr = True\n",
    "        self.uut.process_output = lambda output, filename, file: output\n",
    "        out = self.uut.lint(\"unused_filename\")\n",
    "        self.assertEqual((), out)  # stderr is used\n",
    "\n",
    "        self.uut.use_stderr = False\n",
    "        out = self.uut.lint(\"unused_filename\")\n",
    "        self.assertEqual(('hello\\n',), out)  # stdout is used\n",
    "\n",
    "        def assert_warn(line):\n",
    "            assert line == \"hello\"\n",
    "        old_warn = self.uut.warn\n",
    "        self.uut.warn = assert_warn\n",
    "        self.uut._print_errors([\"hello\", \"\\n\"])\n",
    "        self.uut.warn = old_warn\n",
    "\n",
    "    def test_gives_corrected(self):\n",
    "        self.uut.gives_corrected = True\n",
    "        out = tuple(self.uut.process_output([\"a\", \"b\"], \"filename\", [\"a\", \"b\"]))\n",
    "        self.assertEqual((), out)\n",
    "        out = tuple(self.uut.process_output([\"a\", \"b\"], \"filename\", [\"a\"]))\n",
    "        self.assertEqual(len(out), 1)\n",
    "\n",
    "    def test_check_prerequisites(self):\n",
    "        old_binary = Lint.executable\n",
    "        invalid_binary = \"invalid_binary_which_doesnt_exist\"\n",
    "        Lint.executable = invalid_binary\n",
    "\n",
    "        self.assertEqual(Lint.check_prerequisites(),\n",
    "                         \"'{}' is not installed.\".format(invalid_binary))\n",
    "\n",
    "        # \"echo\" is existent on nearly all platforms.\n",
    "        Lint.executable = \"echo\"\n",
    "        self.assertTrue(Lint.check_prerequisites())\n",
    "\n",
    "        Lint.executable = old_binary\n",
    "\n",
    "        old_command = Lint.prerequisite_command\n",
    "\n",
    "        Lint.prerequisite_command = [\"command_which_doesnt_exist\"]\n",
    "        self.assertEqual(Lint.check_prerequisites(), Lint.prerequisite_fail_msg)\n",
    "\n",
    "        Lint.prerequisite_command = \"command_which_isnt_a_list\"\n",
    "        self.assertRaises(TypeError, Lint.check_prerequisites)\n",
    "\n",
    "        Lint.prerequisite_command = [\"cd\",\n",
    "                                     os.path.join('non', 'existent', 'path')]\n",
    "        self.assertEqual(Lint.check_prerequisites(), Lint.prerequisite_fail_msg)\n",
    "\n",
    "        Lint.prerequisite_command = [\"echo\", \"abc\"]\n",
    "        self.assertTrue(Lint.check_prerequisites())\n",
    "\n",
    "        Lint.prerequisite_command = old_command\n",
    "\n",
    "    def test_config_file_generator(self):\n",
    "        self.uut.executable = \"echo\"\n",
    "        self.uut.arguments = \"-c {config_file}\"\n",
    "\n",
    "        self.assertEqual(\n",
    "            self.uut._create_command(config_file=\"configfile\").strip(),\n",
    "            \"echo -c \" + escape_path_argument(\"configfile\"))\n",
    "\n",
    "    def test_generate_config_file_generator(self):\n",
    "        self.uut.executable = \"echo\"\n",
    "        self.uut.config_file = lambda: [\"config line1\"]\n",
    "        config_filename = self.uut.generate_config_file()\n",
    "        self.assertTrue(os.path.isfile(config_filename))\n",
    "        os.remove(config_filename)\n",
    "\n",
    "        # To complete coverage of closing the config file and check if any\n",
    "        # errors are thrown there.\n",
    "        self.uut.lint(\"filename\")\n",
    "\n",
    "\n",
    "class EscapePathArgumentTest(unittest.TestCase):\n",
    "\n",
    "    def test_escape_path_argument_sh(self):\n",
    "        _type = \"sh\"\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"/home/usr/a-file\", _type),\n",
    "            \"/home/usr/a-file\")\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"/home/usr/a-dir/\", _type),\n",
    "            \"/home/usr/a-dir/\")\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"/home/us r/a-file with spaces.bla\",\n",
    "                                 _type),\n",
    "            \"'/home/us r/a-file with spaces.bla'\")\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"/home/us r/a-dir with spaces/x/\",\n",
    "                                 _type),\n",
    "            \"'/home/us r/a-dir with spaces/x/'\")\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\n",
    "                \"relative something/with cherries and/pickles.delicious\",\n",
    "                _type),\n",
    "            \"'relative something/with cherries and/pickles.delicious'\")\n",
    "\n",
    "    def test_escape_path_argument_cmd(self):\n",
    "        _type = \"cmd\"\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"C:\\\\Windows\\\\has-a-weird-shell.txt\", _type),\n",
    "            \"\\\"C:\\\\Windows\\\\has-a-weird-shell.txt\\\"\")\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"C:\\\\Windows\\\\lolrofl\\\\dirs\\\\\", _type),\n",
    "            \"\\\"C:\\\\Windows\\\\lolrofl\\\\dirs\\\\\\\"\")\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"X:\\\\Users\\\\Maito Gai\\\\fi le.exe\", _type),\n",
    "            \"\\\"X:\\\\Users\\\\Maito Gai\\\\fi le.exe\\\"\")\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"X:\\\\Users\\\\Mai to Gai\\\\director y\\\\\",\n",
    "                                 _type),\n",
    "            \"\\\"X:\\\\Users\\\\Mai to Gai\\\\director y\\\\\\\"\")\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"X:\\\\Users\\\\Maito Gai\\\\\\\"seven-gates\\\".y\",\n",
    "                                 _type),\n",
    "            \"\\\"X:\\\\Users\\\\Maito Gai\\\\^\\\"seven-gates^\\\".y\\\"\")\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"System32\\\\my-custom relative tool\\\\\",\n",
    "                                 _type),\n",
    "            \"\\\"System32\\\\my-custom relative tool\\\\\\\"\")\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"System32\\\\illegal\\\" name \\\"\\\".curd\", _type),\n",
    "            \"\\\"System32\\\\illegal^\\\" name ^\\\"^\\\".curd\\\"\")\n",
    "\n",
    "    def test_escape_path_argument_unsupported(self):\n",
    "        _type = \"INVALID\"\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"/home/usr/a-file\", _type),\n",
    "            \"/home/usr/a-file\")\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"/home/us r/a-file with spaces.bla\", _type),\n",
    "            \"/home/us r/a-file with spaces.bla\")\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"|home|us r|a*dir with spaces|x|\", _type),\n",
    "            \"|home|us r|a*dir with spaces|x|\")\n",
    "        self.assertEqual(\n",
    "            escape_path_argument(\"system|a|b|c?d\", _type),\n",
    "            \"system|a|b|c?d\")\n"
  ],
  "/home/tushar/coala/tests/bearlib/abstractions/LinterTest.py": [
    "import os\n",
    "import re\n",
    "import sys\n",
    "import unittest\n",
    "from unittest.mock import ANY, Mock\n",
    "\n",
    "from coalib.bearlib.abstractions.Linter import linter\n",
    "from coalib.results.Diff import Diff\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.RESULT_SEVERITY import RESULT_SEVERITY\n",
    "from coalib.results.SourceRange import SourceRange\n",
    "from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "def get_testfile_name(name):\n",
    "    \"\"\"\n",
    "    Gets the full path to a testfile inside ``linter_test_files`` directory.\n",
    "\n",
    "    :param name: The filename of the testfile to get the full path for.\n",
    "    :return:     The full path to given testfile name.\n",
    "    \"\"\"\n",
    "    return os.path.join(os.path.dirname(os.path.realpath(__file__)),\n",
    "                        \"linter_test_files\",\n",
    "                        name)\n",
    "\n",
    "\n",
    "class LinterComponentTest(unittest.TestCase):\n",
    "\n",
    "    # Using `object` instead of an empty class results in inheritance problems\n",
    "    # inside the linter decorator.\n",
    "    class EmptyTestLinter:\n",
    "        pass\n",
    "\n",
    "    class ManualProcessingTestLinter:\n",
    "\n",
    "        def process_output(self, *args, **kwargs):\n",
    "            pass\n",
    "\n",
    "    def setUp(self):\n",
    "        self.section = Section(\"TEST_SECTION\")\n",
    "\n",
    "    def test_decorator_invalid_parameters(self):\n",
    "        with self.assertRaises(ValueError) as cm:\n",
    "            linter(\"some-executable\", invalid_arg=88, ABC=2000)\n",
    "        self.assertEqual(\n",
    "            str(cm.exception),\n",
    "            \"Invalid keyword arguments provided: 'ABC', 'invalid_arg'\")\n",
    "\n",
    "        with self.assertRaises(ValueError) as cm:\n",
    "            linter(\"some-executable\", diff_severity=RESULT_SEVERITY.MAJOR)\n",
    "        self.assertEqual(str(cm.exception),\n",
    "                         \"Invalid keyword arguments provided: 'diff_severity'\")\n",
    "\n",
    "        with self.assertRaises(ValueError) as cm:\n",
    "            linter(\"some-executable\", result_message=\"Custom message\")\n",
    "        self.assertEqual(str(cm.exception),\n",
    "                         \"Invalid keyword arguments provided: \"\n",
    "                         \"'result_message'\")\n",
    "\n",
    "        with self.assertRaises(ValueError) as cm:\n",
    "            linter(\"some-executable\",\n",
    "                   output_format=\"corrected\",\n",
    "                   output_regex=\".*\")\n",
    "        self.assertEqual(str(cm.exception),\n",
    "                         \"Invalid keyword arguments provided: 'output_regex'\")\n",
    "\n",
    "        with self.assertRaises(ValueError) as cm:\n",
    "            linter(\"some-executable\",\n",
    "                   output_format=\"corrected\",\n",
    "                   severity_map={})\n",
    "        self.assertEqual(str(cm.exception),\n",
    "                         \"Invalid keyword arguments provided: 'severity_map'\")\n",
    "\n",
    "        with self.assertRaises(ValueError) as cm:\n",
    "            linter(\"some-executable\",\n",
    "                   prerequisite_check_fail_message=\"some_message\")\n",
    "        self.assertEqual(str(cm.exception),\n",
    "                         \"Invalid keyword arguments provided: \"\n",
    "                         \"'prerequisite_check_fail_message'\")\n",
    "\n",
    "    def test_decorator_invalid_states(self):\n",
    "        with self.assertRaises(ValueError) as cm:\n",
    "            linter(\"some-executable\", use_stdout=False, use_stderr=False)\n",
    "        self.assertEqual(str(cm.exception),\n",
    "                         \"No output streams provided at all.\")\n",
    "\n",
    "        with self.assertRaises(ValueError) as cm:\n",
    "            linter(\"some-executable\", output_format=\"INVALID\")\n",
    "        self.assertEqual(str(cm.exception),\n",
    "                         \"Invalid `output_format` specified.\")\n",
    "\n",
    "        with self.assertRaises(ValueError) as cm:\n",
    "            linter(\"some-executable\", output_format=\"regex\")\n",
    "        self.assertEqual(\n",
    "            str(cm.exception),\n",
    "            \"`output_regex` needed when specified output-format 'regex'.\")\n",
    "\n",
    "        with self.assertRaises(ValueError) as cm:\n",
    "            linter(\"some-executable\",\n",
    "                   output_format=\"regex\",\n",
    "                   output_regex=\"\",\n",
    "                   severity_map={})\n",
    "        self.assertEqual(\n",
    "            str(cm.exception),\n",
    "            \"Provided `severity_map` but named group `severity` is not used \"\n",
    "            \"in `output_regex`.\")\n",
    "\n",
    "        with self.assertRaises(ValueError) as cm:\n",
    "            linter(\"some-executable\")(object)\n",
    "        self.assertEqual(\n",
    "            str(cm.exception),\n",
    "            \"`process_output` not provided by given class 'object'.\")\n",
    "\n",
    "        with self.assertRaises(ValueError) as cm:\n",
    "            (linter(\"some-executable\", output_format=\"regex\", output_regex=\"\")\n",
    "             (self.ManualProcessingTestLinter))\n",
    "        self.assertEqual(\n",
    "            str(cm.exception),\n",
    "            \"Found `process_output` already defined by class \"\n",
    "            \"'ManualProcessingTestLinter', but 'regex' output-format is \"\n",
    "            \"specified.\")\n",
    "\n",
    "    def test_decorator_generated_default_interface(self):\n",
    "        uut = linter(\"some-executable\")(self.ManualProcessingTestLinter)\n",
    "        with self.assertRaises(NotImplementedError):\n",
    "            uut.create_arguments(\"filename\", \"content\", None)\n",
    "\n",
    "    def test_decorator_invalid_parameter_types(self):\n",
    "        # Provide some invalid severity maps.\n",
    "        with self.assertRaises(TypeError):\n",
    "            linter(\"some-executable\",\n",
    "                   output_format=\"regex\",\n",
    "                   output_regex=\"(?P<severity>)\",\n",
    "                   severity_map=list())\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            linter(\"some-executable\",\n",
    "                   output_format=\"regex\",\n",
    "                   output_regex=\"(?P<severity>)\",\n",
    "                   severity_map={3: 0})\n",
    "\n",
    "        with self.assertRaises(TypeError) as cm:\n",
    "            linter(\"some-executable\",\n",
    "                   output_format=\"regex\",\n",
    "                   output_regex=\"(?P<severity>)\",\n",
    "                   severity_map={\"critical\": \"invalid\"})\n",
    "        self.assertEqual(str(cm.exception),\n",
    "                         \"The value 'invalid' for key 'critical' inside given \"\n",
    "                         \"severity-map is no valid severity value.\")\n",
    "\n",
    "        with self.assertRaises(TypeError) as cm:\n",
    "            linter(\"some-executable\",\n",
    "                   output_format=\"regex\",\n",
    "                   output_regex=\"(?P<severity>)\",\n",
    "                   severity_map={\"critical-error\": 389274234})\n",
    "        self.assertEqual(str(cm.exception),\n",
    "                         \"Invalid severity value 389274234 for key \"\n",
    "                         \"'critical-error' inside given severity-map.\")\n",
    "\n",
    "        # Other type-error test cases.\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            linter(\"some-executable\",\n",
    "                   output_format=\"regex\",\n",
    "                   output_regex=\"(?P<message>)\",\n",
    "                   result_message=None)\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            linter(\"some-executable\",\n",
    "                   output_format=\"corrected\",\n",
    "                   result_message=list())\n",
    "\n",
    "        with self.assertRaises(TypeError) as cm:\n",
    "            linter(\"some-executable\",\n",
    "                   output_format=\"corrected\",\n",
    "                   diff_severity=999888777)\n",
    "        self.assertEqual(str(cm.exception),\n",
    "                         \"Invalid value for `diff_severity`: 999888777\")\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            linter(\"some-executable\",\n",
    "                   prerequisite_check_command=(\"command\",),\n",
    "                   prerequisite_check_fail_message=382983)\n",
    "\n",
    "    def test_get_executable(self):\n",
    "        uut = linter(\"some-executable\")(self.ManualProcessingTestLinter)\n",
    "        self.assertEqual(uut.get_executable(), \"some-executable\")\n",
    "\n",
    "    def test_check_prerequisites(self):\n",
    "        uut = linter(sys.executable)(self.ManualProcessingTestLinter)\n",
    "        self.assertTrue(uut.check_prerequisites())\n",
    "\n",
    "        uut = (linter(\"invalid_nonexisting_programv412\")\n",
    "               (self.ManualProcessingTestLinter))\n",
    "        self.assertEqual(uut.check_prerequisites(),\n",
    "                         \"'invalid_nonexisting_programv412' is not installed.\")\n",
    "\n",
    "        uut = (linter(\"invalid_nonexisting_programv412\",\n",
    "                      executable_check_fail_info=\"You can't install it.\")\n",
    "               (self.ManualProcessingTestLinter))\n",
    "        self.assertEqual(uut.check_prerequisites(),\n",
    "                         \"'invalid_nonexisting_programv412' is not installed. \"\n",
    "                         \"You can't install it.\")\n",
    "\n",
    "        uut = (linter(sys.executable,\n",
    "                      prerequisite_check_command=(sys.executable, \"--version\"))\n",
    "               (self.ManualProcessingTestLinter))\n",
    "        self.assertTrue(uut.check_prerequisites())\n",
    "\n",
    "        uut = (linter(sys.executable,\n",
    "                      prerequisite_check_command=(\"invalid_programv413\",))\n",
    "               (self.ManualProcessingTestLinter))\n",
    "        self.assertEqual(uut.check_prerequisites(),\n",
    "                         \"Prerequisite check failed.\")\n",
    "\n",
    "        uut = (linter(sys.executable,\n",
    "                      prerequisite_check_command=(\"invalid_programv413\",),\n",
    "                      prerequisite_check_fail_message=\"NOPE\")\n",
    "               (self.ManualProcessingTestLinter))\n",
    "        self.assertEqual(uut.check_prerequisites(), \"NOPE\")\n",
    "\n",
    "    def test_output_stream(self):\n",
    "        process_output_mock = Mock()\n",
    "\n",
    "        class TestLinter:\n",
    "\n",
    "            @staticmethod\n",
    "            def process_output(output, filename, file):\n",
    "                process_output_mock(output, filename, file)\n",
    "\n",
    "            @staticmethod\n",
    "            def create_arguments(filename, file, config_file):\n",
    "                code = \"\\n\".join([\"import sys\",\n",
    "                                  \"print('hello stdout')\",\n",
    "                                  \"print('hello stderr', file=sys.stderr)\"])\n",
    "                return \"-c\", code\n",
    "\n",
    "        uut = (linter(sys.executable, use_stdout=True)\n",
    "               (TestLinter)\n",
    "               (self.section, None))\n",
    "        uut.run(\"\", [])\n",
    "\n",
    "        process_output_mock.assert_called_once_with(\"hello stdout\\n\", \"\", [])\n",
    "        process_output_mock.reset_mock()\n",
    "\n",
    "        uut = (linter(sys.executable, use_stdout=False, use_stderr=True)\n",
    "               (TestLinter)\n",
    "               (self.section, None))\n",
    "        uut.run(\"\", [])\n",
    "\n",
    "        process_output_mock.assert_called_once_with(\"hello stderr\\n\", \"\", [])\n",
    "        process_output_mock.reset_mock()\n",
    "\n",
    "        uut = (linter(sys.executable, use_stdout=True, use_stderr=True)\n",
    "               (TestLinter)\n",
    "               (self.section, None))\n",
    "\n",
    "        uut.run(\"\", [])\n",
    "\n",
    "        process_output_mock.assert_called_once_with((\"hello stdout\\n\",\n",
    "                                                     \"hello stderr\\n\"), \"\", [])\n",
    "\n",
    "    def test_process_output_corrected(self):\n",
    "        uut = (linter(sys.executable, output_format=\"corrected\")\n",
    "               (self.EmptyTestLinter)\n",
    "               (self.section, None))\n",
    "\n",
    "        original = [\"void main()  {\\n\", \"return 09;\\n\", \"}\\n\"]\n",
    "        fixed = [\"void main()\\n\", \"{\\n\", \"return 9;\\n\", \"}\\n\"]\n",
    "        fixed_string = \"\".join(fixed)\n",
    "\n",
    "        results = list(uut.process_output(fixed_string,\n",
    "                                          \"some-file.c\",\n",
    "                                          original))\n",
    "\n",
    "        diffs = list(Diff.from_string_arrays(original, fixed).split_diff())\n",
    "        expected = [Result.from_values(uut,\n",
    "                                       \"Inconsistency found.\",\n",
    "                                       \"some-file.c\",\n",
    "                                       1, None, 2, None,\n",
    "                                       RESULT_SEVERITY.NORMAL,\n",
    "                                       diffs={\"some-file.c\": diffs[0]})]\n",
    "\n",
    "        self.assertEqual(results, expected)\n",
    "\n",
    "        # Test when providing a sequence as output.\n",
    "\n",
    "        results = list(uut.process_output([fixed_string, fixed_string],\n",
    "                                          \"some-file.c\",\n",
    "                                          original))\n",
    "        self.assertEqual(results, 2 * expected)\n",
    "\n",
    "        # Test diff_distance\n",
    "\n",
    "        uut = (linter(sys.executable,\n",
    "                      output_format=\"corrected\",\n",
    "                      diff_distance=-1)\n",
    "               (self.EmptyTestLinter)\n",
    "               (self.section, None))\n",
    "\n",
    "        results = list(uut.process_output(fixed_string,\n",
    "                                          \"some-file.c\",\n",
    "                                          original))\n",
    "        self.assertEqual(len(results), 2)\n",
    "\n",
    "    def test_process_output_regex(self):\n",
    "        # Also test the case when an unknown severity is matched.\n",
    "        test_output = (\"12:4-14:0-Serious issue (error) -> ORIGIN=X -> D\\n\"\n",
    "                       \"0:0-0:1-This is a warning (warning) -> ORIGIN=Y -> A\\n\"\n",
    "                       \"813:77-1024:32-Just a note (info) -> ORIGIN=Z -> C\\n\"\n",
    "                       \"0:0-0:0-Some unknown sev (???) -> ORIGIN=W -> B\\n\")\n",
    "        regex = (r\"(?P<line>\\d+):(?P<column>\\d+)-\"\n",
    "                 r\"(?P<end_line>\\d+):(?P<end_column>\\d+)-\"\n",
    "                 r\"(?P<message>.*) \\((?P<severity>.*)\\) -> \"\n",
    "                 r\"ORIGIN=(?P<origin>.*) -> (?P<additional_info>.*)\")\n",
    "\n",
    "        uut = (linter(sys.executable,\n",
    "                      output_format=\"regex\",\n",
    "                      output_regex=regex)\n",
    "               (self.EmptyTestLinter)\n",
    "               (self.section, None))\n",
    "        uut.warn = Mock()\n",
    "\n",
    "        sample_file = \"some-file.xtx\"\n",
    "        results = list(uut.process_output(test_output, sample_file, [\"\"]))\n",
    "        expected = [Result.from_values(\"EmptyTestLinter (X)\",\n",
    "                                       \"Serious issue\",\n",
    "                                       sample_file,\n",
    "                                       12, 4, 14, 0,\n",
    "                                       RESULT_SEVERITY.MAJOR,\n",
    "                                       additional_info=\"D\"),\n",
    "                    Result.from_values(\"EmptyTestLinter (Y)\",\n",
    "                                       \"This is a warning\",\n",
    "                                       sample_file,\n",
    "                                       0, 0, 0, 1,\n",
    "                                       RESULT_SEVERITY.NORMAL,\n",
    "                                       additional_info=\"A\"),\n",
    "                    Result.from_values(\"EmptyTestLinter (Z)\",\n",
    "                                       \"Just a note\",\n",
    "                                       sample_file,\n",
    "                                       813, 77, 1024, 32,\n",
    "                                       RESULT_SEVERITY.INFO,\n",
    "                                       additional_info=\"C\"),\n",
    "                    Result.from_values(\"EmptyTestLinter (W)\",\n",
    "                                       \"Some unknown sev\",\n",
    "                                       sample_file,\n",
    "                                       0, 0, 0, 0,\n",
    "                                       RESULT_SEVERITY.NORMAL,\n",
    "                                       additional_info=\"B\")]\n",
    "\n",
    "        self.assertEqual(results, expected)\n",
    "        uut.warn.assert_called_once_with(\n",
    "            \"'???' not found in severity-map. Assuming \"\n",
    "            \"`RESULT_SEVERITY.NORMAL`.\")\n",
    "\n",
    "        # Test when providing a sequence as output.\n",
    "        test_output = [\"\",\n",
    "                       \"12:4-14:0-Serious issue (error) -> ORIGIN=X -> XYZ\\n\"]\n",
    "        results = list(uut.process_output(test_output, sample_file, [\"\"]))\n",
    "        expected = [Result.from_values(\"EmptyTestLinter (X)\",\n",
    "                                       \"Serious issue\",\n",
    "                                       sample_file,\n",
    "                                       12, 4, 14, 0,\n",
    "                                       RESULT_SEVERITY.MAJOR,\n",
    "                                       additional_info=\"XYZ\")]\n",
    "\n",
    "        self.assertEqual(results, expected)\n",
    "\n",
    "        # Test with using `result_message` parameter.\n",
    "        uut = (linter(sys.executable,\n",
    "                      output_format=\"regex\",\n",
    "                      output_regex=regex,\n",
    "                      result_message=\"Hello world\")\n",
    "               (self.EmptyTestLinter)\n",
    "               (self.section, None))\n",
    "\n",
    "        results = list(uut.process_output(test_output, sample_file, [\"\"]))\n",
    "        expected = [Result.from_values(\"EmptyTestLinter (X)\",\n",
    "                                       \"Hello world\",\n",
    "                                       sample_file,\n",
    "                                       12, 4, 14, 0,\n",
    "                                       RESULT_SEVERITY.MAJOR,\n",
    "                                       additional_info=\"XYZ\")]\n",
    "\n",
    "        self.assertEqual(results, expected)\n",
    "\n",
    "    def test_minimal_regex(self):\n",
    "        uut = (linter(sys.executable,\n",
    "                      output_format=\"regex\",\n",
    "                      output_regex=\"an_issue\")\n",
    "               (self.EmptyTestLinter)\n",
    "               (self.section, None))\n",
    "\n",
    "        results = list(uut.process_output(['not an issue'], 'file', [\"\"]))\n",
    "        self.assertEqual(results, [])\n",
    "\n",
    "        results = list(uut.process_output(['an_issue'], 'file', [\"\"]))\n",
    "        self.assertEqual(results, [Result.from_values(\"EmptyTestLinter\", \"\",\n",
    "                                                      file=\"file\")])\n",
    "\n",
    "    def test_get_non_optional_settings(self):\n",
    "        class Handler(self.ManualProcessingTestLinter):\n",
    "\n",
    "            @staticmethod\n",
    "            def create_arguments(filename, file, config_file, param_x: int):\n",
    "                pass\n",
    "\n",
    "            @staticmethod\n",
    "            def generate_config(filename, file, superparam):\n",
    "                \"\"\"\n",
    "                :param superparam: A superparam!\n",
    "                \"\"\"\n",
    "                return None\n",
    "\n",
    "        uut = linter(sys.executable)(Handler)\n",
    "\n",
    "        self.assertEqual(uut.get_non_optional_settings(),\n",
    "                         {\"param_x\": (\"No description given.\", int),\n",
    "                          \"superparam\": (\"A superparam!\", None)})\n",
    "\n",
    "    def test_process_output_metadata_omits_on_builtin_formats(self):\n",
    "        uut = (linter(executable='', output_format='corrected')\n",
    "               (self.EmptyTestLinter))\n",
    "        # diff_severity and result_message should now not occur inside the\n",
    "        # metadata definition.\n",
    "        self.assertNotIn(\"diff_severity\", uut.get_metadata().optional_params)\n",
    "        self.assertNotIn(\"result_message\", uut.get_metadata().optional_params)\n",
    "        self.assertNotIn(\"diff_severity\",\n",
    "                         uut.get_metadata().non_optional_params)\n",
    "        self.assertNotIn(\"result_message\",\n",
    "                         uut.get_metadata().non_optional_params)\n",
    "\n",
    "        # But every parameter manually defined in process_output shall appear\n",
    "        # inside the metadata signature.\n",
    "        class Handler:\n",
    "\n",
    "            @staticmethod\n",
    "            def create_arguments(filename, file, config_file):\n",
    "                pass\n",
    "\n",
    "            @staticmethod\n",
    "            def process_output(output, filename, file, diff_severity):\n",
    "                pass\n",
    "\n",
    "        uut = linter(executable='')(Handler)\n",
    "        self.assertIn(\"diff_severity\", uut.get_metadata().non_optional_params)\n",
    "\n",
    "    def test_section_settings_forwarding(self):\n",
    "        create_arguments_mock = Mock()\n",
    "        generate_config_mock = Mock()\n",
    "        process_output_mock = Mock()\n",
    "\n",
    "        class Handler(self.ManualProcessingTestLinter):\n",
    "\n",
    "            @staticmethod\n",
    "            def create_arguments(filename, file, config_file, my_param: int):\n",
    "                create_arguments_mock(filename, file, config_file, my_param)\n",
    "                # Execute python and do nothing.\n",
    "                return \"-c\", \"print('coala!')\"\n",
    "\n",
    "            @staticmethod\n",
    "            def generate_config(filename, file, my_config_param: int):\n",
    "                generate_config_mock(filename, file, my_config_param)\n",
    "                return None\n",
    "\n",
    "            def process_output(self, output, filename, file, makman2: str):\n",
    "                process_output_mock(output, filename, file, makman2)\n",
    "\n",
    "        self.section[\"my_param\"] = \"109\"\n",
    "        self.section[\"my_config_param\"] = \"88\"\n",
    "        self.section[\"makman2\"] = \"is cool\"\n",
    "\n",
    "        uut = linter(sys.executable)(Handler)(self.section, None)\n",
    "\n",
    "        self.assertIsNotNone(list(uut.execute(filename=\"some_file.cs\",\n",
    "                                              file=[])))\n",
    "        create_arguments_mock.assert_called_once_with(\n",
    "            \"some_file.cs\", [], None, 109)\n",
    "        generate_config_mock.assert_called_once_with(\"some_file.cs\", [], 88)\n",
    "        process_output_mock.assert_called_once_with(\n",
    "            \"coala!\\n\", \"some_file.cs\", [], \"is cool\")\n",
    "\n",
    "    def test_section_settings_defaults_forwarding(self):\n",
    "        create_arguments_mock = Mock()\n",
    "        generate_config_mock = Mock()\n",
    "        process_output_mock = Mock()\n",
    "\n",
    "        class Handler:\n",
    "\n",
    "            @staticmethod\n",
    "            def generate_config(filename, file, some_default: str=\"x\"):\n",
    "                generate_config_mock(filename, file, some_default)\n",
    "                return None\n",
    "\n",
    "            @staticmethod\n",
    "            def create_arguments(filename, file, config_file, default: int=3):\n",
    "                create_arguments_mock(\n",
    "                    filename, file, config_file, default)\n",
    "                return \"-c\", \"print('hello')\"\n",
    "\n",
    "            @staticmethod\n",
    "            def process_output(output, filename, file, xxx: int=64):\n",
    "                process_output_mock(output, filename, file, xxx)\n",
    "\n",
    "        uut = linter(sys.executable)(Handler)(self.section, None)\n",
    "\n",
    "        self.assertIsNotNone(list(uut.execute(filename=\"abc.py\", file=[])))\n",
    "        create_arguments_mock.assert_called_once_with(\"abc.py\", [], None, 3)\n",
    "        generate_config_mock.assert_called_once_with(\"abc.py\", [], \"x\")\n",
    "        process_output_mock.assert_called_once_with(\n",
    "            \"hello\\n\", \"abc.py\", [], 64)\n",
    "\n",
    "        create_arguments_mock.reset_mock()\n",
    "        generate_config_mock.reset_mock()\n",
    "        process_output_mock.reset_mock()\n",
    "\n",
    "        self.section[\"default\"] = \"1000\"\n",
    "        self.section[\"some_default\"] = \"xyz\"\n",
    "        self.section[\"xxx\"] = \"-50\"\n",
    "        self.assertIsNotNone(list(uut.execute(filename=\"def.py\", file=[])))\n",
    "        create_arguments_mock.assert_called_once_with(\"def.py\", [], None, 1000)\n",
    "        generate_config_mock.assert_called_once_with(\"def.py\", [], \"xyz\")\n",
    "        process_output_mock.assert_called_once_with(\n",
    "            \"hello\\n\", \"def.py\", [], -50)\n",
    "\n",
    "    def test_invalid_arguments(self):\n",
    "\n",
    "        class InvalidArgumentsLinter(self.ManualProcessingTestLinter):\n",
    "\n",
    "            @staticmethod\n",
    "            def create_arguments(filename, file, config_file):\n",
    "                return None\n",
    "\n",
    "        uut = (linter(sys.executable)(InvalidArgumentsLinter)\n",
    "               (self.section, None))\n",
    "        self.assertEqual(uut.run(\"\", []), None)\n",
    "\n",
    "    def test_generate_config(self):\n",
    "        uut = linter(\"\")(self.ManualProcessingTestLinter)\n",
    "        with uut._create_config(\"filename\", []) as config_file:\n",
    "            self.assertIsNone(config_file)\n",
    "\n",
    "        class ConfigurationTestLinter(self.ManualProcessingTestLinter):\n",
    "\n",
    "            @staticmethod\n",
    "            def generate_config(filename, file, val):\n",
    "                return \"config_value = \" + str(val)\n",
    "\n",
    "        uut = linter(\"\", config_suffix=\".xml\")(ConfigurationTestLinter)\n",
    "        with uut._create_config(\"filename\", [], val=88) as config_file:\n",
    "            self.assertTrue(os.path.isfile(config_file))\n",
    "            self.assertEqual(config_file[-4:], \".xml\")\n",
    "            with open(config_file, mode=\"r\") as fl:\n",
    "                self.assertEqual(fl.read(), \"config_value = 88\")\n",
    "        self.assertFalse(os.path.isfile(config_file))\n",
    "\n",
    "    def test_metaclass_repr(self):\n",
    "        uut = linter(\"my-tool\")(self.ManualProcessingTestLinter)\n",
    "        self.assertEqual(\n",
    "            repr(uut),\n",
    "            \"<ManualProcessingTestLinter linter class (wrapping 'my-tool')>\")\n",
    "\n",
    "        # Test also whether derivatives change the class name accordingly.\n",
    "        class DerivedLinter(uut):\n",
    "            pass\n",
    "        self.assertEqual(repr(DerivedLinter),\n",
    "                         \"<DerivedLinter linter class (wrapping 'my-tool')>\")\n",
    "\n",
    "    def test_repr(self):\n",
    "        uut = (linter(sys.executable)\n",
    "               (self.ManualProcessingTestLinter)\n",
    "               (self.section, None))\n",
    "\n",
    "        self.assertRegex(\n",
    "            repr(uut),\n",
    "            \"<ManualProcessingTestLinter linter object \\\\(wrapping \" +\n",
    "            re.escape(repr(sys.executable)) + \"\\\\) at 0x[a-fA-F0-9]+>\")\n",
    "\n",
    "\n",
    "class LinterReallifeTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.section = Section(\"REALLIFE_TEST_SECTION\")\n",
    "\n",
    "        self.test_program_path = get_testfile_name(\"test_linter.py\")\n",
    "        self.test_program_regex = (\n",
    "            r\"L(?P<line>\\d+)C(?P<column>\\d+)-\"\n",
    "            r\"L(?P<end_line>\\d+)C(?P<end_column>\\d+):\"\n",
    "            r\" (?P<message>.*) \\| (?P<severity>.+) SEVERITY\")\n",
    "        self.test_program_severity_map = {\"MAJOR\": RESULT_SEVERITY.MAJOR}\n",
    "\n",
    "        self.testfile_path = get_testfile_name(\"test_file.txt\")\n",
    "        with open(self.testfile_path, mode=\"r\") as fl:\n",
    "            self.testfile_content = fl.read().splitlines(keepends=True)\n",
    "\n",
    "        self.testfile2_path = get_testfile_name(\"test_file2.txt\")\n",
    "        with open(self.testfile2_path, mode=\"r\") as fl:\n",
    "            self.testfile2_content = fl.read().splitlines(keepends=True)\n",
    "\n",
    "    def test_nostdin_nostderr_noconfig_nocorrection(self):\n",
    "        create_arguments_mock = Mock()\n",
    "\n",
    "        class Handler:\n",
    "\n",
    "            @staticmethod\n",
    "            def create_arguments(filename, file, config_file):\n",
    "                create_arguments_mock(filename, file, config_file)\n",
    "                return self.test_program_path, filename\n",
    "\n",
    "        uut = (linter(sys.executable,\n",
    "                      output_format=\"regex\",\n",
    "                      output_regex=self.test_program_regex,\n",
    "                      severity_map=self.test_program_severity_map)\n",
    "               (Handler)\n",
    "               (self.section, None))\n",
    "\n",
    "        results = list(uut.run(self.testfile_path, self.testfile_content))\n",
    "        expected = [Result.from_values(uut,\n",
    "                                       \"Invalid char ('0')\",\n",
    "                                       self.testfile_path,\n",
    "                                       3, 0, 3, 1,\n",
    "                                       RESULT_SEVERITY.MAJOR),\n",
    "                    Result.from_values(uut,\n",
    "                                       \"Invalid char ('.')\",\n",
    "                                       self.testfile_path,\n",
    "                                       5, 0, 5, 1,\n",
    "                                       RESULT_SEVERITY.MAJOR),\n",
    "                    Result.from_values(uut,\n",
    "                                       \"Invalid char ('p')\",\n",
    "                                       self.testfile_path,\n",
    "                                       9, 0, 9, 1,\n",
    "                                       RESULT_SEVERITY.MAJOR)]\n",
    "\n",
    "        self.assertEqual(results, expected)\n",
    "        create_arguments_mock.assert_called_once_with(\n",
    "            self.testfile_path, self.testfile_content, None)\n",
    "\n",
    "    def test_stdin_stderr_noconfig_nocorrection(self):\n",
    "        create_arguments_mock = Mock()\n",
    "\n",
    "        class Handler:\n",
    "\n",
    "            @staticmethod\n",
    "            def create_arguments(filename, file, config_file):\n",
    "                create_arguments_mock(filename, file, config_file)\n",
    "                return (self.test_program_path,\n",
    "                        \"--use_stderr\",\n",
    "                        \"--use_stdin\",\n",
    "                        filename)\n",
    "\n",
    "        uut = (linter(sys.executable,\n",
    "                      use_stdin=True,\n",
    "                      use_stdout=False,\n",
    "                      use_stderr=True,\n",
    "                      output_format=\"regex\",\n",
    "                      output_regex=self.test_program_regex,\n",
    "                      severity_map=self.test_program_severity_map)\n",
    "               (Handler)\n",
    "               (self.section, None))\n",
    "\n",
    "        results = list(uut.run(self.testfile2_path, self.testfile2_content))\n",
    "        expected = [Result.from_values(uut,\n",
    "                                       \"Invalid char ('X')\",\n",
    "                                       self.testfile2_path,\n",
    "                                       0, 0, 0, 1,\n",
    "                                       RESULT_SEVERITY.MAJOR),\n",
    "                    Result.from_values(uut,\n",
    "                                       \"Invalid char ('i')\",\n",
    "                                       self.testfile2_path,\n",
    "                                       4, 0, 4, 1,\n",
    "                                       RESULT_SEVERITY.MAJOR)]\n",
    "\n",
    "        self.assertEqual(results, expected)\n",
    "        create_arguments_mock.assert_called_once_with(\n",
    "            self.testfile2_path, self.testfile2_content, None)\n",
    "\n",
    "    def test_nostdin_nostderr_noconfig_correction(self):\n",
    "        create_arguments_mock = Mock()\n",
    "\n",
    "        class Handler:\n",
    "\n",
    "            @staticmethod\n",
    "            def create_arguments(filename, file, config_file):\n",
    "                create_arguments_mock(filename, file, config_file)\n",
    "                return self.test_program_path, \"--correct\", filename\n",
    "\n",
    "        uut = (linter(sys.executable,\n",
    "                      output_format=\"corrected\",\n",
    "                      diff_severity=RESULT_SEVERITY.INFO,\n",
    "                      result_message=\"Custom message\")\n",
    "               (Handler)\n",
    "               (self.section, None))\n",
    "\n",
    "        results = list(uut.run(self.testfile_path, self.testfile_content))\n",
    "\n",
    "        expected_correction = [s + \"\\n\"\n",
    "                               for s in [\"+\", \"-\", \"*\", \"++\", \"-\", \"-\", \"+\"]]\n",
    "\n",
    "        diffs = list(Diff.from_string_arrays(\n",
    "            self.testfile_content,\n",
    "            expected_correction).split_diff())\n",
    "\n",
    "        expected = [Result(uut, \"Custom message\",\n",
    "                           affected_code=(\n",
    "                               SourceRange.from_values(self.testfile_path, 4),\n",
    "                               SourceRange.from_values(self.testfile_path, 6)),\n",
    "                           severity=RESULT_SEVERITY.INFO,\n",
    "                           diffs={self.testfile_path: diffs[0]}),\n",
    "                    Result.from_values(uut,\n",
    "                                       \"Custom message\",\n",
    "                                       self.testfile_path,\n",
    "                                       10, None, 10, None,\n",
    "                                       RESULT_SEVERITY.INFO,\n",
    "                                       diffs={self.testfile_path: diffs[1]})]\n",
    "\n",
    "        self.assertEqual(results, expected)\n",
    "        create_arguments_mock.assert_called_once_with(\n",
    "            self.testfile_path, self.testfile_content, None)\n",
    "\n",
    "    def test_stdin_stdout_stderr_config_nocorrection(self):\n",
    "        create_arguments_mock = Mock()\n",
    "        generate_config_mock = Mock()\n",
    "\n",
    "        class Handler:\n",
    "\n",
    "            @staticmethod\n",
    "            def generate_config(filename, file, some_val):\n",
    "                # some_val shall only test the argument delegation from run().\n",
    "                generate_config_mock(filename, file, some_val)\n",
    "                return \"\\n\".join([\"use_stdin\", \"use_stderr\"])\n",
    "\n",
    "            @staticmethod\n",
    "            def create_arguments(filename, file, config_file, some_val):\n",
    "                create_arguments_mock(filename, file, config_file, some_val)\n",
    "                return self.test_program_path, \"--config\", config_file\n",
    "\n",
    "        uut = (linter(sys.executable,\n",
    "                      use_stdin=True,\n",
    "                      use_stderr=True,\n",
    "                      output_format=\"regex\",\n",
    "                      output_regex=self.test_program_regex,\n",
    "                      severity_map=self.test_program_severity_map,\n",
    "                      result_message=\"Invalid char provided!\")\n",
    "               (Handler)\n",
    "               (self.section, None))\n",
    "\n",
    "        results = list(uut.run(self.testfile_path,\n",
    "                               self.testfile_content,\n",
    "                               some_val=33))\n",
    "        expected = [Result.from_values(uut,\n",
    "                                       \"Invalid char provided!\",\n",
    "                                       self.testfile_path,\n",
    "                                       3, 0, 3, 1,\n",
    "                                       RESULT_SEVERITY.MAJOR),\n",
    "                    Result.from_values(uut,\n",
    "                                       \"Invalid char provided!\",\n",
    "                                       self.testfile_path,\n",
    "                                       5, 0, 5, 1,\n",
    "                                       RESULT_SEVERITY.MAJOR),\n",
    "                    Result.from_values(uut,\n",
    "                                       \"Invalid char provided!\",\n",
    "                                       self.testfile_path,\n",
    "                                       9, 0, 9, 1,\n",
    "                                       RESULT_SEVERITY.MAJOR)]\n",
    "\n",
    "        self.assertEqual(results, expected)\n",
    "        create_arguments_mock.assert_called_once_with(\n",
    "            self.testfile_path, self.testfile_content, ANY, 33)\n",
    "        self.assertIsNotNone(create_arguments_mock.call_args[0][2])\n",
    "        generate_config_mock.assert_called_once_with(\n",
    "            self.testfile_path, self.testfile_content, 33)\n",
    "\n",
    "    def test_stdin_stderr_config_correction(self):\n",
    "        create_arguments_mock = Mock()\n",
    "        generate_config_mock = Mock()\n",
    "\n",
    "        # `some_value_A` and `some_value_B` are used to test the different\n",
    "        # delegation to `generate_config()` and `create_arguments()`\n",
    "        # accordingly.\n",
    "        class Handler:\n",
    "\n",
    "            @staticmethod\n",
    "            def generate_config(filename, file, some_value_A):\n",
    "                generate_config_mock(filename, file, some_value_A)\n",
    "                return \"\\n\".join([\"use_stdin\", \"use_stderr\", \"correct\"])\n",
    "\n",
    "            @staticmethod\n",
    "            def create_arguments(filename, file, config_file, some_value_B):\n",
    "                create_arguments_mock(filename, file, config_file,\n",
    "                                      some_value_B)\n",
    "                return self.test_program_path, \"--config\", config_file\n",
    "\n",
    "        uut = (linter(sys.executable,\n",
    "                      use_stdin=True,\n",
    "                      use_stdout=False,\n",
    "                      use_stderr=True,\n",
    "                      output_format=\"corrected\",\n",
    "                      config_suffix=\".conf\")\n",
    "               (Handler)\n",
    "               (self.section, None))\n",
    "\n",
    "        results = list(uut.run(self.testfile2_path,\n",
    "                               self.testfile2_content,\n",
    "                               some_value_A=124,\n",
    "                               some_value_B=-78))\n",
    "\n",
    "        expected_correction = [s + \"\\n\" for s in [\"+\", \"/\", \"/\", \"-\"]]\n",
    "\n",
    "        diffs = list(Diff.from_string_arrays(\n",
    "            self.testfile2_content,\n",
    "            expected_correction).split_diff())\n",
    "\n",
    "        expected = [Result.from_values(uut,\n",
    "                                       \"Inconsistency found.\",\n",
    "                                       self.testfile2_path,\n",
    "                                       1, None, 1, None,\n",
    "                                       RESULT_SEVERITY.NORMAL,\n",
    "                                       diffs={self.testfile2_path: diffs[0]}),\n",
    "                    Result.from_values(uut,\n",
    "                                       \"Inconsistency found.\",\n",
    "                                       self.testfile2_path,\n",
    "                                       5, None, 5, None,\n",
    "                                       RESULT_SEVERITY.NORMAL,\n",
    "                                       diffs={self.testfile2_path: diffs[1]})]\n",
    "\n",
    "        self.assertEqual(results, expected)\n",
    "        create_arguments_mock.assert_called_once_with(\n",
    "            self.testfile2_path, self.testfile2_content, ANY, -78)\n",
    "        self.assertEqual(create_arguments_mock.call_args[0][2][-5:], \".conf\")\n",
    "        generate_config_mock.assert_called_once_with(\n",
    "            self.testfile2_path, self.testfile2_content, 124)\n"
  ],
  "/home/tushar/coala/tests/bearlib/abstractions/SectionCreatableTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.bearlib.abstractions.SectionCreatable import SectionCreatable\n",
    "from coalib.settings.Section import Section, Setting\n",
    "\n",
    "\n",
    "class TestObject(SectionCreatable):\n",
    "\n",
    "    def __init__(self,\n",
    "                 setting_one: int,\n",
    "                 raw_setting,\n",
    "                 setting_two: bool=False,\n",
    "                 setting_three: list=[1, 2],\n",
    "                 opt_raw_set=5):\n",
    "        SectionCreatable.__init__(self)\n",
    "        assert isinstance(setting_one, int)\n",
    "        assert isinstance(raw_setting, Setting)\n",
    "        assert isinstance(setting_two, bool)\n",
    "        assert isinstance(setting_three, list)\n",
    "        assert isinstance(opt_raw_set, Setting) or isinstance(opt_raw_set, int)\n",
    "\n",
    "        self.setting_one = setting_one\n",
    "        self.raw_setting = raw_setting\n",
    "        self.setting_two = setting_two\n",
    "        self.setting_three = setting_three\n",
    "        self.opt_raw_set = opt_raw_set\n",
    "\n",
    "\n",
    "class SectionCreatableTest(unittest.TestCase):\n",
    "\n",
    "    def test_api(self):\n",
    "        uut = SectionCreatable()\n",
    "        self.assertEqual(uut.get_non_optional_settings(), {})\n",
    "        self.assertEqual(uut.get_optional_settings(), {})\n",
    "\n",
    "    def test_needed_settings(self):\n",
    "        self.assertEqual(sorted(list(TestObject.get_non_optional_settings())),\n",
    "                         sorted([\"setting_one\", \"raw_setting\"]))\n",
    "        self.assertEqual(\n",
    "            sorted(list(TestObject.get_optional_settings())),\n",
    "            sorted([\"setting_two\", \"setting_three\", \"opt_raw_set\"]))\n",
    "\n",
    "    def test_from_section(self):\n",
    "        section = Section(\"name\")\n",
    "        section.append(Setting(\"setting_one\", \" 5\"))\n",
    "        section.append(Setting(\"raw_setting\", \" 5s\"))\n",
    "        uut = TestObject.from_section(section)\n",
    "        self.assertEqual(uut.setting_one, 5)\n",
    "        self.assertEqual(str(uut.raw_setting), \"5s\")\n",
    "        self.assertEqual(uut.setting_two, False)\n",
    "        self.assertEqual(uut.setting_three, [1, 2])\n",
    "        self.assertEqual(str(uut.opt_raw_set), \"5\")\n",
    "\n",
    "        section.append(Setting(\"setting_three\", \"2, 4\"))\n",
    "        section.append(Setting(\"opt_raw_set\", \"tst ,\"))\n",
    "        uut = TestObject.from_section(section)\n",
    "        self.assertEqual(uut.setting_one, 5)\n",
    "        self.assertEqual(str(uut.raw_setting), \"5s\")\n",
    "        self.assertEqual(uut.setting_two, False)\n",
    "        self.assertEqual(uut.setting_three, [\"2\", \"4\"])\n",
    "        self.assertEqual(str(uut.opt_raw_set), \"tst ,\")\n"
  ],
  "/home/tushar/coala/tests/bearlib/abstractions/__init__.py": [],
  "/home/tushar/coala/tests/bearlib/abstractions/linter_test_files/test_linter.py": [
    "# This little program tests whether each line begins with one of the primitive\n",
    "# math operations ``+``, ``-``, ``*`` and ``/``.\n",
    "#\n",
    "# Invocation\n",
    "# ==========\n",
    "#\n",
    "# python3 test_linter.py [--config <config-file>] [--use_stderr] [--use_stdin]\n",
    "#                        [--correct] <file-to-lint>\n",
    "#\n",
    "# Parameters\n",
    "# ==========\n",
    "#\n",
    "# --config      Use a config file located at <config-file>. Other arguments are\n",
    "#               ignored when supplying this.\n",
    "#               A config file contains in each line a flag that resemble the\n",
    "#               command-line-flags that are ignored from the\n",
    "#               command-line-interface without the leading \"--\". So valid\n",
    "#               values for each line inside the config are \"use_stderr\",\n",
    "#               \"use_stdin\" and \"correct\".\n",
    "# --use_stderr  Output to stderr instead of stdout.\n",
    "# --use_stdin   Whether to take file <file-to-lint> or grab lint-contents\n",
    "#               directly from stdin. Supplying this makes <file-to-lint>\n",
    "#               obsolete.\n",
    "# --correct     Whether to output the auto-corrected file-content instead of\n",
    "#               issue messages. The correction consists of removing invalid\n",
    "#               lines.\n",
    "\n",
    "import sys\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    if \"--config\" in sys.argv:\n",
    "        config_file = sys.argv[sys.argv.index(\"--config\") + 1]\n",
    "        with open(config_file, mode=\"r\") as fl:\n",
    "            config_content = fl.read().splitlines()\n",
    "\n",
    "        output_file = (sys.stderr\n",
    "                       if \"use_stderr\" in config_content else\n",
    "                       sys.stdout)\n",
    "        correct = \"correct\" in config_content\n",
    "        use_stdin = \"use_stdin\" in config_content\n",
    "    else:\n",
    "        if \"--use_stderr\" in sys.argv:\n",
    "            output_file = sys.stderr\n",
    "        else:\n",
    "            output_file = sys.stdout\n",
    "\n",
    "        correct = \"--correct\" in sys.argv\n",
    "        use_stdin = \"--use_stdin\" in sys.argv\n",
    "\n",
    "    if use_stdin:\n",
    "        content = sys.stdin.read()\n",
    "    else:\n",
    "        filename = sys.argv[-1]\n",
    "        with open(filename, mode=\"r\") as fl:\n",
    "            content = fl.read()\n",
    "\n",
    "    for i, line in enumerate(content.splitlines()):\n",
    "        if line[0] not in (\"+\", \"-\", \"*\", \"/\"):\n",
    "            if not correct:\n",
    "                print(\"L{}C{}-L{}C{}: Invalid char ('{}') | \"\n",
    "                      \"MAJOR SEVERITY\".format(i, 0, i, 1, line[0]),\n",
    "                      file=output_file)\n",
    "            # If `correct` is True just leave out the line since it's invalid.\n",
    "        else:\n",
    "            if correct:\n",
    "                print(line, file=output_file)\n"
  ],
  "/home/tushar/coala/tests/bearlib/languages/LanguageDefinitionTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.bearlib.languages.LanguageDefinition import LanguageDefinition\n",
    "from coalib.settings.Section import Section\n",
    "from coalib.settings.Setting import Setting\n",
    "\n",
    "\n",
    "class LanguageDefinitionTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.section = Section(\"any\")\n",
    "        self.section.append(Setting(\"language_family\", \"C\"))\n",
    "        self.section.append(Setting(\"language\", \"CPP\"))\n",
    "\n",
    "    def test_nonexistant_file(self):\n",
    "        self.section.append(Setting(\"language\", \"bullshit\"))\n",
    "\n",
    "        with self.assertRaises(KeyError):\n",
    "            LanguageDefinition.from_section(self.section)\n",
    "\n",
    "        self.section.append(Setting(\"language_family\", \"bullshit\"))\n",
    "        with self.assertRaises(FileNotFoundError):\n",
    "            LanguageDefinition.from_section(self.section)\n",
    "\n",
    "    def test_loading(self):\n",
    "        uut = LanguageDefinition.from_section(self.section)\n",
    "        self.assertEqual(list(uut[\"extensions\"]), [\".c\", \".cpp\", \".h\", \".hpp\"])\n",
    "\n",
    "    def test_key_contains(self):\n",
    "        uut = LanguageDefinition.from_section(self.section)\n",
    "        self.assertIn(\"extensions\", uut)\n",
    "        self.assertNotIn(\"randomstuff\", uut)\n"
  ],
  "/home/tushar/coala/tests/bearlib/languages/__init__.py": [],
  "/home/tushar/coala/tests/bearlib/languages/documentation/DocstyleDefinitionTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.bearlib.languages.documentation.DocstyleDefinition import (\n",
    "    DocstyleDefinition)\n",
    "\n",
    "\n",
    "class DocstyleDefinitionTest(unittest.TestCase):\n",
    "\n",
    "    def test_fail_instantation(self):\n",
    "        with self.assertRaises(ValueError):\n",
    "            DocstyleDefinition(\"PYTHON\", \"doxyGEN\", ((\"##\", \"#\"),))\n",
    "\n",
    "        with self.assertRaises(ValueError):\n",
    "            DocstyleDefinition(\"WEIRD-PY\",\n",
    "                               \"schloxygen\",\n",
    "                               ((\"##+\", \"x\", \"y\", \"z\"),))\n",
    "\n",
    "        with self.assertRaises(ValueError):\n",
    "            DocstyleDefinition(\"PYTHON\",\n",
    "                               \"doxygen\",\n",
    "                               ((\"##\", \"\", \"#\"), ('\"\"\"', '\"\"\"')))\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            DocstyleDefinition(123, [\"doxygen\"], (('\"\"\"', '\"\"\"')))\n",
    "\n",
    "    def test_properties(self):\n",
    "        uut = DocstyleDefinition(\"C\", \"doxygen\", ((\"/**\", \"*\", \"*/\"),))\n",
    "\n",
    "        self.assertEqual(uut.language, \"c\")\n",
    "        self.assertEqual(uut.docstyle, \"doxygen\")\n",
    "        self.assertEqual(uut.markers, ((\"/**\", \"*\", \"*/\"),))\n",
    "\n",
    "        uut = DocstyleDefinition(\"PYTHON\", \"doxyGEN\", [(\"##\", \"\", \"#\")])\n",
    "\n",
    "        self.assertEqual(uut.language, \"python\")\n",
    "        self.assertEqual(uut.docstyle, \"doxygen\")\n",
    "        self.assertEqual(uut.markers, ((\"##\", \"\", \"#\"),))\n",
    "\n",
    "        uut = DocstyleDefinition(\"I2C\",\n",
    "                                 \"my-custom-tool\",\n",
    "                                 ([\"~~\", \"/~\", \"/~\"], (\">!\", \">>\", \">>\")))\n",
    "\n",
    "        self.assertEqual(uut.language, \"i2c\")\n",
    "        self.assertEqual(uut.docstyle, \"my-custom-tool\")\n",
    "        self.assertEqual(uut.markers, ((\"~~\", \"/~\", \"/~\"), (\">!\", \">>\", \">>\")))\n",
    "\n",
    "        uut = DocstyleDefinition(\"Cpp\", \"doxygen\", (\"~~\", \"/~\", \"/~\"))\n",
    "\n",
    "        self.assertEqual(uut.language, \"cpp\")\n",
    "        self.assertEqual(uut.docstyle, \"doxygen\")\n",
    "        self.assertEqual(uut.markers, ((\"~~\", \"/~\", \"/~\"),))\n",
    "\n",
    "    def test_load(self):\n",
    "        # Test unregistered docstyle.\n",
    "        with self.assertRaises(FileNotFoundError):\n",
    "            next(DocstyleDefinition.load(\"PYTHON\", \"INVALID\"))\n",
    "\n",
    "        # Test unregistered language in existing docstyle.\n",
    "        with self.assertRaises(KeyError):\n",
    "            next(DocstyleDefinition.load(\"bake-a-cake\", \"default\"))\n",
    "\n",
    "        # Test wrong argument type.\n",
    "        with self.assertRaises(TypeError):\n",
    "            next(DocstyleDefinition.load(123, [\"list\"]))\n",
    "\n",
    "        # Test python 3 default configuration and if everything is parsed\n",
    "        # right.\n",
    "        result = DocstyleDefinition.load(\"PYTHON3\", \"default\")\n",
    "\n",
    "        self.assertEqual(result.language, \"python3\")\n",
    "        self.assertEqual(result.docstyle, \"default\")\n",
    "        self.assertEqual(result.markers, (('\"\"\"', '', '\"\"\"'),))\n"
  ],
  "/home/tushar/coala/tests/bearlib/languages/documentation/DocumentationCommentTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.bearlib.languages.documentation.DocumentationComment import (\n",
    "    DocumentationComment)\n",
    "\n",
    "\n",
    "class DocumentationCommentTest(unittest.TestCase):\n",
    "\n",
    "    def test_fields(self):\n",
    "        uut = DocumentationComment(\"my doc\",\n",
    "                                   (\"/**\", \"*\", \"*/\"),\n",
    "                                   (25, 45))\n",
    "\n",
    "        self.assertEqual(uut.documentation, \"my doc\")\n",
    "        self.assertEqual(str(uut), \"my doc\")\n",
    "        self.assertEqual(uut.marker, (\"/**\", \"*\", \"*/\"))\n",
    "        self.assertEqual(uut.range, (25, 45))\n",
    "\n",
    "        uut = DocumentationComment(\"qwertzuiop\",\n",
    "                                   (\"##\", \"#\", \"#\"),\n",
    "                                   None)\n",
    "\n",
    "        self.assertEqual(uut.documentation, \"qwertzuiop\")\n",
    "        self.assertEqual(str(uut), \"qwertzuiop\")\n",
    "        self.assertEqual(uut.marker, (\"##\", \"#\", \"#\"))\n",
    "        self.assertEqual(uut.range, None)\n"
  ],
  "/home/tushar/coala/tests/bearlib/languages/documentation/DocumentationExtractionTest.py": [
    "import os.path\n",
    "import unittest\n",
    "\n",
    "from coalib.bearlib.languages.documentation.DocstyleDefinition import (\n",
    "    DocstyleDefinition)\n",
    "from coalib.bearlib.languages.documentation.DocumentationComment import (\n",
    "    DocumentationComment)\n",
    "from coalib.bearlib.languages.documentation.DocumentationExtraction import (\n",
    "    extract_documentation)\n",
    "from coalib.results.TextRange import TextRange\n",
    "\n",
    "\n",
    "class DocumentationExtractionTest(unittest.TestCase):\n",
    "\n",
    "    def test_extract_documentation_invalid_input(self):\n",
    "        with self.assertRaises(FileNotFoundError):\n",
    "            tuple(extract_documentation(\"\", \"PYTHON\", \"INVALID\"))\n",
    "\n",
    "    @staticmethod\n",
    "    def load_testdata(filename):\n",
    "        filename = (os.path.dirname(os.path.realpath(__file__)) +\n",
    "                    \"/documentation_extraction_testdata/\" + filename)\n",
    "        with open(filename, \"r\") as fl:\n",
    "            data = fl.read()\n",
    "\n",
    "        return data.splitlines(keepends=True)\n",
    "\n",
    "    def test_extract_documentation_C(self):\n",
    "        data = DocumentationExtractionTest.load_testdata(\"data.c\")\n",
    "\n",
    "        # No built-in documentation for C.\n",
    "        with self.assertRaises(KeyError):\n",
    "            tuple(extract_documentation(data, \"C\", \"default\"))\n",
    "\n",
    "        docstyle_C_doxygen = DocstyleDefinition.load(\"C\", \"doxygen\")\n",
    "\n",
    "        expected_results = (DocumentationComment(\n",
    "                                (\"\\n\"\n",
    "                                 \" This is the main function.\\n\"\n",
    "                                 \"\\n\"\n",
    "                                 \" @returns Your favorite number.\\n\"),\n",
    "                                docstyle_C_doxygen.markers[0],\n",
    "                                TextRange.from_values(3, 1, 7, 4)),\n",
    "                            DocumentationComment(\n",
    "                                (\"\\n\"\n",
    "                                 \" Preserves alignment\\n\"\n",
    "                                 \" - Main item\\n\"\n",
    "                                 \"   - sub item\\n\"\n",
    "                                 \"     - sub sub item\\n\"),\n",
    "                                docstyle_C_doxygen.markers[2],\n",
    "                                TextRange.from_values(15, 1, 20, 4)),\n",
    "                            DocumentationComment(\n",
    "                                (\" ABC\\n\"\n",
    "                                 \"    Another type of comment\\n\"\n",
    "                                 \"\\n\"\n",
    "                                 \"    ...\"),\n",
    "                                docstyle_C_doxygen.markers[1],\n",
    "                                TextRange.from_values(23, 1, 26, 11)),\n",
    "                            DocumentationComment(\n",
    "                                (\" foobar = barfoo.\\n\"\n",
    "                                 \" @param x whatever...\\n\"),\n",
    "                                docstyle_C_doxygen.markers[0],\n",
    "                                TextRange.from_values(28, 1, 30, 4)))\n",
    "\n",
    "        self.assertEqual(tuple(extract_documentation(data, \"C\", \"doxygen\")),\n",
    "                         expected_results)\n",
    "\n",
    "    def test_extract_documentation_C_2(self):\n",
    "        data = ['/** my main description\\n', ' * continues here */']\n",
    "\n",
    "        docstyle_C_doxygen = DocstyleDefinition.load(\"C\", \"doxygen\")\n",
    "\n",
    "        self.assertEqual(\n",
    "            list(extract_documentation(data, \"C\", \"doxygen\")),\n",
    "            [DocumentationComment(\" my main description\\n continues here\",\n",
    "                                  docstyle_C_doxygen.markers[0],\n",
    "                                  TextRange.from_values(1, 1, 2, 21))])\n",
    "\n",
    "    def test_extract_documentation_CPP(self):\n",
    "        data = DocumentationExtractionTest.load_testdata(\"data.cpp\")\n",
    "\n",
    "        # No built-in documentation for C++.\n",
    "        with self.assertRaises(KeyError):\n",
    "            tuple(extract_documentation(data, \"CPP\", \"default\"))\n",
    "\n",
    "        docstyle_CPP_doxygen = DocstyleDefinition.load(\"CPP\", \"doxygen\")\n",
    "\n",
    "        self.assertEqual(tuple(extract_documentation(data, \"CPP\", \"doxygen\")),\n",
    "                         (DocumentationComment(\n",
    "                              (\"\\n\"\n",
    "                               \" This is the main function.\\n\"\n",
    "                               \" @returns Exit code.\\n\"\n",
    "                               \"          Or any other number.\\n\"),\n",
    "                              docstyle_CPP_doxygen.markers[0],\n",
    "                              TextRange.from_values(4, 1, 8, 4)),\n",
    "                          DocumentationComment(\n",
    "                              (\" foobar\\n\"\n",
    "                               \" @param xyz\\n\"),\n",
    "                              docstyle_CPP_doxygen.markers[0],\n",
    "                              TextRange.from_values(15, 1, 17, 4)),\n",
    "                          DocumentationComment(\n",
    "                              \" Some alternate style of documentation\\n\",\n",
    "                              docstyle_CPP_doxygen.markers[4],\n",
    "                              TextRange.from_values(22, 1, 23, 1)),\n",
    "                          DocumentationComment(\n",
    "                              \" ends instantly\",\n",
    "                              docstyle_CPP_doxygen.markers[0],\n",
    "                              TextRange.from_values(26, 5, 26, 26)),\n",
    "                          DocumentationComment(\n",
    "                              (\" Should work\\n\"\n",
    "                               \"\\n\"\n",
    "                               \" even without a function standing below.\\n\"\n",
    "                               \"\\n\"\n",
    "                               \" @param foo WHAT PARAM PLEASE!?\\n\"),\n",
    "                              docstyle_CPP_doxygen.markers[4],\n",
    "                              TextRange.from_values(32, 1, 37, 1))))\n",
    "\n",
    "    def test_extract_documentation_CPP_2(self):\n",
    "        data = DocumentationExtractionTest.load_testdata(\"data2.cpp\")\n",
    "\n",
    "        docstyle_CPP_doxygen = DocstyleDefinition.load(\"CPP\", \"doxygen\")\n",
    "\n",
    "        self.assertEqual(tuple(extract_documentation(data, \"CPP\", \"doxygen\")),\n",
    "                         (DocumentationComment(\n",
    "                              (\"module comment\\n\"\n",
    "                               \" hello world\\n\"),\n",
    "                              docstyle_CPP_doxygen.markers[0],\n",
    "                              TextRange.from_values(1, 1, 3, 4)),))\n",
    "\n",
    "    def test_extract_documentation_PYTHON3(self):\n",
    "        data = DocumentationExtractionTest.load_testdata(\"data.py\")\n",
    "\n",
    "        docstyle_PYTHON3_default = DocstyleDefinition.load(\"PYTHON3\",\n",
    "                                                           \"default\")\n",
    "        docstyle_PYTHON3_doxygen = DocstyleDefinition.load(\"PYTHON3\",\n",
    "                                                           \"doxygen\")\n",
    "\n",
    "        expected = (DocumentationComment(\n",
    "                        (\"\\n\"\n",
    "                         \"Module description.\\n\"\n",
    "                         \"\\n\"\n",
    "                         \"Some more foobar-like text.\\n\"),\n",
    "                        docstyle_PYTHON3_default.markers[0],\n",
    "                        TextRange.from_values(1, 1, 5, 4)),\n",
    "                    DocumentationComment(\n",
    "                        (\"\\n\"\n",
    "                         \"A nice and neat way of documenting code.\\n\"\n",
    "                         \":param radius: The explosion radius.\\n\"),\n",
    "                        docstyle_PYTHON3_default.markers[0],\n",
    "                        TextRange.from_values(8, 5, 11, 8)),\n",
    "                    DocumentationComment(\n",
    "                        (\"\\n\"\n",
    "                         \"Docstring with layouted text.\\n\"\n",
    "                         \"\\n\"\n",
    "                         \"    layouts inside docs are preserved for these \"\n",
    "                         \"documentation styles.\\n\"\n",
    "                         \"this is intended.\\n\"),\n",
    "                        docstyle_PYTHON3_default.markers[0],\n",
    "                        TextRange.from_values(14, 1, 19, 4)),\n",
    "                    DocumentationComment(\n",
    "                        (\" Docstring directly besides triple quotes.\\n\"\n",
    "                         \"    Continues here. \"),\n",
    "                        docstyle_PYTHON3_default.markers[0],\n",
    "                        TextRange.from_values(21, 1, 22, 24)),\n",
    "                    DocumentationComment(\n",
    "                        (\"super\\n\"\n",
    "                         \" nicely\\n\"\n",
    "                         \"short\"),\n",
    "                        docstyle_PYTHON3_default.markers[0],\n",
    "                        TextRange.from_values(35, 1, 37, 9)))\n",
    "\n",
    "        self.assertEqual(\n",
    "            tuple(extract_documentation(data, \"PYTHON3\", \"default\")),\n",
    "            expected)\n",
    "\n",
    "        # Change only the docstyle in expected results.\n",
    "        expected = list(DocumentationComment(r.documentation,\n",
    "                                             r.marker,\n",
    "                                             r.range)\n",
    "                        for r in expected)\n",
    "\n",
    "        expected.insert(4, DocumentationComment(\n",
    "            (\" Alternate documentation style in doxygen.\\n\"\n",
    "             \"  Subtext\\n\"\n",
    "             \" More subtext (not correctly aligned)\\n\"\n",
    "             \"      sub-sub-text\\n\"\n",
    "             \"\\n\"),\n",
    "            docstyle_PYTHON3_doxygen.markers[1],\n",
    "            TextRange.from_values(25, 1, 30, 1)))\n",
    "\n",
    "        self.assertEqual(\n",
    "            list(extract_documentation(data, \"PYTHON3\", \"doxygen\")),\n",
    "            expected)\n",
    "\n",
    "    def test_extract_documentation_PYTHON3_2(self):\n",
    "        data = ['\\n', '\"\"\" documentation in single line  \"\"\"\\n', 'print(1)\\n']\n",
    "\n",
    "        docstyle_PYTHON3_default = DocstyleDefinition.load(\"PYTHON3\",\n",
    "                                                           \"default\")\n",
    "\n",
    "        self.assertEqual(\n",
    "            list(extract_documentation(data, \"PYTHON3\", \"default\")),\n",
    "            [DocumentationComment(\" documentation in single line  \",\n",
    "                                  docstyle_PYTHON3_default.markers[0],\n",
    "                                  TextRange.from_values(2, 1, 2, 38))])\n",
    "\n",
    "    def test_extract_documentation_PYTHON3_3(self):\n",
    "        data = ['## documentation in single line without return at end.']\n",
    "\n",
    "        docstyle_PYTHON3_doxygen = DocstyleDefinition.load(\"PYTHON3\",\n",
    "                                                           \"doxygen\")\n",
    "\n",
    "        self.assertEqual(\n",
    "            list(extract_documentation(data, \"PYTHON3\", \"doxygen\")),\n",
    "            [DocumentationComment(\" documentation in single line without \"\n",
    "                                  \"return at end.\",\n",
    "                                  docstyle_PYTHON3_doxygen.markers[1],\n",
    "                                  TextRange.from_values(1, 1, 1, 55))])\n"
  ],
  "/home/tushar/coala/tests/bearlib/parsing/__init__.py": [],
  "/home/tushar/coala/tests/bearlib/spacing/SpacingHelperTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.bearlib.spacing.SpacingHelper import SpacingHelper\n",
    "from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "class SpacingHelperTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.uut = SpacingHelper()\n",
    "\n",
    "    def test_needed_settings(self):\n",
    "        self.assertEqual(list(self.uut.get_optional_settings()), [\"tab_width\"])\n",
    "        self.assertEqual(list(self.uut.get_non_optional_settings()), [])\n",
    "\n",
    "    def test_construction(self):\n",
    "        section = Section(\"test section\")\n",
    "        self.assertRaises(TypeError, SpacingHelper, \"no integer\")\n",
    "        self.assertRaises(TypeError, self.uut.from_section, 5)\n",
    "\n",
    "        self.assertEqual(self.uut.tab_width,\n",
    "                         self.uut.from_section(section).tab_width)\n",
    "\n",
    "        # This is assumed in some tests. If you want to change this value, be\n",
    "        # sure to change the tests too\n",
    "        self.assertEqual(self.uut.DEFAULT_TAB_WIDTH, 4)\n",
    "        self.assertEqual(self.uut.tab_width, self.uut.DEFAULT_TAB_WIDTH)\n",
    "\n",
    "    def test_get_indentation(self):\n",
    "        self.assertRaises(TypeError, self.uut.get_indentation, 5)\n",
    "\n",
    "        self.assertEqual(self.uut.get_indentation(\"no indentation\"), 0)\n",
    "        self.assertEqual(self.uut.get_indentation(\" indentation\"), 1)\n",
    "        self.assertEqual(self.uut.get_indentation(\"  indentation\"), 2)\n",
    "        self.assertEqual(self.uut.get_indentation(\"\\tindentation\"),\n",
    "                         self.uut.DEFAULT_TAB_WIDTH)\n",
    "\n",
    "        # Having a space before the tab shouldn't make any difference\n",
    "        self.assertEqual(self.uut.get_indentation(\" \\tindentation\"),\n",
    "                         self.uut.DEFAULT_TAB_WIDTH)\n",
    "        self.assertEqual(self.uut.get_indentation(\" \\t indentation\"),\n",
    "                         self.uut.DEFAULT_TAB_WIDTH+1)\n",
    "        self.assertEqual(self.uut.get_indentation(\"\\t indentation\"),\n",
    "                         self.uut.DEFAULT_TAB_WIDTH+1)\n",
    "\n",
    "        # same tests but with indentation only\n",
    "        self.assertEqual(self.uut.get_indentation(\"\\t\"),\n",
    "                         self.uut.DEFAULT_TAB_WIDTH)\n",
    "        self.assertEqual(self.uut.get_indentation(\" \\t\"),\n",
    "                         self.uut.DEFAULT_TAB_WIDTH)\n",
    "        self.assertEqual(self.uut.get_indentation(\" \\t \"),\n",
    "                         self.uut.DEFAULT_TAB_WIDTH+1)\n",
    "        self.assertEqual(self.uut.get_indentation(\"\\t \"),\n",
    "                         self.uut.DEFAULT_TAB_WIDTH+1)\n",
    "        self.assertEqual(self.uut.get_indentation(\"\\t\\t\"),\n",
    "                         self.uut.DEFAULT_TAB_WIDTH*2)\n",
    "\n",
    "    def test_replace_tabs_with_spaces(self):\n",
    "        self.assertRaises(TypeError, self.uut.replace_tabs_with_spaces, 5)\n",
    "\n",
    "        self.assertEqual(self.uut.replace_tabs_with_spaces(\"\"), \"\")\n",
    "        self.assertEqual(self.uut.replace_tabs_with_spaces(\" \"), \" \")\n",
    "        self.assertEqual(self.uut.replace_tabs_with_spaces(\"\\t\"),\n",
    "                         \" \"*self.uut.DEFAULT_TAB_WIDTH)\n",
    "        self.assertEqual(self.uut.replace_tabs_with_spaces(\"\\t\\t\"),\n",
    "                         \" \"*self.uut.DEFAULT_TAB_WIDTH*2)\n",
    "        self.assertEqual(self.uut.replace_tabs_with_spaces(\" \\t\"),\n",
    "                         \" \"*self.uut.DEFAULT_TAB_WIDTH)\n",
    "        self.assertEqual(self.uut.replace_tabs_with_spaces(\"  \\t\"),\n",
    "                         \" \"*self.uut.DEFAULT_TAB_WIDTH)\n",
    "        self.assertEqual(self.uut.replace_tabs_with_spaces(\"d \\t \"),\n",
    "                         \"d\" + \" \"*self.uut.DEFAULT_TAB_WIDTH)\n",
    "\n",
    "    def test_replace_spaces_with_tabs(self):\n",
    "        self.assertRaises(TypeError, self.uut.replace_spaces_with_tabs, 5)\n",
    "\n",
    "        self.assertEqual(self.uut.replace_spaces_with_tabs(\"\"), \"\")\n",
    "        self.assertEqual(self.uut.replace_spaces_with_tabs(\" \"), \" \")\n",
    "        self.assertEqual(self.uut.replace_spaces_with_tabs(\"    \"), \"\\t\")\n",
    "        self.assertEqual(self.uut.replace_spaces_with_tabs(\"   \\t\"), \"\\t\")\n",
    "        self.assertEqual(self.uut.replace_spaces_with_tabs(\"   dd  \"),\n",
    "                         \"   dd  \")\n",
    "        self.assertEqual(self.uut.replace_spaces_with_tabs(\"   dd d \"),\n",
    "                         \"   dd d \")  # One space shouldnt be replaced\n",
    "        self.assertEqual(self.uut.replace_spaces_with_tabs(\"   dd   \"),\n",
    "                         \"   dd\\t\")\n",
    "        self.assertEqual(\n",
    "            self.uut.replace_spaces_with_tabs(\" \\t   a_text   another\"),\n",
    "            \"\\t   a_text\\tanother\")\n",
    "        self.assertEqual(self.uut.replace_spaces_with_tabs(\"d  d\"), \"d  d\")\n"
  ],
  "/home/tushar/coala/tests/bearlib/spacing/__init__.py": [],
  "/home/tushar/coala/tests/bears/BearTest.py": [
    "import multiprocessing\n",
    "import unittest\n",
    "from os.path import abspath\n",
    "\n",
    "from coalib.bears.Bear import Bear\n",
    "from coalib.output.printers.LOG_LEVEL import LOG_LEVEL\n",
    "from coalib.processes.communication.LogMessage import LogMessage\n",
    "from coalib.settings.Section import Section\n",
    "from coalib.settings.Setting import Setting\n",
    "\n",
    "\n",
    "class TestBear(Bear):\n",
    "\n",
    "    def __init__(self, section, queue):\n",
    "        Bear.__init__(self, section, queue)\n",
    "\n",
    "    def run(self):\n",
    "        self.print(\"set\", \"up\", delimiter=\"=\")\n",
    "        self.err(\"teardown\")\n",
    "        self.err()\n",
    "\n",
    "    @staticmethod\n",
    "    def get_dependencies():\n",
    "        return [BadTestBear]\n",
    "\n",
    "\n",
    "class BadTestBear(Bear):\n",
    "\n",
    "    def __init__(self, section, queue):\n",
    "        Bear.__init__(self, section, queue)\n",
    "\n",
    "    def run(self):\n",
    "        raise NotImplementedError\n",
    "\n",
    "\n",
    "class TypedTestBear(Bear):\n",
    "\n",
    "    def __init__(self, section, queue):\n",
    "        Bear.__init__(self, section, queue)\n",
    "        self.was_executed = False\n",
    "\n",
    "    def run(self, something: int):\n",
    "        self.was_executed = True\n",
    "        return []\n",
    "\n",
    "\n",
    "class BearWithPrerequisites(Bear):\n",
    "    prerequisites_fulfilled = True\n",
    "\n",
    "    def __init__(self, section, queue, prerequisites_fulfilled):\n",
    "        BearWithPrerequisites.prerequisites_fulfilled = prerequisites_fulfilled\n",
    "        Bear.__init__(self, section, queue)\n",
    "        self.was_executed = False\n",
    "\n",
    "    def run(self):\n",
    "        self.was_executed = True\n",
    "        return []\n",
    "\n",
    "    @classmethod\n",
    "    def check_prerequisites(cls):\n",
    "        return cls.prerequisites_fulfilled\n",
    "\n",
    "\n",
    "class BearTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.queue = multiprocessing.Queue()\n",
    "        self.settings = Section(\"test_settings\")\n",
    "        self.uut = TestBear(self.settings, self.queue)\n",
    "\n",
    "    def test_simple_api(self):\n",
    "        self.assertRaises(TypeError, TestBear, self.settings, 2)\n",
    "        self.assertRaises(TypeError, TestBear, None, self.queue)\n",
    "        self.assertRaises(NotImplementedError, self.uut.kind)\n",
    "\n",
    "        base = Bear(self.settings, None)\n",
    "        self.assertRaises(NotImplementedError, base.run)\n",
    "        self.assertEqual(base.get_non_optional_settings(), {})\n",
    "\n",
    "    def test_message_queue(self):\n",
    "        self.uut.execute()\n",
    "        self.check_message(LOG_LEVEL.DEBUG,\n",
    "                           \"Running bear TestBear...\")\n",
    "        self.check_message(LOG_LEVEL.DEBUG, \"set=up\")\n",
    "        self.check_message(LOG_LEVEL.ERROR, \"teardown\")\n",
    "\n",
    "    def test_bad_bear(self):\n",
    "        self.uut = BadTestBear(self.settings, self.queue)\n",
    "        self.uut.execute()\n",
    "        self.check_message(LOG_LEVEL.DEBUG)\n",
    "        self.check_message(LOG_LEVEL.WARNING,\n",
    "                           \"Bear BadTestBear failed to run. Take a look at \"\n",
    "                           \"debug messages for further information.\")\n",
    "        # debug message contains custom content, dont test this here\n",
    "        self.queue.get()\n",
    "\n",
    "    def test_inconvertible(self):\n",
    "        self.uut = TypedTestBear(self.settings, self.queue)\n",
    "        self.settings.append(Setting(\"something\", \"5\"))\n",
    "        self.uut.execute()\n",
    "        self.check_message(LOG_LEVEL.DEBUG)\n",
    "        self.assertTrue(self.uut.was_executed)\n",
    "\n",
    "        self.settings.append(Setting(\"something\", \"nonsense\"))\n",
    "        self.uut.was_executed = False\n",
    "        self.uut.execute()\n",
    "        self.check_message(LOG_LEVEL.DEBUG)\n",
    "        self.check_message(LOG_LEVEL.WARNING)\n",
    "        self.assertTrue(self.queue.empty())\n",
    "        self.assertFalse(self.uut.was_executed)\n",
    "\n",
    "    def check_message(self, log_level, message=None):\n",
    "        msg = self.queue.get()\n",
    "        self.assertIsInstance(msg, LogMessage)\n",
    "        if message:\n",
    "            self.assertEqual(msg.message, message)\n",
    "\n",
    "        self.assertEqual(msg.log_level, log_level, msg)\n",
    "\n",
    "    def test_no_queue(self):\n",
    "        uut = TestBear(self.settings, None)\n",
    "        uut.execute()  # No exceptions\n",
    "\n",
    "    def test_dependencies(self):\n",
    "        self.assertEqual(Bear.get_dependencies(), [])\n",
    "        self.assertEqual(Bear.missing_dependencies([]), [])\n",
    "        self.assertEqual(Bear.missing_dependencies([BadTestBear]), [])\n",
    "\n",
    "        self.assertEqual(TestBear.missing_dependencies([]), [BadTestBear])\n",
    "        self.assertEqual(TestBear.missing_dependencies([BadTestBear]), [])\n",
    "        self.assertEqual(TestBear.missing_dependencies([TestBear]),\n",
    "                         [BadTestBear])\n",
    "        self.assertEqual(TestBear.missing_dependencies([TestBear,\n",
    "                                                        BadTestBear]),\n",
    "                         [])\n",
    "\n",
    "    def test_check_prerequisites(self):\n",
    "        uut = BearWithPrerequisites(self.settings, self.queue, True)\n",
    "        uut.execute()\n",
    "        self.check_message(LOG_LEVEL.DEBUG)\n",
    "        self.assertTrue(self.queue.empty())\n",
    "        self.assertTrue(uut.was_executed)\n",
    "\n",
    "        self.assertRaisesRegex(RuntimeError,\n",
    "                               \"The bear BearWithPrerequisites does not \"\n",
    "                               \"fulfill all requirements\\\\.\",\n",
    "                               BearWithPrerequisites,\n",
    "                               self.settings,\n",
    "                               self.queue,\n",
    "                               False)\n",
    "\n",
    "        self.check_message(LOG_LEVEL.WARNING,\n",
    "                           \"The bear BearWithPrerequisites does not fulfill \"\n",
    "                           \"all requirements.\")\n",
    "        self.assertTrue(self.queue.empty())\n",
    "\n",
    "        self.assertRaisesRegex(RuntimeError,\n",
    "                               \"The bear BearWithPrerequisites does not \"\n",
    "                               \"fulfill all requirements\\\\. Just because \"\n",
    "                               \"I want to\\\\.\",\n",
    "                               BearWithPrerequisites,\n",
    "                               self.settings,\n",
    "                               self.queue,\n",
    "                               \"Just because I want to.\")\n",
    "\n",
    "        self.check_message(LOG_LEVEL.WARNING,\n",
    "                           \"The bear BearWithPrerequisites does not fulfill \"\n",
    "                           \"all requirements. Just because I want to.\")\n",
    "        self.assertTrue(self.queue.empty())\n",
    "\n",
    "    def test_get_config_dir(self):\n",
    "        section = Section(\"default\")\n",
    "        section.append(Setting(\"files\", \"**\", \"/path/to/dir/config\"))\n",
    "        uut = TestBear(section, None)\n",
    "        self.assertEqual(uut.get_config_dir(), abspath(\"/path/to/dir\"))\n"
  ],
  "/home/tushar/coala/tests/bears/GlobalBearTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.bears.GlobalBear import BEAR_KIND, GlobalBear\n",
    "from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "class GlobalBearTest(unittest.TestCase):\n",
    "\n",
    "    def test_api(self):\n",
    "        test_object = GlobalBear(0, Section(\"name\"), None)\n",
    "        self.assertRaises(NotImplementedError, test_object.run)\n",
    "\n",
    "    def test_kind(self):\n",
    "        self.assertEqual(GlobalBear.kind(), BEAR_KIND.GLOBAL)\n"
  ],
  "/home/tushar/coala/tests/bears/LocalBearTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.bears.LocalBear import BEAR_KIND, LocalBear\n",
    "from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "class LocalBearTest(unittest.TestCase):\n",
    "\n",
    "    def test_api(self):\n",
    "        test_object = LocalBear(Section(\"name\"), None)\n",
    "        self.assertRaises(NotImplementedError,\n",
    "                          test_object.run,\n",
    "                          \"filename\",\n",
    "                          [\"file\\n\"])\n",
    "\n",
    "    def test_kind(self):\n",
    "        self.assertEqual(LocalBear.kind(), BEAR_KIND.LOCAL)\n"
  ],
  "/home/tushar/coala/tests/bears/__init__.py": [],
  "/home/tushar/coala/tests/coalaCITest.py": [
    "import os\n",
    "import re\n",
    "import sys\n",
    "import unittest\n",
    "from tempfile import NamedTemporaryFile, TemporaryDirectory\n",
    "\n",
    "from pyprint.NullPrinter import NullPrinter\n",
    "\n",
    "from coalib import coala_ci\n",
    "from coalib.misc.ContextManagers import make_temp, prepare_file\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "from coalib.output.Tagging import get_tag_path\n",
    "from tests.TestUtilities import bear_test_module, execute_coala\n",
    "\n",
    "\n",
    "class coalaCITest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.old_argv = sys.argv\n",
    "        self.unescaped_coafile = os.path.abspath(\"./.coafile\")\n",
    "        self.coafile = re.escape(self.unescaped_coafile)\n",
    "\n",
    "    def tearDown(self):\n",
    "        sys.argv = self.old_argv\n",
    "\n",
    "    def test_nonexistent(self):\n",
    "        retval, output = execute_coala(\n",
    "            coala_ci.main, \"coala-ci\", \"-c\", 'nonex', \"test\")\n",
    "        self.assertRegex(\n",
    "            output,\n",
    "            \".*\\\\[ERROR\\\\].*The requested coafile '.*' does not exist.\\n\")\n",
    "\n",
    "    def test_find_no_issues(self):\n",
    "        with bear_test_module(), \\\n",
    "                prepare_file([\"#include <a>\"], None) as (lines, filename):\n",
    "            retval, output = execute_coala(coala_ci.main, \"coala-ci\",\n",
    "                                           '-c', os.devnull,\n",
    "                                           '-f', re.escape(filename),\n",
    "                                           '-b', 'SpaceConsistencyTestBear',\n",
    "                                           \"--settings\", \"use_spaces=True\")\n",
    "            self.assertIn(\"Executing section Default\", output)\n",
    "            self.assertEqual(retval, 0,\n",
    "                             \"coala-ci must return zero when successful\")\n",
    "\n",
    "    def test_find_issues(self):\n",
    "        with bear_test_module(), \\\n",
    "                prepare_file([\"#fixme\"], None) as (lines, filename):\n",
    "            retval, output = execute_coala(coala_ci.main, \"coala-ci\",\n",
    "                                           \"-c\", os.devnull,\n",
    "                                           \"-b\", \"LineCountTestBear\",\n",
    "                                           \"-f\", re.escape(filename))\n",
    "            self.assertIn(\"This file has 1 lines.\",\n",
    "                          output,\n",
    "                          \"The output should report count as 1 lines\")\n",
    "            self.assertNotEqual(retval, 0,\n",
    "                                \"coala-ci was expected to return non-zero\")\n",
    "\n",
    "    def test_fix_patchable_issues(self):\n",
    "        with bear_test_module(), \\\n",
    "                prepare_file([\"\\t#include <a>\"], None) as (lines, filename):\n",
    "            retval, output = execute_coala(\n",
    "                coala_ci.main, \"coala-ci\",\n",
    "                \"-c\", os.devnull,\n",
    "                \"-f\", re.escape(filename),\n",
    "                \"-b\", \"SpaceConsistencyTestBear\",\n",
    "                \"--settings\", \"autoapply=true\", \"use_spaces=True\",\n",
    "                \"default_actions=SpaceConsistencyTestBear:ApplyPatchAction\")\n",
    "            self.assertIn(\"Applied 'ApplyPatchAction'\", output)\n",
    "            self.assertEqual(retval, 5,\n",
    "                             \"coala-ci must return exitcode 5 when it \"\n",
    "                             \"autofixes the code.\")\n",
    "\n",
    "    def test_tagging(self):\n",
    "        with bear_test_module(), \\\n",
    "                prepare_file([\"\\t#include <a>\"], None) as (lines, filename):\n",
    "            log_printer = LogPrinter(NullPrinter())\n",
    "            execute_coala(coala_ci.main, \"coala-ci\", \"default\",\n",
    "                          \"-c\", self.coafile,\n",
    "                          \"-f\", re.escape(filename),\n",
    "                          \"-b\", \"SpaceConsistencyTestBear\",\n",
    "                          \"-S\", \"tag=test_tag\")\n",
    "            tag_path = get_tag_path(\"test_tag\",\n",
    "                                    self.unescaped_coafile,\n",
    "                                    log_printer)\n",
    "            self.assertTrue(os.path.exists(tag_path))\n",
    "            execute_coala(coala_ci.main, \"coala-ci\", \"default\",\n",
    "                          \"-c\", self.coafile,\n",
    "                          \"-f\", re.escape(filename),\n",
    "                          \"-b\", \"SpaceConsistencyTestBear\",\n",
    "                          \"-S\", \"dtag=test_tag\")\n",
    "            self.assertFalse(os.path.exists(tag_path))\n",
    "\n",
    "    def test_fail_acquire_settings(self):\n",
    "        with bear_test_module():\n",
    "            retval, output = execute_coala(coala_ci.main, \"coala-ci\",\n",
    "                                           \"-b\", 'SpaceConsistencyTestBear',\n",
    "                                           '-c', os.devnull)\n",
    "            self.assertIn(\"During execution, we found that some\", output)\n",
    "\n",
    "    def test_coala_delete_orig(self):\n",
    "        with TemporaryDirectory() as tempdir,\\\n",
    "             NamedTemporaryFile(suffix='.orig',\n",
    "                                dir=tempdir,\n",
    "                                delete=False) as orig_file,\\\n",
    "             make_temp(suffix='.coafile', prefix='', dir=tempdir) as coafile,\\\n",
    "             make_temp(dir=tempdir) as unrelated_file:\n",
    "            orig_file.close()\n",
    "\n",
    "            execute_coala(coala_ci.main, \"coala-ci\", \"-S\",\n",
    "                          \"project_dir=\" + os.path.dirname(coafile))\n",
    "            self.assertFalse(os.path.isfile(orig_file.name))\n",
    "            self.assertTrue(os.path.isfile(unrelated_file))\n"
  ],
  "/home/tushar/coala/tests/coalaDbusTest.py": [
    "import unittest\n",
    "from unittest.case import SkipTest\n",
    "\n",
    "try:\n",
    "    from coalib import coala_dbus\n",
    "    from gi.repository import GLib\n",
    "except ImportError:\n",
    "    raise SkipTest(\"python-gi or python-dbus not installed\")\n",
    "\n",
    "\n",
    "class GlibMainLoopTest:\n",
    "\n",
    "    @staticmethod\n",
    "    def run():\n",
    "        raise AssertionError\n",
    "\n",
    "\n",
    "class coalaDbusTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.glib_main_loop = GLib.MainLoop\n",
    "        GLib.MainLoop = GlibMainLoopTest\n",
    "\n",
    "    def tearDown(self):\n",
    "        GLib.MainLoop = self.glib_main_loop\n",
    "\n",
    "    def test_main(self):\n",
    "        # Ensure we are able to setup dbus and create a mainloop\n",
    "        with self.assertRaises(AssertionError):\n",
    "            coala_dbus.main()\n",
    "\n",
    "        with self.assertRaises(SystemExit):\n",
    "            coala_dbus.sys_clean_exit()\n",
    "\n",
    "        self.assertGreater(coala_dbus.on_disconnected(), 0)\n"
  ],
  "/home/tushar/coala/tests/coalaDeleteOrigTest.py": [
    "import tempfile\n",
    "import unittest\n",
    "\n",
    "from coalib import coala_delete_orig\n",
    "from coalib.misc.ContextManagers import retrieve_stdout\n",
    "from coalib.settings.Section import Section\n",
    "from coalib.settings.Setting import Setting\n",
    "\n",
    "\n",
    "class coalaDeleteOrigTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.section = Section(\"default\")\n",
    "        self.section.append(Setting(\"config\", '/path/to/file'))\n",
    "\n",
    "    @unittest.mock.patch('os.getcwd')\n",
    "    def test_nonexistent_coafile(self, mocked_getcwd):\n",
    "        mocked_getcwd.return_value = None\n",
    "        retval = coala_delete_orig.main()\n",
    "        self.assertEqual(retval, 255)\n",
    "\n",
    "    @unittest.mock.patch('coalib.parsing.Globbing.glob')\n",
    "    def test_remove_exception(self, mock_glob):\n",
    "        # Non existent file\n",
    "        mock_glob.return_value = [\"non_existent_file\"]\n",
    "        with retrieve_stdout() as stdout:\n",
    "            retval = coala_delete_orig.main(section=self.section)\n",
    "            output = stdout.getvalue()\n",
    "            self.assertEqual(retval, 0)\n",
    "            self.assertIn(\"Couldn't delete\", output)\n",
    "\n",
    "        # Directory instead of file\n",
    "        with tempfile.TemporaryDirectory() as filename, \\\n",
    "                retrieve_stdout() as stdout:\n",
    "            mock_glob.return_value = [filename]\n",
    "            retval = coala_delete_orig.main(section=self.section)\n",
    "            output = stdout.getvalue()\n",
    "            self.assertEqual(retval, 0)\n",
    "            self.assertIn(\"Couldn't delete\", output)\n"
  ],
  "/home/tushar/coala/tests/coalaFormatTest.py": [
    "import os\n",
    "import re\n",
    "import sys\n",
    "import unittest\n",
    "\n",
    "from coalib import coala_format\n",
    "from coalib.misc.ContextManagers import prepare_file\n",
    "from tests.TestUtilities import bear_test_module, execute_coala\n",
    "\n",
    "\n",
    "class coalaFormatTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.old_argv = sys.argv\n",
    "\n",
    "    def tearDown(self):\n",
    "        sys.argv = self.old_argv\n",
    "\n",
    "    def test_line_count(self):\n",
    "        with bear_test_module(), \\\n",
    "                prepare_file([\"#fixme\"], None) as (lines, filename):\n",
    "            retval, output = execute_coala(coala_format.main, \"coala-format\",\n",
    "                                           \"-c\", os.devnull,\n",
    "                                           \"-f\", re.escape(filename),\n",
    "                                           \"-b\", \"LineCountTestBear\")\n",
    "            self.assertRegex(output, r'message:This file has [0-9]+ lines.',\n",
    "                             \"coala-format output for line count should \"\n",
    "                             \"not be empty\")\n",
    "            self.assertEqual(retval, 1,\n",
    "                             \"coala-format must return exitcode 1 when it \"\n",
    "                             \"yields results\")\n"
  ],
  "/home/tushar/coala/tests/coalaJSONTest.py": [
    "import json\n",
    "import os\n",
    "import re\n",
    "import sys\n",
    "import unittest\n",
    "\n",
    "from coalib import coala_json\n",
    "from coalib.misc.ContextManagers import prepare_file\n",
    "from tests.TestUtilities import bear_test_module, execute_coala\n",
    "\n",
    "\n",
    "class coalaJSONTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.old_argv = sys.argv\n",
    "\n",
    "    def tearDown(self):\n",
    "        sys.argv = self.old_argv\n",
    "\n",
    "    def test_nonexistent(self):\n",
    "        retval, output = execute_coala(\n",
    "            coala_json.main, \"coala-json\", \"-c\", 'nonex', \"test\")\n",
    "        output = json.loads(output)\n",
    "        self.assertRegex(\n",
    "            output[\"logs\"][0][\"message\"],\n",
    "            \"The requested coafile '.*' does not exist.\")\n",
    "\n",
    "    def test_find_issues(self):\n",
    "        with bear_test_module(), \\\n",
    "                prepare_file([\"#fixme\"], None) as (lines, filename):\n",
    "            retval, output = execute_coala(coala_json.main, \"coala-json\",\n",
    "                                           \"-c\", os.devnull,\n",
    "                                           \"-b\", \"LineCountTestBear\",\n",
    "                                           \"-f\", re.escape(filename))\n",
    "            output = json.loads(output)\n",
    "            self.assertEqual(output[\"results\"][\"default\"][0][\"message\"],\n",
    "                             \"This file has 1 lines.\")\n",
    "            self.assertNotEqual(retval, 0,\n",
    "                                \"coala-json must return nonzero when \"\n",
    "                                \"results found\")\n",
    "\n",
    "    def test_fail_acquire_settings(self):\n",
    "        with bear_test_module():\n",
    "            retval, output = execute_coala(coala_json.main, 'coala-json',\n",
    "                                           '-c', os.devnull,\n",
    "                                           '-b', 'SpaceConsistencyTestBear')\n",
    "            output = json.loads(output)\n",
    "            found = False\n",
    "            for msg in output[\"logs\"]:\n",
    "                if \"During execution, we found that some\" in msg[\"message\"]:\n",
    "                    found = True\n",
    "            self.assertTrue(found, \"Missing settings not logged\")\n",
    "\n",
    "    def test_version(self):\n",
    "        with self.assertRaises(SystemExit):\n",
    "            execute_coala(coala_json.main, 'coala-json', '-v')\n",
    "\n",
    "    def test_text_logs(self):\n",
    "        retval, output = execute_coala(\n",
    "            coala_json.main, 'coala-json', '--text-logs', '-c', 'nonex')\n",
    "        self.assertRegex(\n",
    "            output,\n",
    "            \".*\\\\[ERROR\\\\].*The requested coafile '.*' does not exist.\\n\")\n",
    "\n",
    "    def test_output_file(self):\n",
    "        with prepare_file([\"#todo this is todo\"], None) as (lines, filename):\n",
    "            retval, output = execute_coala(coala_json.main, \"coala-json\",\n",
    "                                           \"-c\", os.devnull,\n",
    "                                           \"-b\", \"LineCountTestBear\",\n",
    "                                           \"-f\", re.escape(filename))\n",
    "            exp_retval, exp_output = execute_coala(coala_json.main,\n",
    "                                                   \"coala-json\",\n",
    "                                                   \"-c\", os.devnull,\n",
    "                                                   \"-b\", \"LineCountTestBear\",\n",
    "                                                   \"-f\", re.escape(filename),\n",
    "                                                   \"-o\", \"file.json\")\n",
    "\n",
    "        with open('file.json') as fp:\n",
    "            data = json.load(fp)\n",
    "\n",
    "        output = json.loads(output)\n",
    "\n",
    "        self.assertEqual(data['logs'][0]['log_level'],\n",
    "                         output['logs'][0]['log_level'])\n",
    "        os.remove('file.json')\n"
  ],
  "/home/tushar/coala/tests/coalaTest.py": [
    "import os\n",
    "import re\n",
    "import sys\n",
    "import unittest\n",
    "import unittest.mock\n",
    "from pkg_resources import VersionConflict\n",
    "\n",
    "from coalib import coala\n",
    "from coalib.misc.ContextManagers import prepare_file\n",
    "from tests.test_bears.LineCountTestBear import LineCountTestBear\n",
    "from tests.test_bears.internal_folder.SpaceConsistencyTestBear import (\n",
    "    SpaceConsistencyTestBear)\n",
    "from tests.test_bears.JavaTestBear import JavaTestBear\n",
    "from tests.TestUtilities import execute_coala, bear_test_module, raise_error\n",
    "\n",
    "\n",
    "class coalaTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.old_argv = sys.argv\n",
    "\n",
    "    def tearDown(self):\n",
    "        sys.argv = self.old_argv\n",
    "\n",
    "    def test_coala(self):\n",
    "        with bear_test_module(), \\\n",
    "                prepare_file([\"#fixme\"], None) as (lines, filename):\n",
    "            retval, output = execute_coala(\n",
    "                             coala.main,\n",
    "                            \"coala\", \"-c\", os.devnull,\n",
    "                            \"-f\", re.escape(filename),\n",
    "                            \"-b\", \"LineCountTestBear\")\n",
    "            self.assertIn(\"This file has 1 lines.\",\n",
    "                          output,\n",
    "                          \"The output should report count as 1 lines\")\n",
    "\n",
    "    def test_did_nothing(self):\n",
    "        retval, output = execute_coala(coala.main, \"coala\", \"-c\", os.devnull,\n",
    "                                       \"-S\", \"default.enabled=false\")\n",
    "        self.assertEqual(retval, 0)\n",
    "        self.assertIn(\"No existent section was targeted or enabled\", output)\n",
    "\n",
    "    def test_show_bears(self):\n",
    "        with bear_test_module():\n",
    "            retval, output = execute_coala(coala.main, \"coala\", \"-A\")\n",
    "            self.assertEqual(retval, 0)\n",
    "            lines = output.splitlines()\n",
    "            bear_missing_lines = sum(1 for line in lines if \"WARNING\" in line)\n",
    "            self.assertEqual(bear_missing_lines, 0)\n",
    "\n",
    "            retval, output = execute_coala(coala.main, \"coala\", \"-A\")\n",
    "            self.assertEqual(retval, 0)\n",
    "\n",
    "            lines = output.splitlines()\n",
    "            bear_lines = sum(1 for line in lines if line.startswith(\"===\"))\n",
    "            self.assertEqual(bear_lines, 4)\n",
    "\n",
    "            for line in lines:\n",
    "                self.assertNotIn(\"WARNING\", line)\n",
    "\n",
    "            retval, output = execute_coala(\n",
    "                coala.main, \"coala\", \"-B\",\n",
    "                \"-b\", \"LineCountTestBear, SpaceConsistencyTestBear\",\n",
    "                \"-c\", os.devnull)\n",
    "            self.assertEqual(retval, 0)\n",
    "            self.assertIn(LineCountTestBear.run.__doc__.strip(), output)\n",
    "\n",
    "    def test_show_language_bears(self):\n",
    "        with bear_test_module():\n",
    "            retval, output = execute_coala(coala.main, \"coala\", \"-l\", \"java\")\n",
    "            self.assertEqual(retval, 0)\n",
    "            lines = output.splitlines()\n",
    "            bear_missing_lines = sum(1 for line in lines if \"WARNING\" in line)\n",
    "            self.assertEqual(bear_missing_lines, 0)\n",
    "\n",
    "            self.assertIn(JavaTestBear.run.__doc__.strip(), output)\n",
    "            self.assertIn(LineCountTestBear.run.__doc__.strip(), output)\n",
    "            self.assertNotIn(SpaceConsistencyTestBear.run.__doc__.strip(),\n",
    "                             output)\n",
    "\n",
    "    @unittest.mock.patch('coalib.parsing.DefaultArgParser.get_all_bears_names')\n",
    "    @unittest.mock.patch('coalib.collecting.Collectors.icollect_bears')\n",
    "    def test_version_conflict_in_collecting_bears(self, import_fn, _):\n",
    "        with bear_test_module():\n",
    "            import_fn.side_effect = (\n",
    "                lambda *args, **kwargs: raise_error(VersionConflict,\n",
    "                                                    \"msg1\", \"msg2\"))\n",
    "            retval, output = execute_coala(coala.main, \"coala\", \"-A\")\n",
    "            self.assertEqual(retval, 13)\n",
    "            self.assertIn((\"There is a conflict in the version of a \"\n",
    "                           \"dependency you have installed\"), output)\n",
    "            self.assertIn(\"pip install msg2\", output)  # Check recommendation\n",
    "\n",
    "    @unittest.mock.patch('coalib.collecting.Collectors._import_bears')\n",
    "    def test_unimportable_bear(self, import_fn):\n",
    "        with bear_test_module():\n",
    "            import_fn.side_effect = (\n",
    "                lambda *args, **kwargs: raise_error(SyntaxError))\n",
    "            retval, output = execute_coala(coala.main, \"coala\", \"-A\")\n",
    "            self.assertEqual(retval, 0)\n",
    "            self.assertIn(\"Unable to collect bears from\", output)\n",
    "\n",
    "            import_fn.side_effect = (\n",
    "                lambda *args, **kwargs: raise_error(VersionConflict,\n",
    "                                                    \"msg1\", \"msg2\"))\n",
    "            retval, output = execute_coala(coala.main, \"coala\", \"-A\")\n",
    "            # Note that bear version conflicts don't give exitcode=13,\n",
    "            # they just give a warning with traceback in log_level debug.\n",
    "            self.assertEqual(retval, 0)\n",
    "            self.assertRegex(output,\n",
    "                             \"Unable to collect bears from .* because there \"\n",
    "                             \"is a conflict with the version of a dependency \"\n",
    "                             \"you have installed\")\n",
    "            self.assertIn(\"pip install msg2\", output)  # Check recommendation\n"
  ],
  "/home/tushar/coala/tests/collecting/CollectorsTest.py": [
    "import os\n",
    "import pkg_resources\n",
    "import unittest\n",
    "\n",
    "from pyprint.ConsolePrinter import ConsolePrinter\n",
    "\n",
    "from coalib.collecting.Collectors import (\n",
    "    collect_all_bears_from_sections, collect_bears, collect_dirs, collect_files,\n",
    "    collect_registered_bears_dirs, filter_section_bears_by_languages,\n",
    "    get_all_bears_names)\n",
    "from coalib.misc.ContextManagers import retrieve_stdout\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "from coalib.settings.Section import Section\n",
    "from tests.TestUtilities import bear_test_module\n",
    "\n",
    "\n",
    "class CollectFilesTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        current_dir = os.path.split(__file__)[0]\n",
    "        self.collectors_test_dir = os.path.join(current_dir,\n",
    "                                                \"collectors_test_dir\")\n",
    "        self.log_printer = LogPrinter(ConsolePrinter())\n",
    "\n",
    "    def test_file_empty(self):\n",
    "        self.assertRaises(TypeError, collect_files)\n",
    "\n",
    "    def test_file_invalid(self):\n",
    "        with retrieve_stdout() as sio:\n",
    "            self.assertEqual(collect_files([\"invalid_path\"],\n",
    "                                           self.log_printer), [])\n",
    "            self.assertRegex(sio.getvalue(),\n",
    "                             \".*\\\\[WARNING\\\\].*No files matching \"\n",
    "                             \"'invalid_path' were found.\\n\")\n",
    "\n",
    "    def test_file_collection(self):\n",
    "        self.assertEqual(collect_files([os.path.join(self.collectors_test_dir,\n",
    "                                                     \"others\",\n",
    "                                                     \"*\",\n",
    "                                                     \"*2.py\")],\n",
    "                                       self.log_printer),\n",
    "                         [os.path.normcase(os.path.join(\n",
    "                             self.collectors_test_dir,\n",
    "                             \"others\",\n",
    "                             \"py_files\",\n",
    "                             \"file2.py\"))])\n",
    "\n",
    "    def test_file_string_collection(self):\n",
    "        self.assertEqual(collect_files(os.path.join(self.collectors_test_dir,\n",
    "                                                    \"others\",\n",
    "                                                    \"*\",\n",
    "                                                    \"*2.py\"),\n",
    "                                       self.log_printer),\n",
    "                         [os.path.normcase(os.path.join(\n",
    "                             self.collectors_test_dir,\n",
    "                             \"others\",\n",
    "                             \"py_files\",\n",
    "                             \"file2.py\"))])\n",
    "\n",
    "    def test_ignored(self):\n",
    "        self.assertEqual(collect_files([os.path.join(self.collectors_test_dir,\n",
    "                                                     \"others\",\n",
    "                                                     \"*\",\n",
    "                                                     \"*2.py\"),\n",
    "                                        os.path.join(self.collectors_test_dir,\n",
    "                                                     \"others\",\n",
    "                                                     \"*\",\n",
    "                                                     \"*2.py\")],\n",
    "                                       self.log_printer,\n",
    "                                       ignored_file_paths=[os.path.join(\n",
    "                                           self.collectors_test_dir,\n",
    "                                           \"others\",\n",
    "                                           \"py_files\",\n",
    "                                           \"file2.py\")]),\n",
    "                         [])\n",
    "\n",
    "    def test_limited(self):\n",
    "        self.assertEqual(\n",
    "            collect_files([os.path.join(self.collectors_test_dir,\n",
    "                                        \"others\",\n",
    "                                        \"*\",\n",
    "                                        \"*py\")],\n",
    "                          self.log_printer,\n",
    "                          limit_file_paths=[os.path.join(\n",
    "                                                self.collectors_test_dir,\n",
    "                                                \"others\",\n",
    "                                                \"*\",\n",
    "                                                \"*2.py\")]),\n",
    "            [os.path.normcase(os.path.join(self.collectors_test_dir,\n",
    "                                           \"others\",\n",
    "                                           \"py_files\",\n",
    "                                           \"file2.py\"))])\n",
    "\n",
    "\n",
    "class CollectDirsTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        current_dir = os.path.split(__file__)[0]\n",
    "        self.collectors_test_dir = os.path.join(current_dir,\n",
    "                                                \"collectors_test_dir\")\n",
    "\n",
    "    def test_dir_empty(self):\n",
    "        self.assertRaises(TypeError, collect_dirs)\n",
    "\n",
    "    def test_dir_invalid(self):\n",
    "        self.assertEqual(collect_dirs([\"invalid_path\"]), [])\n",
    "\n",
    "    def test_dir_collection(self):\n",
    "        self.assertEqual(\n",
    "            sorted(i for i in\n",
    "                   collect_dirs([os.path.join(self.collectors_test_dir,\n",
    "                                              \"**\")])\n",
    "                   if \"__pycache__\" not in i),\n",
    "            sorted([os.path.normcase(os.path.join(\n",
    "                self.collectors_test_dir, \"bears\")),\n",
    "                os.path.normcase(os.path.join(self.collectors_test_dir,\n",
    "                                              \"bears_local_global\")),\n",
    "                os.path.normcase(os.path.join(self.collectors_test_dir,\n",
    "                                              \"others\")),\n",
    "                os.path.normcase(os.path.join(self.collectors_test_dir,\n",
    "                                              \"others\",\n",
    "                                              \"c_files\")),\n",
    "                os.path.normcase(os.path.join(self.collectors_test_dir,\n",
    "                                              \"others\",\n",
    "                                              \"py_files\")),\n",
    "                os.path.normcase(self.collectors_test_dir+os.sep)]))\n",
    "\n",
    "    def test_dir_string_collection(self):\n",
    "        self.assertEqual(\n",
    "            sorted(i for i in\n",
    "                   collect_dirs(os.path.join(self.collectors_test_dir,\n",
    "                                             \"**\"))\n",
    "                   if \"__pycache__\" not in i),\n",
    "            sorted([os.path.normcase(os.path.join(\n",
    "                self.collectors_test_dir, \"bears\")),\n",
    "                os.path.normcase(os.path.join(self.collectors_test_dir,\n",
    "                                              \"bears_local_global\")),\n",
    "                os.path.normcase(os.path.join(self.collectors_test_dir,\n",
    "                                              \"others\")),\n",
    "                os.path.normcase(os.path.join(self.collectors_test_dir,\n",
    "                                              \"others\",\n",
    "                                              \"c_files\")),\n",
    "                os.path.normcase(os.path.join(self.collectors_test_dir,\n",
    "                                              \"others\",\n",
    "                                              \"py_files\")),\n",
    "                os.path.normcase(self.collectors_test_dir+os.sep)]))\n",
    "\n",
    "    def test_ignored(self):\n",
    "        self.assertEqual(\n",
    "            sorted(i for i in\n",
    "                   collect_dirs([os.path.join(self.collectors_test_dir,\n",
    "                                              \"**\")],\n",
    "                                [os.path.normcase(os.path.join(\n",
    "                                    self.collectors_test_dir,\n",
    "                                    \"others\",\n",
    "                                    \"py_files\"))])\n",
    "                   if \"__pycache__\" not in i),\n",
    "\n",
    "            sorted([os.path.normcase(os.path.join(\n",
    "                self.collectors_test_dir, \"bears\")),\n",
    "                os.path.normcase(os.path.join(self.collectors_test_dir,\n",
    "                                              \"bears_local_global\")),\n",
    "                os.path.normcase(os.path.join(self.collectors_test_dir,\n",
    "                                              \"others\")),\n",
    "                os.path.normcase(os.path.join(self.collectors_test_dir,\n",
    "                                              \"others\",\n",
    "                                              \"c_files\")),\n",
    "                os.path.normcase(self.collectors_test_dir+os.sep)]))\n",
    "\n",
    "    def test_collect_registered_bears_dirs(self):\n",
    "        old_iter = pkg_resources.iter_entry_points\n",
    "\n",
    "        def test_iter_entry_points(name):\n",
    "            assert name == \"hello\"\n",
    "\n",
    "            class EntryPoint1:\n",
    "\n",
    "                @staticmethod\n",
    "                def load():\n",
    "                    class PseudoPlugin:\n",
    "                        __file__ = \"/path1/file1\"\n",
    "                    return PseudoPlugin()\n",
    "\n",
    "            class EntryPoint2:\n",
    "\n",
    "                @staticmethod\n",
    "                def load():\n",
    "                    raise pkg_resources.DistributionNotFound\n",
    "\n",
    "            return iter([EntryPoint1(), EntryPoint2()])\n",
    "\n",
    "        pkg_resources.iter_entry_points = test_iter_entry_points\n",
    "        output = sorted(collect_registered_bears_dirs(\"hello\"))\n",
    "        self.assertEqual(output, [os.path.abspath(\"/path1\")])\n",
    "        pkg_resources.iter_entry_points = old_iter\n",
    "\n",
    "\n",
    "class CollectBearsTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        current_dir = os.path.split(__file__)[0]\n",
    "        self.collectors_test_dir = os.path.join(current_dir,\n",
    "                                                \"collectors_test_dir\")\n",
    "\n",
    "        self.log_printer = LogPrinter(ConsolePrinter())\n",
    "\n",
    "    def test_bear_empty(self):\n",
    "        self.assertRaises(TypeError, collect_bears)\n",
    "\n",
    "    def test_bear_invalid(self):\n",
    "        with retrieve_stdout() as sio:\n",
    "            self.assertEqual(collect_bears([\"invalid_paths\"],\n",
    "                                           [\"invalid_name\"],\n",
    "                                           [\"invalid kind\"],\n",
    "                                           self.log_printer), ([],))\n",
    "            self.assertRegex(sio.getvalue(),\n",
    "                             \".*\\\\[WARNING\\\\].*No bears were found matching \"\n",
    "                             \"'invalid_name'.\\n\")\n",
    "\n",
    "        self.assertEqual(collect_bears([\"invalid_paths\"],\n",
    "                                       [\"invalid_name\"],\n",
    "                                       [\"invalid kind1\", \"invalid kind2\"],\n",
    "                                       self.log_printer), ([], []))\n",
    "\n",
    "    def test_simple_single(self):\n",
    "        self.assertEqual(len(collect_bears(\n",
    "            [os.path.join(self.collectors_test_dir, \"bears\")],\n",
    "            [\"bear1\"],\n",
    "            [\"kind\"],\n",
    "            self.log_printer)[0]), 1)\n",
    "\n",
    "    def test_string_single(self):\n",
    "        self.assertEqual(len(collect_bears(\n",
    "            os.path.join(self.collectors_test_dir, \"bears\"),\n",
    "            [\"bear1\"],\n",
    "            [\"kind\"],\n",
    "            self.log_printer)[0]), 1)\n",
    "\n",
    "    def test_reference_single(self):\n",
    "        self.assertEqual(len(collect_bears(\n",
    "            [os.path.join(self.collectors_test_dir, \"bears\")],\n",
    "            [\"metabear\"],\n",
    "            [\"kind\"],\n",
    "            self.log_printer)[0]), 1)\n",
    "\n",
    "    def test_no_duplications(self):\n",
    "        self.assertEqual(len(collect_bears(\n",
    "            [os.path.join(self.collectors_test_dir, \"bears\", \"**\")],\n",
    "            [\"*\"],\n",
    "            [\"kind\"],\n",
    "            self.log_printer)[0]), 2)\n",
    "\n",
    "    def test_wrong_kind(self):\n",
    "        self.assertEqual(len(collect_bears(\n",
    "            [os.path.join(self.collectors_test_dir, \"bears\", \"**\")],\n",
    "            [\"*\"],\n",
    "            [\"other_kind\"],\n",
    "            self.log_printer)[0]), 0)\n",
    "\n",
    "    def test_all_bears_from_sections(self):\n",
    "        test_section = Section(\"test_section\")\n",
    "        test_section.bear_dirs = lambda: os.path.join(self.collectors_test_dir,\n",
    "                                                      \"bears_local_global\",\n",
    "                                                      \"**\")\n",
    "        local_bears, global_bears = collect_all_bears_from_sections(\n",
    "            {'test_section': test_section},\n",
    "            self.log_printer)\n",
    "\n",
    "        self.assertEqual(len(local_bears['test_section']), 2)\n",
    "        self.assertEqual(len(global_bears['test_section']), 2)\n",
    "\n",
    "\n",
    "class CollectorsTests(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        current_dir = os.path.split(__file__)[0]\n",
    "        self.collectors_test_dir = os.path.join(current_dir,\n",
    "                                                \"collectors_test_dir\")\n",
    "        self.log_printer = LogPrinter(ConsolePrinter())\n",
    "\n",
    "    def test_filter_section_bears_by_languages(self):\n",
    "        test_section = Section(\"test_section\")\n",
    "        test_section.bear_dirs = lambda: os.path.join(self.collectors_test_dir,\n",
    "                                                      \"bears_local_global\",\n",
    "                                                      \"**\")\n",
    "        local_bears, global_bears = collect_all_bears_from_sections(\n",
    "            {'test_section': test_section},\n",
    "            self.log_printer)\n",
    "        local_bears = filter_section_bears_by_languages(local_bears, ['C'])\n",
    "        self.assertEqual(len(local_bears['test_section']), 1)\n",
    "        self.assertEqual(str(local_bears['test_section'][0]),\n",
    "                         \"<class 'bears2.Test2LocalBear'>\")\n",
    "\n",
    "        global_bears = filter_section_bears_by_languages(global_bears, ['Java'])\n",
    "        self.assertEqual(len(global_bears['test_section']), 1)\n",
    "        self.assertEqual(str(global_bears['test_section'][0]),\n",
    "                         \"<class 'bears1.Test1GlobalBear'>\")\n",
    "\n",
    "    def test_get_all_bears_names(self):\n",
    "        with bear_test_module():\n",
    "            self.assertSetEqual(\n",
    "                set(get_all_bears_names()),\n",
    "                {'EchoBear',\n",
    "                 'LineCountTestBear',\n",
    "                 'JavaTestBear',\n",
    "                 'SpaceConsistencyTestBear'})\n"
  ],
  "/home/tushar/coala/tests/collecting/DependenciesTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.bears.Bear import Bear\n",
    "from coalib.collecting import Dependencies\n",
    "\n",
    "\n",
    "class BearWithoutDeps(Bear):\n",
    "\n",
    "    @staticmethod\n",
    "    def get_dependencies():\n",
    "        return []\n",
    "\n",
    "\n",
    "class ResolvableBear1(Bear):\n",
    "\n",
    "    @staticmethod\n",
    "    def get_dependencies():\n",
    "        return [BearWithoutDeps]\n",
    "\n",
    "\n",
    "class ResolvableBear2(Bear):\n",
    "\n",
    "    @staticmethod\n",
    "    def get_dependencies():\n",
    "        return [ResolvableBear1, BearWithoutDeps]\n",
    "\n",
    "\n",
    "class UnresolvableBear1(Bear):\n",
    "\n",
    "    @staticmethod\n",
    "    def get_dependencies():\n",
    "        return [ResolvableBear1, BearWithoutDeps, UnresolvableBear3]\n",
    "\n",
    "\n",
    "class UnresolvableBear2(Bear):\n",
    "\n",
    "    @staticmethod\n",
    "    def get_dependencies():\n",
    "        return [ResolvableBear1, BearWithoutDeps, UnresolvableBear1]\n",
    "\n",
    "\n",
    "class UnresolvableBear3(Bear):\n",
    "\n",
    "    @staticmethod\n",
    "    def get_dependencies():\n",
    "        return [ResolvableBear1, BearWithoutDeps, UnresolvableBear2]\n",
    "\n",
    "\n",
    "class DependenciesTest(unittest.TestCase):\n",
    "\n",
    "    def test_no_deps(self):\n",
    "        self.assertEqual(\n",
    "            len(Dependencies.resolve([BearWithoutDeps,\n",
    "                                      BearWithoutDeps])),\n",
    "            1)\n",
    "\n",
    "    def test_resolvable_deps(self):\n",
    "        self.assertEqual(Dependencies.resolve([ResolvableBear1,\n",
    "                                               ResolvableBear2]),\n",
    "                         [BearWithoutDeps, ResolvableBear1, ResolvableBear2])\n",
    "\n",
    "    def test_unresolvable_deps(self):\n",
    "        self.assertRaises(\n",
    "            Dependencies.CircularDependencyError,\n",
    "            Dependencies.resolve,\n",
    "            [UnresolvableBear1])\n"
  ],
  "/home/tushar/coala/tests/collecting/ImportersTest.py": [
    "import os\n",
    "import unittest\n",
    "from collections import OrderedDict\n",
    "\n",
    "from coalib.collecting.Importers import import_objects\n",
    "\n",
    "\n",
    "class ImportObjectsTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        current_dir = os.path.split(__file__)[0]\n",
    "        self.testfile1_path = os.path.join(current_dir,\n",
    "                                           \"importers_test_dir\",\n",
    "                                           \"file_one.py\")\n",
    "        self.testfile2_path = os.path.join(current_dir,\n",
    "                                           \"importers_test_dir\",\n",
    "                                           \"file_two.py\")\n",
    "\n",
    "    def test_no_file(self):\n",
    "        self.assertEqual(import_objects([]), [])\n",
    "\n",
    "    def test_no_data(self):\n",
    "        self.assertEqual(import_objects(self.testfile1_path), [])\n",
    "\n",
    "    def test_name_import(self):\n",
    "        self.assertEqual(\n",
    "            len(import_objects((self.testfile1_path, self.testfile2_path),\n",
    "                               names=\"name\")),\n",
    "            2)\n",
    "        self.assertEqual(\n",
    "            len(import_objects((self.testfile1_path, self.testfile2_path),\n",
    "                               names=\"last_name\")),\n",
    "            0)\n",
    "\n",
    "    def test_type_import(self):\n",
    "        self.assertEqual(\n",
    "            len(import_objects(self.testfile1_path,\n",
    "                               types=list,\n",
    "                               verbose=True)),\n",
    "            2)\n",
    "        self.assertEqual(\n",
    "            len(import_objects((self.testfile1_path, self.testfile2_path),\n",
    "                               names=\"name\",\n",
    "                               types=OrderedDict,\n",
    "                               verbose=True)),\n",
    "            0)\n",
    "\n",
    "    def test_class_import(self):\n",
    "        self.assertEqual(\n",
    "            len(import_objects((self.testfile1_path, self.testfile2_path),\n",
    "                               supers=list,\n",
    "                               verbose=True)),\n",
    "            1)\n",
    "        self.assertEqual(\n",
    "            len(import_objects((self.testfile1_path, self.testfile2_path),\n",
    "                               supers=str,\n",
    "                               verbose=True)),\n",
    "            0)\n",
    "\n",
    "    def test_attribute_import(self):\n",
    "        self.assertEqual(\n",
    "            len(import_objects((self.testfile1_path, self.testfile2_path),\n",
    "                               attributes=\"method\",\n",
    "                               local=True,\n",
    "                               verbose=True)),\n",
    "            1)\n",
    "        self.assertEqual(\n",
    "            len(import_objects((self.testfile1_path, self.testfile2_path),\n",
    "                               attributes=\"something\",\n",
    "                               verbose=True)),\n",
    "            0)\n",
    "\n",
    "    def test_local_definition(self):\n",
    "        self.assertEqual(\n",
    "            len(import_objects((self.testfile1_path, self.testfile2_path),\n",
    "                               attributes=\"method\",\n",
    "                               verbose=True)),\n",
    "            2)\n",
    "        self.assertEqual(\n",
    "            len(import_objects((self.testfile1_path, self.testfile2_path),\n",
    "                               attributes=\"method\",\n",
    "                               local=True,\n",
    "                               verbose=True)),\n",
    "            1)\n",
    "\n",
    "    def test_invalid_file(self):\n",
    "        with self.assertRaises(ImportError):\n",
    "            import_objects(\"some/invalid/path\",\n",
    "                           attributes=\"method\",\n",
    "                           local=True,\n",
    "                           verbose=True)\n",
    "\n",
    "        with self.assertRaises(ImportError):\n",
    "            import_objects(\"some/invalid/path\",\n",
    "                           attributes=\"method\",\n",
    "                           local=True,\n",
    "                           verbose=False)\n"
  ],
  "/home/tushar/coala/tests/collecting/__init__.py": [],
  "/home/tushar/coala/tests/collecting/collectors_test_dir/bears/bear1.py": [
    "import multiprocessing\n",
    "\n",
    "from coalib.bears.Bear import Bear\n",
    "from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "class TestBear(Bear):\n",
    "\n",
    "    def __init__(self):\n",
    "        Bear.__init__(self, Section(\"settings\"), multiprocessing.Queue())\n",
    "\n",
    "    @staticmethod\n",
    "    def kind():\n",
    "        return \"kind\"\n",
    "\n",
    "    def origin(self):\n",
    "        return __file__\n",
    "\n",
    "\n",
    "class NoKind():\n",
    "\n",
    "    def __init__(self):\n",
    "        pass\n",
    "\n",
    "    @staticmethod\n",
    "    def kind():\n",
    "        raise NotImplementedError\n"
  ],
  "/home/tushar/coala/tests/collecting/collectors_test_dir/bears/bear2.py": [
    "from bear1 import TestBear as ImportedTestBear\n",
    "\n",
    "\n",
    "class SubTestBear(ImportedTestBear):\n",
    "\n",
    "    def __init__(self):\n",
    "        ImportedTestBear.__init__(self)\n",
    "\n",
    "    @staticmethod\n",
    "    def kind():\n",
    "        return \"kind\"\n",
    "\n",
    "    def origin(self):\n",
    "        return __file__\n"
  ],
  "/home/tushar/coala/tests/collecting/collectors_test_dir/bears/metabear.py": [
    "from bear1 import TestBear as ImportedTestBear\n",
    "\n",
    "__additional_bears__ = [ImportedTestBear]\n"
  ],
  "/home/tushar/coala/tests/collecting/collectors_test_dir/bears_local_global/bears1.py": [
    "from coalib.bears.GlobalBear import GlobalBear\n",
    "from coalib.bears.LocalBear import LocalBear\n",
    "\n",
    "\n",
    "class Test1LocalBear(LocalBear):\n",
    "    pass\n",
    "\n",
    "\n",
    "class Test1GlobalBear(GlobalBear):\n",
    "    LANGUAGES = 'All'\n"
  ],
  "/home/tushar/coala/tests/collecting/collectors_test_dir/bears_local_global/bears2.py": [
    "from coalib.bears.GlobalBear import GlobalBear\n",
    "from coalib.bears.LocalBear import LocalBear\n",
    "\n",
    "\n",
    "class Test2LocalBear(LocalBear):\n",
    "    LANGUAGES = ('C', 'Java')\n",
    "\n",
    "\n",
    "class Test2GlobalBear(GlobalBear):\n",
    "    LANGUAGES = ('C', )\n"
  ],
  "/home/tushar/coala/tests/collecting/collectors_test_dir/others/py_files/file1.py": [],
  "/home/tushar/coala/tests/collecting/collectors_test_dir/others/py_files/file2.py": [],
  "/home/tushar/coala/tests/collecting/importers_test_dir/file_one.py": [
    "class test(list):\n",
    "\n",
    "    def __init__(self, *args):\n",
    "        list.__init__(self, *args)\n",
    "\n",
    "    @staticmethod\n",
    "    def method():\n",
    "        pass\n",
    "\n",
    "a = [1, 2, 3]\n",
    "b = [1, 2, 4]\n",
    "\n",
    "name = True\n"
  ],
  "/home/tushar/coala/tests/collecting/importers_test_dir/file_two.py": [
    "from file_one import test\n",
    "\n",
    "a = test()\n",
    "\n",
    "name = False\n"
  ],
  "/home/tushar/coala/tests/misc/AnnotationsTest.py": [
    "from unittest import TestCase\n",
    "\n",
    "from coalib.misc.Annotations import typechain\n",
    "\n",
    "\n",
    "class AnnotationsTest(TestCase):\n",
    "\n",
    "    def test_empty(self):\n",
    "        with self.assertRaises(TypeError) as ctx:\n",
    "            typechain()\n",
    "        self.assertEqual(str(ctx.exception), \"No arguments were provided.\")\n",
    "\n",
    "    def test_with_lambda(self):\n",
    "        function = typechain(lambda x: int(x) > 0)\n",
    "        with self.assertRaises(ValueError):\n",
    "            function(\"str\")\n",
    "        self.assertEqual(function(\"10\"), True)\n",
    "\n",
    "    def test_with_function(self):\n",
    "        def positive(val):\n",
    "            val = int(val)\n",
    "            if val > 0:\n",
    "                return val\n",
    "            raise ValueError\n",
    "        function = typechain(positive, ord)\n",
    "        with self.assertRaises(ValueError):\n",
    "            function(0)\n",
    "        with self.assertRaises(ValueError):\n",
    "            function(\"str\")\n",
    "        self.assertEqual(function(\"10\"), 10)\n",
    "        self.assertEqual(function(\"0\"), 48)\n",
    "\n",
    "    def test_with_function_without_arguments(self):\n",
    "        def dummy():\n",
    "            return 10\n",
    "        function = typechain(dummy)\n",
    "        with self.assertRaises(ValueError):\n",
    "            function(0)\n",
    "\n",
    "    def test_with_custom_type(self):\n",
    "        class Positive:\n",
    "\n",
    "            def __init__(self, val):\n",
    "                val = int(val)\n",
    "                if val > 0:\n",
    "                    self.val = val\n",
    "                else:\n",
    "                    raise ValueError\n",
    "\n",
    "        function = typechain(Positive, ord)\n",
    "        with self.assertRaises(ValueError):\n",
    "            function(0)\n",
    "        obj = function(\"10\")\n",
    "        self.assertIsInstance(obj, Positive)\n",
    "        self.assertEqual(obj.val, 10)\n",
    "        self.assertEqual(function(\"0\"), 48)\n",
    "\n",
    "    def test_with_empty_class(self):\n",
    "        class Dummy:\n",
    "            pass\n",
    "\n",
    "        function = typechain(Dummy)\n",
    "        with self.assertRaises(ValueError):\n",
    "            function(\"str\")\n",
    "        dummy = Dummy()\n",
    "        self.assertEqual(function(dummy), dummy)\n"
  ],
  "/home/tushar/coala/tests/misc/BuildManPageTest.py": [
    "import argparse\n",
    "import datetime\n",
    "import unittest\n",
    "from distutils.errors import DistutilsOptionError\n",
    "\n",
    "from setuptools.dist import Distribution\n",
    "\n",
    "from coalib.misc.BuildManPage import BuildManPage, ManPageFormatter\n",
    "from coalib.misc.ContextManagers import make_temp\n",
    "\n",
    "app_name = \"name\"\n",
    "app_description = (\"short description \" * 2).strip()\n",
    "app_long_description = (\"long description \" * 80).strip()\n",
    "section_name = \"sect\"\n",
    "section_text = (\"section text \" * 5).strip()\n",
    "sections = {section_name: section_text}\n",
    "\n",
    "\n",
    "def test_arg_parser(formatter_class=argparse.RawDescriptionHelpFormatter):\n",
    "    arg_parser = argparse.ArgumentParser(formatter_class=formatter_class,\n",
    "                                         prog=app_name,\n",
    "                                         description=app_description)\n",
    "    arg_parser.add_argument('arg1')\n",
    "    arg_parser.add_argument('-a')\n",
    "\n",
    "    return arg_parser\n",
    "\n",
    "\n",
    "class ManPageFormatterTest(unittest.TestCase):\n",
    "\n",
    "    def test_format_functions(self):\n",
    "        uut = ManPageFormatter(app_name)\n",
    "        self.assertEqual(ManPageFormatter._markup(\"a-b\"), \"a\\\\-b\")\n",
    "        self.assertEqual(ManPageFormatter._underline(\"test\"), \"\\\\fItest\\\\fR\")\n",
    "        self.assertEqual(ManPageFormatter._bold(\"test\"), \"\\\\fBtest\\\\fR\")\n",
    "        self.assertEqual(ManPageFormatter._bold(\"\\\\fBtest\"), \"\\\\fBtest\\\\fR\")\n",
    "        self.assertEqual(ManPageFormatter._bold(\"test\\\\fR\"), \"\\\\fBtest\\\\fR\")\n",
    "\n",
    "    def test_mk_title(self):\n",
    "        uut = ManPageFormatter(app_name, parser=test_arg_parser())\n",
    "        today = datetime.date.today().strftime('%Y\\\\-%m\\\\-%d')\n",
    "        self.assertEqual(uut._mk_title(),\n",
    "                         '.TH {0} {1} {2}\\n'.format(app_name, 1, today))\n",
    "\n",
    "    def test_mk_name(self):\n",
    "        uut = ManPageFormatter(app_name, parser=test_arg_parser())\n",
    "        self.assertEqual(uut._mk_name(),\n",
    "                         \".SH NAME\\n{}\\n\".format(app_name))\n",
    "\n",
    "    def test_mk_synopsis(self):\n",
    "        uut = ManPageFormatter(app_name, parser=test_arg_parser())\n",
    "        self.assertEqual(\n",
    "            uut._mk_synopsis(),\n",
    "            \".SH SYNOPSIS\\n \\\\fB{}\\\\fR [-h] [-a A] arg1\\n\\n\\n\".format(\n",
    "                app_name))\n",
    "\n",
    "    def test_mk_description(self):\n",
    "        uut = ManPageFormatter(app_name,\n",
    "                               parser=test_arg_parser())\n",
    "        self.assertEqual(uut._mk_description(), \"\")\n",
    "        uut = ManPageFormatter(app_name,\n",
    "                               parser=test_arg_parser(),\n",
    "                               long_desc=app_long_description)\n",
    "        self.assertEqual(uut._mk_description(),\n",
    "                         \".SH DESCRIPTION\\n{}\\n\".format(app_long_description))\n",
    "\n",
    "    def test_mk_options(self):\n",
    "        uut = ManPageFormatter(app_name, parser=test_arg_parser())\n",
    "        self.assertEqual(uut._mk_options(),\n",
    "                         \".SH OPTIONS\\n\"\n",
    "                         \"  arg1\\n\\n\"\n",
    "                         \"  -h, --help  show this help message and exit\\n\"\n",
    "                         \"  -a A\\n\")\n",
    "\n",
    "    def test_mk_footer(self):\n",
    "        uut = ManPageFormatter(app_name, ext_sections=sections)\n",
    "        self.assertEqual(uut._mk_footer(),\n",
    "                         \".SH {}\\n {}\".format(\n",
    "                             section_name.upper(), section_text))\n",
    "        uut = ManPageFormatter(app_name, ext_sections=None)\n",
    "        self.assertEqual(uut._mk_footer(), \"\")\n",
    "\n",
    "    def test_formatter(self):\n",
    "        parser = test_arg_parser(ManPageFormatter)\n",
    "        self.assertEqual(\n",
    "            parser.format_help(),\n",
    "            \"usage: {0} [-h] [-a A] arg1\\n\\n{1}\\n\\n\"\n",
    "            \"positional arguments:\\n\"\n",
    "            \"  arg1\\n\\n\"\n",
    "            \"optional arguments:\\n\"\n",
    "            \"  \\\\fB-h\\\\fR, \\\\fB--help\\\\fR\\n\"\n",
    "            \"                        show this help message and exit\\n\"\n",
    "            \"  \\\\fB-a\\\\fR \\\\fIA\\\\fR\\n\"\n",
    "            .format(app_name, app_description))\n",
    "\n",
    "        parser = ManPageFormatter(app_name,\n",
    "                                  parser=argparse.ArgumentParser(\n",
    "                                      prog=app_name))\n",
    "        today = datetime.date.today().strftime('%Y\\\\-%m\\\\-%d')\n",
    "        self.assertEqual(parser.format_man_page(),\n",
    "                         \".TH {0} 1 {1}\\n\"\n",
    "                         \".SH NAME\\n\"\n",
    "                         \"{0}\\n\"\n",
    "                         \".SH SYNOPSIS\\n\"\n",
    "                         \" \\\\fBname\\\\fR [-h]\\n\\n\\n\"\n",
    "                         \".SH OPTIONS\\n\"\n",
    "                         \"  -h, --help  show this help message and exit\\n\"\n",
    "                         .format(app_name, today))\n",
    "\n",
    "\n",
    "class BuildManPageTest(unittest.TestCase):\n",
    "\n",
    "    def test_finalize_options(self):\n",
    "        dist = Distribution()\n",
    "        uut = BuildManPage(dist)\n",
    "        self.assertRaises(DistutilsOptionError, uut.finalize_options)\n",
    "        with make_temp() as uut.output:\n",
    "            self.assertRaises(DistutilsOptionError, uut.finalize_options)\n",
    "            uut.parser = \"tests.misc.BuildManPageTest:test_arg_parser\"\n",
    "\n",
    "            uut.finalize_options()\n",
    "            self.assertIsInstance(uut._parser, argparse.ArgumentParser)\n",
    "\n",
    "            uut.run()\n",
    "            with open(uut.output) as file:\n",
    "                result = file.read(1000)\n",
    "\n",
    "            today = datetime.date.today().strftime('%Y\\\\-%m\\\\-%d')\n",
    "            self.assertEqual(result,\n",
    "                             \"\"\".TH {0} 1 {1}\n",
    ".SH NAME\n",
    "{0}\n",
    ".SH SYNOPSIS\n",
    " \\\\fB{0}\\\\fR [-h] [-a A] arg1\n",
    "\n",
    "\n",
    ".SH DESCRIPTION\n",
    "UNKNOWN\n",
    ".SH OPTIONS\n",
    "  arg1\n",
    "\n",
    "  \\\\fB-h\\\\fR, \\\\fB--help\\\\fR\n",
    "                        show this help message and exit\n",
    "  \\\\fB-a\\\\fR \\\\fIA\\\\fR\n",
    ".SH LICENSE\n",
    " UNKNOWN\n",
    ".SH MAINTAINER(S)\n",
    " UNKNOWN\n",
    ".SH SEE ALSO\n",
    " Online documentation: UNKNOWN\"\"\".format(app_name, today))\n"
  ],
  "/home/tushar/coala/tests/misc/ContextManagersTest.py": [
    "import os\n",
    "import subprocess\n",
    "import sys\n",
    "from tempfile import TemporaryDirectory\n",
    "import unittest\n",
    "\n",
    "from coalib.misc.ContextManagers import (\n",
    "    change_directory, make_temp, prepare_file, retrieve_stdout,\n",
    "    retrieve_stderr, simulate_console_inputs, subprocess_timeout,\n",
    "    suppress_stdout)\n",
    "from coalib.processes.Processing import create_process_group\n",
    "\n",
    "\n",
    "process_group_timeout_test_code = \"\"\"\n",
    "import time, subprocess, sys;\n",
    "p = subprocess.Popen([sys.executable,\n",
    "                     \"-c\",\n",
    "                     \"import time; time.sleep(100)\"]);\n",
    "time.sleep(100);\n",
    "\"\"\"\n",
    "\n",
    "\n",
    "class ContextManagersTest(unittest.TestCase):\n",
    "\n",
    "    def test_subprocess_timeout(self):\n",
    "        p = subprocess.Popen([sys.executable,\n",
    "                              \"-c\",\n",
    "                              \"import time; time.sleep(0.5);\"],\n",
    "                             stderr=subprocess.PIPE)\n",
    "        with subprocess_timeout(p, 0.2) as timedout:\n",
    "            retval = p.wait()\n",
    "            p.stderr.close()\n",
    "            self.assertEqual(timedout.value, True)\n",
    "        self.assertNotEqual(retval, 0)\n",
    "\n",
    "        p = create_process_group([sys.executable,\n",
    "                                  \"-c\",\n",
    "                                  process_group_timeout_test_code])\n",
    "        with subprocess_timeout(p, 0.5, kill_pg=True):\n",
    "            retval = p.wait()\n",
    "            self.assertEqual(timedout.value, True)\n",
    "        self.assertNotEqual(retval, 0)\n",
    "\n",
    "        p = subprocess.Popen([sys.executable,\n",
    "                              \"-c\",\n",
    "                              \"import time\"])\n",
    "        with subprocess_timeout(p, 0.5) as timedout:\n",
    "            retval = p.wait()\n",
    "            self.assertEqual(timedout.value, False)\n",
    "        self.assertEqual(retval, 0)\n",
    "\n",
    "        p = subprocess.Popen([sys.executable,\n",
    "                              \"-c\",\n",
    "                              \"import time\"])\n",
    "        with subprocess_timeout(p, 0) as timedout:\n",
    "            retval = p.wait()\n",
    "            self.assertEqual(timedout.value, False)\n",
    "        self.assertEqual(retval, 0)\n",
    "\n",
    "    def test_suppress_stdout(self):\n",
    "        def print_func():\n",
    "            print(\"func\")\n",
    "            raise NotImplementedError\n",
    "\n",
    "        def no_print_func():\n",
    "            with suppress_stdout():\n",
    "                print(\"func\")\n",
    "                raise NotImplementedError\n",
    "\n",
    "        old_stdout = sys.stdout\n",
    "        sys.stdout = False\n",
    "\n",
    "        self.assertRaises(AttributeError, print_func)\n",
    "        self.assertRaises(NotImplementedError, no_print_func)\n",
    "\n",
    "        sys.stdout = old_stdout\n",
    "\n",
    "    def test_retrieve_stdout(self):\n",
    "        with retrieve_stdout() as sio:\n",
    "            print(\"test\", file=sys.stdout)\n",
    "            self.assertEqual(sio.getvalue(), \"test\\n\")\n",
    "\n",
    "    def test_retrieve_stderr(self):\n",
    "        with retrieve_stderr() as sio:\n",
    "            print(\"test\", file=sys.stderr)\n",
    "            self.assertEqual(sio.getvalue(), \"test\\n\")\n",
    "\n",
    "    def test_simulate_console_inputs(self):\n",
    "        with simulate_console_inputs(0, 1, 2) as generator:\n",
    "            self.assertEqual(input(), 0)\n",
    "            self.assertEqual(generator.last_input, 0)\n",
    "            generator.inputs.append(3)\n",
    "            self.assertEqual(input(), 1)\n",
    "            self.assertEqual(input(), 2)\n",
    "            self.assertEqual(input(), 3)\n",
    "            self.assertEqual(generator.last_input, 3)\n",
    "\n",
    "        with simulate_console_inputs(\"test\"), self.assertRaises(ValueError):\n",
    "            self.assertEqual(input(), \"test\")\n",
    "            input()\n",
    "\n",
    "    def test_make_temp(self):\n",
    "        with make_temp() as f_a:\n",
    "            self.assertTrue(os.path.isfile(f_a))\n",
    "            self.assertTrue(os.path.basename(f_a).startswith(\"tmp\"))\n",
    "        self.assertFalse(os.path.isfile(f_a))\n",
    "\n",
    "        with make_temp(suffix=\".orig\", prefix=\"pre\") as f_b:\n",
    "            self.assertTrue(f_b.endswith(\".orig\"))\n",
    "            self.assertTrue(os.path.basename(f_b).startswith(\"pre\"))\n",
    "\n",
    "    def test_prepare_file(self):\n",
    "        with prepare_file(['line1', 'line2\\n'],\n",
    "                          \"/file/name\",\n",
    "                          force_linebreaks=True,\n",
    "                          create_tempfile=True) as (lines, filename):\n",
    "            self.assertEqual(filename, '/file/name')\n",
    "            self.assertEqual(lines, ['line1\\n', 'line2\\n'])\n",
    "\n",
    "        with prepare_file(['line1', 'line2\\n'],\n",
    "                          None,\n",
    "                          force_linebreaks=False,\n",
    "                          create_tempfile=True) as (lines, filename):\n",
    "            self.assertTrue(os.path.isfile(filename))\n",
    "            self.assertEqual(lines, ['line1', 'line2\\n'])\n",
    "\n",
    "        with prepare_file(['line1', 'line2\\n'],\n",
    "                          None,\n",
    "                          tempfile_kwargs={\"suffix\": \".test\",\n",
    "                                           \"prefix\": \"test_\"},\n",
    "                          force_linebreaks=False,\n",
    "                          create_tempfile=True) as (lines, filename):\n",
    "            self.assertTrue(os.path.isfile(filename))\n",
    "            basename = os.path.basename(filename)\n",
    "            self.assertTrue(basename.endswith(\".test\"))\n",
    "            self.assertTrue(basename.startswith(\"test_\"))\n",
    "\n",
    "        with prepare_file(['line1', 'line2\\n'],\n",
    "                          None,\n",
    "                          force_linebreaks=False,\n",
    "                          create_tempfile=False) as (lines, filename):\n",
    "            self.assertEqual(filename, \"dummy_file_name\")\n",
    "\n",
    "    def test_change_directory(self):\n",
    "        old_dir = os.getcwd()\n",
    "        with TemporaryDirectory(\"temp\") as tempdir:\n",
    "            tempdir = os.path.realpath(tempdir)\n",
    "            with change_directory(tempdir):\n",
    "                self.assertEqual(os.getcwd(), tempdir)\n",
    "        self.assertEqual(os.getcwd(), old_dir)\n"
  ],
  "/home/tushar/coala/tests/misc/DecoratorsTest.py": [
    "import unittest\n",
    "\n",
    "from coala_decorators.decorators import (\n",
    "    arguments_to_lists, enforce_signature, generate_eq, generate_ordering,\n",
    "    generate_repr, yield_once)\n",
    "\n",
    "\n",
    "class YieldOnceTest(unittest.TestCase):\n",
    "\n",
    "    def test_yield_once(self):\n",
    "        @yield_once\n",
    "        def iterate_over_list(arg_list):\n",
    "            for arg in arg_list:\n",
    "                yield arg\n",
    "\n",
    "        self.assertEqual(list(iterate_over_list([1, 1, 2, 2, 3, 3, 1, 4])),\n",
    "                         [1, 2, 3, 4])\n",
    "\n",
    "\n",
    "class ArgumentsToListsTest(unittest.TestCase):\n",
    "\n",
    "    def test_arguments_to_lists(self):\n",
    "        @arguments_to_lists\n",
    "        def return_args(*args, **kwargs):\n",
    "            return args, kwargs\n",
    "\n",
    "        self.assertEqual(\n",
    "            return_args(None, True, 1, \"\", \"AB\", [1, 2], t=(3, 4), d={\"a\": 1}),\n",
    "            (([], [True], [1], [\"\"], [\"AB\"], [1, 2]), {\"t\": [3, 4],\n",
    "                                                       \"d\": [{\"a\": 1}]\n",
    "                                                       })\n",
    "        )\n",
    "\n",
    "\n",
    "class GenerateReprTest(unittest.TestCase):\n",
    "    # We can't define the class in the scope of this test because generate_repr\n",
    "    # modifies the class in place, so we need to redefine it every time.\n",
    "\n",
    "    @staticmethod\n",
    "    def define_class():\n",
    "        class X:\n",
    "\n",
    "            def __init__(self):\n",
    "                self.A = 2\n",
    "                self.B = \"A string\"\n",
    "                self.ComplexMember = [3, 2, 1]\n",
    "                self.Q = 0.5\n",
    "                self.one = 1\n",
    "                self._private_member = 0\n",
    "                self.__DONT_TOUCH = 1\n",
    "\n",
    "            def computeA(self):\n",
    "                return self.A ** 3 - 7\n",
    "\n",
    "            @property\n",
    "            def getter(self):\n",
    "                return self.one * \"getter()\"\n",
    "\n",
    "            @property\n",
    "            def _private_prop(self):\n",
    "                return self.one\n",
    "\n",
    "            @property\n",
    "            def defaulted_getter(self, a=3, b=2):\n",
    "                return a * b * self.one\n",
    "\n",
    "            def getter_like_function(self):\n",
    "                return [\"A\", \"B\"] * self.one\n",
    "\n",
    "            def defaulted_getter_like_function(self, num=33):\n",
    "                return (num, num + self.one, num + self.one * 2)\n",
    "\n",
    "            def polynome(self, x, a, b, c):\n",
    "                return a + b * x + self.one * c * x ** 2\n",
    "\n",
    "        return X\n",
    "\n",
    "    def test_manual_argument_list(self):\n",
    "        X = generate_repr(\"A\")(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(A=2\\\\) at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "        X = generate_repr(\"A\", \"B\")(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(A=2, B='A string'\\\\) at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "        X = generate_repr(\"A\", \"B\", \"ComplexMember\")(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(A=2, B='A string', ComplexMember=\\\\[3, \"\n",
    "                         \"2, 1\\\\]\\\\) at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "        X = generate_repr(\"A\", \"B\", \"ComplexMember\", \"Q\")(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(A=2, B='A string', \"\n",
    "                         \"ComplexMember=\\\\[3, 2, 1\\\\]\\\\, Q=0\\\\.5\\\\) at \"\n",
    "                         \"0x[0-9a-fA-F]+>\")\n",
    "\n",
    "        # Switch order.\n",
    "        X = generate_repr(\"ComplexMember\", \"A\")(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(ComplexMember=\\\\[3, 2, 1\\\\], A=2\\\\) at \"\n",
    "                         \"0x[0-9a-fA-F]+>\")\n",
    "\n",
    "        X = generate_repr(\"Q\", \"ComplexMember\", \"A\", \"B\")(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(Q=0\\\\.5, ComplexMember=\\\\[3, 2, 1\\\\], \"\n",
    "                         \"A=2, B='A string'\\\\) at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "    def test_manual_argument_list_with_custom_repr(self):\n",
    "        X = generate_repr((\"A\", lambda x: str(x ** 2)))(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(A=4\\\\) at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "        X = generate_repr((\"A\", lambda x: str(x ** 2)), (\"B\", None))\n",
    "        X = X(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(A=4, B='A string'\\\\) at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "        X = generate_repr(\n",
    "            (\"B\", None),\n",
    "            (\"A\", lambda x: str(x ** 2)),\n",
    "            (\"ComplexMember\", lambda x: \".\".join(str(v) for v in x)))\n",
    "        X = X(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(B='A string', A=4, \"\n",
    "                         \"ComplexMember=3\\\\.2\\\\.1\\\\) at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "        # Combine normal strings with tuples.\n",
    "        X = generate_repr(\"A\",\n",
    "                          (\"B\", str),\n",
    "                          \"ComplexMember\",\n",
    "                          (\"Q\", lambda x: \"OVERRIDE\"))\n",
    "        X = X(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(A=2, B=A string, \"\n",
    "                         \"ComplexMember=\\\\[3, 2, 1\\\\], Q=OVERRIDE\\\\) at \"\n",
    "                         \"0x[0-9a-fA-F]+>\")\n",
    "\n",
    "    def test_properties(self):\n",
    "        X = generate_repr(\"getter\")(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(getter='getter\\\\(\\\\)'\\\\) at \"\n",
    "                         \"0x[0-9a-fA-F]+>\")\n",
    "\n",
    "        X = generate_repr(\"A\",\n",
    "                          \"getter\",\n",
    "                          \"defaulted_getter\")\n",
    "        X = X(self.define_class())\n",
    "\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(A=2, getter='getter\\\\(\\\\)', \"\n",
    "                         \"defaulted_getter=6\\\\) at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "    def test_getter_like_functions(self):\n",
    "        X = generate_repr(\"getter_like_function\")(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(getter_like_function=\\\\['A', 'B'\\\\]\\\\) \"\n",
    "                         \"at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "        X = generate_repr(\"defaulted_getter_like_function\")\n",
    "        X = X(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(defaulted_getter_like_function=\\\\(33, \"\n",
    "                         \"34, 35\\\\)\\\\) at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "    def test_invalid_attribute(self):\n",
    "        X = generate_repr(\"A\", \"B\", \"INVALID\")(self.define_class())\n",
    "        self.assertRaises(AttributeError, repr, X())\n",
    "\n",
    "        X = generate_repr(\"A\", \"polynome\")(self.define_class())\n",
    "        self.assertRaises(TypeError, repr, X())\n",
    "\n",
    "    def test_invalid_argument_tuple_size(self):\n",
    "        self.assertRaises(ValueError, generate_repr, (88,))\n",
    "        self.assertRaises(ValueError, generate_repr, (\"A\", repr, 3, 4))\n",
    "        self.assertRaises(ValueError, generate_repr, (\"A\", repr, False))\n",
    "        self.assertRaises(ValueError,\n",
    "                          generate_repr,\n",
    "                          (\"A\", repr),\n",
    "                          (\"B\", None),\n",
    "                          (\"Q\", 3, 2, 1, 0))\n",
    "\n",
    "    def test_auto_repr(self):\n",
    "        X = generate_repr()(self.define_class())\n",
    "        x = X()\n",
    "\n",
    "        self.assertRegex(repr(x),\n",
    "                         \"<X object\\\\(A=2, B='A string', ComplexMember=\\\\[3, \"\n",
    "                         \"2, 1\\\\], defaulted_getter=6, getter='getter\\\\(\\\\)', \"\n",
    "                         \"one=1, Q=0\\\\.5\\\\) at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "        # Insert member after instantation.\n",
    "        x.Z = 17\n",
    "        self.assertRegex(repr(x),\n",
    "                         \"<X object\\\\(A=2, B='A string', ComplexMember=\\\\[3, \"\n",
    "                         \"2, 1\\\\], defaulted_getter=6, getter='getter\\\\(\\\\)', \"\n",
    "                         \"one=1, Q=0\\\\.5, Z=17\\\\) at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "        # Test alphabetical order a bit more.\n",
    "        x.Ba = 4\n",
    "        x.g_mem = 0\n",
    "        self.assertRegex(repr(x),\n",
    "                         \"<X object\\\\(A=2, B='A string', Ba=4, \"\n",
    "                         \"ComplexMember=\\\\[3, 2, 1\\\\], defaulted_getter=6, \"\n",
    "                         \"g_mem=0, getter='getter\\\\(\\\\)', one=1, Q=0\\\\.5, \"\n",
    "                         \"Z=17\\\\) at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "    def test_duplicate_member(self):\n",
    "        X = generate_repr(\"A\", \"A\")(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(A=2, A=2\\\\) at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "        X = generate_repr(\"A\", \"B\", \"A\")(self.define_class())\n",
    "        self.assertRegex(repr(X()),\n",
    "                         \"<X object\\\\(A=2, B='A string', A=2\\\\) at \"\n",
    "                         \"0x[0-9a-fA-F]+>\")\n",
    "\n",
    "\n",
    "class GenerateEqTest(unittest.TestCase):\n",
    "\n",
    "    def test_equality(self):\n",
    "        @generate_eq(\"cookie\", \"cake\")\n",
    "        class TestClass:\n",
    "\n",
    "            def __init__(self, cookie, cake, irrelevant):\n",
    "                self.cookie = cookie\n",
    "                self._cake = cake\n",
    "                self.irrelevant = irrelevant\n",
    "\n",
    "            @property\n",
    "            def cake(self):\n",
    "                return self._cake\n",
    "\n",
    "        self.assertEqual(TestClass(4, 5, 3), TestClass(4, 5, 6))\n",
    "        self.assertNotEqual(TestClass(4, None, 3), TestClass(4, 5, 3))\n",
    "        self.assertNotEqual(TestClass(3, 5, 5), 5)\n",
    "        self.assertNotEqual(TestClass(3, 5, 5), None)\n",
    "        self.assertNotEqual(TestClass(3, 5, 5), TestClass(4, 5, 5))\n",
    "        self.assertNotEqual(TestClass(3, 5, 5), TestClass(3, 4, 5))\n",
    "\n",
    "    def test_relationship(self):\n",
    "        @generate_eq()\n",
    "        class TestClass:\n",
    "            pass\n",
    "\n",
    "        class Derived(TestClass):\n",
    "            pass\n",
    "\n",
    "        self.assertNotEqual(TestClass(), Derived())\n",
    "        self.assertNotEqual(Derived(), TestClass())\n",
    "\n",
    "\n",
    "class GenerateOrderingTest(unittest.TestCase):\n",
    "\n",
    "    def test_ordering(self):\n",
    "        @generate_ordering(\"cake\", \"cookie\")\n",
    "        class TestClass:\n",
    "\n",
    "            def __init__(self, cookie, cake, irrelevant):\n",
    "                self.cookie = cookie\n",
    "                self._cake = cake\n",
    "                self.irrelevant = irrelevant\n",
    "\n",
    "            @property\n",
    "            def cake(self):\n",
    "                return self._cake\n",
    "\n",
    "        self.assert_equal(TestClass(4, 5, 3), TestClass(4, 5, 6))\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            TestClass(4, 5, 3) < 5\n",
    "\n",
    "        # Cakes are more important than cookies\n",
    "        self.assert_ordering(TestClass(1, 1, 1), TestClass(2, 0, 4))\n",
    "        # But cookies are well too, provided cakes are there too\n",
    "        self.assert_ordering(TestClass(2, 1, 1), TestClass(1, 1, 2))\n",
    "        # Without any cookies I won't even start working\n",
    "        self.assert_ordering(TestClass(2, 1, 1), TestClass(None, 1, 2))\n",
    "\n",
    "    def assert_equal(self, first, second):\n",
    "        self.assertGreaterEqual(first, second)\n",
    "        self.assertEqual(first, second)\n",
    "        self.assertLessEqual(first, second)\n",
    "\n",
    "    def assert_ordering(self, greater, lesser):\n",
    "        self.assertGreater(greater, lesser)\n",
    "        self.assertGreaterEqual(greater, lesser)\n",
    "        self.assertNotEqual(greater, lesser)\n",
    "        self.assertLessEqual(lesser, greater)\n",
    "        self.assertLess(lesser, greater)\n",
    "\n",
    "\n",
    "class EnforceSignatureTest(unittest.TestCase):\n",
    "\n",
    "    def test_enforce_kwargs(self):\n",
    "        @enforce_signature\n",
    "        def test_function(*args, a, b: str):\n",
    "            pass\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            test_function(\"test\", a=\"test\", b=5)\n",
    "\n",
    "        test_function(5, a=5, b=\"test\")\n",
    "\n",
    "    def test_enforce_args(self):\n",
    "        @enforce_signature\n",
    "        def test_function(a: (int, None), b: \"t\", c=5, d: str=\"a\"):\n",
    "            pass\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            test_function(\"t\", \"t\")\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            test_function(4, \"test\")\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            test_function(4, \"t\", d=6)\n",
    "\n",
    "        test_function(4, \"t\")\n",
    "        test_function(None, \"t\", \"anything\", \"test\")\n"
  ],
  "/home/tushar/coala/tests/misc/DictUtilitiesTest.py": [
    "import unittest\n",
    "from collections import OrderedDict\n",
    "\n",
    "from coalib.misc.DictUtilities import inverse_dicts, update_ordered_dict_key\n",
    "\n",
    "\n",
    "class DictUtilitiesTest(unittest.TestCase):\n",
    "\n",
    "    def test_inverse_dicts(self):\n",
    "        self.dict1 = {1: [1, 2, 3], 2: [3, 4, 5]}\n",
    "        self.dict2 = {2: [1], 3: [2], 4: [3, 4]}\n",
    "        self.dict3 = {1: 2, 3: 4, 4: 4, 5: 4}\n",
    "        self.dict4 = {2: 3, 4: 4}\n",
    "        result = inverse_dicts(self.dict3)\n",
    "        self.assertEqual({2: [1], 4: [3, 4, 5]}, result)\n",
    "\n",
    "        result = inverse_dicts(self.dict1)\n",
    "        self.assertEqual({1: [1], 2: [1], 3: [1, 2], 4: [2], 5: [2]}, result)\n",
    "\n",
    "        result = inverse_dicts(self.dict3, self.dict4)\n",
    "        self.assertEqual({2: [1], 3: [2], 4: [3, 4, 5, 4]}, result)\n",
    "\n",
    "        result = inverse_dicts(self.dict1, self.dict2)\n",
    "        self.assertEqual({1: [1, 2],\n",
    "                          2: [1, 3],\n",
    "                          3: [1, 2, 4],\n",
    "                          4: [2, 4],\n",
    "                          5: [2]}, result)\n",
    "\n",
    "    def test_update_ordered_dict_key(self):\n",
    "        self.ordered_dict = OrderedDict()\n",
    "        self.ordered_dict[\"default\"] = \"Some stuff\"\n",
    "        self.ordered_dict[\"pythoncheck\"] = \"Somemore stuff\"\n",
    "        self.ordered_dict = update_ordered_dict_key(self.ordered_dict,\n",
    "                                                    \"default\",\n",
    "                                                    \"coala\")\n",
    "        self.assertTrue(\"coala\" in self.ordered_dict)\n",
    "        self.assertEqual(\"OrderedDict([('coala', 'Some stuff'), \"\n",
    "                         \"('pythoncheck', 'Somemore stuff')])\",\n",
    "                         self.ordered_dict.__str__())\n",
    "        self.ordered_dict = update_ordered_dict_key(self.ordered_dict,\n",
    "                                                    \"coala\",\n",
    "                                                    \"section\")\n",
    "        self.assertTrue(\"section\" in self.ordered_dict)\n",
    "        self.assertEqual(\"OrderedDict([('section', 'Some stuff'), \"\n",
    "                         \"('pythoncheck', 'Somemore stuff')])\",\n",
    "                         self.ordered_dict.__str__())\n"
  ],
  "/home/tushar/coala/tests/misc/EnumTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.misc.Enum import enum\n",
    "\n",
    "\n",
    "class ProcessTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.uut = enum(\"ZERO\", \"ONE\", \"TWO\", THREE=\"val\")\n",
    "\n",
    "    def test_sequentials(self):\n",
    "        self.assertEqual(self.uut.ZERO, 0)\n",
    "        self.assertEqual(self.uut.ONE, 1)\n",
    "        self.assertEqual(self.uut.TWO, 2)\n",
    "        self.assertEqual(self.uut.THREE, \"val\")\n",
    "        self.assertEqual(self.uut.str_dict[\"ZERO\"], 0)\n",
    "        self.assertRaises(KeyError, self.uut.str_dict.__getitem__, \"reverse\")\n",
    "\n",
    "    def test_reverse_mapping(self):\n",
    "        self.assertEqual(self.uut.reverse[self.uut.ZERO], \"ZERO\")\n",
    "        self.assertEqual(self.uut.reverse[self.uut.ONE], \"ONE\")\n",
    "        self.assertEqual(self.uut.reverse[self.uut.TWO], \"TWO\")\n",
    "        self.assertEqual(self.uut.reverse[self.uut.THREE], \"THREE\")\n"
  ],
  "/home/tushar/coala/tests/misc/ExceptionsTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.misc.Exceptions import get_exitcode\n",
    "from pkg_resources import VersionConflict\n",
    "\n",
    "\n",
    "class ExceptionsTest(unittest.TestCase):\n",
    "\n",
    "    def test_get_exitcode(self):\n",
    "        self.assertEqual(get_exitcode(KeyboardInterrupt()), 130)\n",
    "        self.assertEqual(get_exitcode(AssertionError()), 255)\n",
    "        self.assertEqual(get_exitcode(SystemExit(999)), 999)\n",
    "        self.assertEqual(get_exitcode(VersionConflict(\n",
    "            \"libclang-py3 0.3\", \"libclang-py3==0.2\")), 13)\n",
    "        self.assertEqual(get_exitcode(EOFError()), 0)\n",
    "        self.assertEqual(get_exitcode(None), 0)\n"
  ],
  "/home/tushar/coala/tests/misc/ShellTest.py": [
    "from contextlib import ExitStack\n",
    "import os\n",
    "import sys\n",
    "from tempfile import NamedTemporaryFile\n",
    "import unittest\n",
    "\n",
    "from coalib.misc.Shell import run_interactive_shell_command, run_shell_command\n",
    "\n",
    "\n",
    "class RunShellCommandTest(unittest.TestCase):\n",
    "\n",
    "    @staticmethod\n",
    "    def construct_testscript_command(scriptname):\n",
    "        return (sys.executable,\n",
    "                os.path.join(os.path.dirname(os.path.realpath(__file__)),\n",
    "                             \"run_shell_command_testfiles\",\n",
    "                             scriptname))\n",
    "\n",
    "    def test_run_interactive_shell_command(self):\n",
    "        command = RunShellCommandTest.construct_testscript_command(\n",
    "            \"test_interactive_program.py\")\n",
    "\n",
    "        with run_interactive_shell_command(command) as p:\n",
    "            self.assertEqual(p.stdout.readline(), \"test_program X\\n\")\n",
    "            self.assertEqual(p.stdout.readline(), \"Type in a number:\\n\")\n",
    "            p.stdin.write(\"33\\n\")\n",
    "            p.stdin.flush()\n",
    "            self.assertEqual(p.stdout.readline(), \"33\\n\")\n",
    "            self.assertEqual(p.stdout.readline(), \"Exiting program.\\n\")\n",
    "\n",
    "            self.assertEqual(p.stdout.read(), \"\")\n",
    "            self.assertEqual(p.stderr.read(), \"\")\n",
    "\n",
    "    def test_run_interactive_shell_command_custom_streams(self):\n",
    "        command = RunShellCommandTest.construct_testscript_command(\n",
    "            \"test_interactive_program.py\")\n",
    "\n",
    "        with ExitStack() as stack:\n",
    "            streams = {s: stack.enter_context(NamedTemporaryFile(mode=\"w+\"))\n",
    "                       for s in [\"stdout\", \"stderr\", \"stdin\"]}\n",
    "\n",
    "            with run_interactive_shell_command(command, **streams) as p:\n",
    "                streams[\"stdin\"].write(\"712\\n\")\n",
    "                streams[\"stdin\"].flush()\n",
    "                streams[\"stdin\"].seek(0)\n",
    "\n",
    "            self.assertFalse(streams[\"stdout\"].closed)\n",
    "            self.assertFalse(streams[\"stderr\"].closed)\n",
    "            self.assertFalse(streams[\"stdin\"].closed)\n",
    "\n",
    "            streams[\"stdout\"].seek(0)\n",
    "            self.assertEqual(streams[\"stdout\"].read(),\n",
    "                             \"test_program X\\nType in a number:\\n712\\n\"\n",
    "                             \"Exiting program.\\n\")\n",
    "\n",
    "            streams[\"stderr\"].seek(0)\n",
    "            self.assertEqual(streams[\"stderr\"].read(), \"\")\n",
    "\n",
    "    def test_run_interactive_shell_command_kwargs_delegation(self):\n",
    "        with self.assertRaises(TypeError):\n",
    "            with run_interactive_shell_command(\"some_command\",\n",
    "                                               weird_parameter=30):\n",
    "                pass\n",
    "\n",
    "    def test_run_shell_command_without_stdin(self):\n",
    "        command = RunShellCommandTest.construct_testscript_command(\n",
    "            \"test_program.py\")\n",
    "\n",
    "        stdout, stderr = run_shell_command(command)\n",
    "\n",
    "        expected = (\"test_program Z\\n\"\n",
    "                    \"non-interactive mode.\\n\"\n",
    "                    \"Exiting...\\n\")\n",
    "        self.assertEqual(stdout, expected)\n",
    "        self.assertEqual(stderr, \"\")\n",
    "\n",
    "    def test_run_shell_command_with_stdin(self):\n",
    "        command = RunShellCommandTest.construct_testscript_command(\n",
    "            \"test_input_program.py\")\n",
    "\n",
    "        stdout, stderr = run_shell_command(command, \"1  4  10  22\")\n",
    "\n",
    "        self.assertEqual(stdout, \"37\\n\")\n",
    "        self.assertEqual(stderr, \"\")\n",
    "\n",
    "        stdout, stderr = run_shell_command(command, \"1 p 5\")\n",
    "\n",
    "        self.assertEqual(stdout, \"\")\n",
    "        self.assertEqual(stderr, \"INVALID INPUT\\n\")\n",
    "\n",
    "    def test_run_shell_command_kwargs_delegation(self):\n",
    "        with self.assertRaises(TypeError):\n",
    "            run_shell_command(\"super-cool-command\", weird_parameter2=\"abc\")\n"
  ],
  "/home/tushar/coala/tests/misc/StringConverterTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.misc.StringConverter import StringConverter\n",
    "\n",
    "\n",
    "class StringConverterTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.uut = StringConverter(\"\\n \\\\1 \\n \")\n",
    "\n",
    "    def test_construction(self):\n",
    "        self.assertRaises(TypeError,\n",
    "                          StringConverter,\n",
    "                          \"test\",\n",
    "                          strip_whitespaces=5)\n",
    "        self.assertRaises(TypeError,\n",
    "                          StringConverter,\n",
    "                          \"test\",\n",
    "                          list_delimiters=5)\n",
    "\n",
    "    def test_whitespace_stripping(self):\n",
    "        self.assertEqual(str(self.uut), \"1\")\n",
    "\n",
    "        self.uut = StringConverter(\"\\n 1 \\n\", strip_whitespaces=False)\n",
    "        self.assertEqual(str(self.uut), \"\\n 1 \\n\")\n",
    "\n",
    "    def test_int_conversion(self):\n",
    "        self.assertEqual(int(self.uut), 1)\n",
    "        self.uut = StringConverter(\" not an int \")\n",
    "        self.assertRaises(ValueError, int, self.uut)\n",
    "\n",
    "    def test_float_conversion(self):\n",
    "        self.assertEqual(float(self.uut), 1)\n",
    "        self.uut.value = \"0.5 \"\n",
    "        self.assertEqual(float(self.uut), 0.5)\n",
    "        self.uut = StringConverter(\" not a float \")\n",
    "        self.assertRaises(ValueError, float, self.uut)\n",
    "\n",
    "    def test_len(self):\n",
    "        self.assertEqual(len(self.uut), 1)\n",
    "\n",
    "    def test_iterator(self):\n",
    "        self.uut = StringConverter(\"a, test with!!some challenge\",\n",
    "                                   list_delimiters=[\",\", \" \", \"!!\"])\n",
    "        self.assertEqual(list(self.uut),\n",
    "                         [\"a\", \"test\", \"with\", \"some\", \"challenge\"])\n",
    "        self.uut = StringConverter(\"a\\\\ \\\\,\\\\\\\\ test with!!some challenge\",\n",
    "                                   list_delimiters=[\",\", \" \", \"!!\"])\n",
    "        self.assertEqual(list(self.uut),\n",
    "                         [\"a ,\\\\\", \"test\", \"with\", \"some\", \"challenge\"])\n",
    "        self.uut = StringConverter(\"a, test with!some \\\\\\\\\\\\ challenge\\\\ \",\n",
    "                                   list_delimiters=\", !\",\n",
    "                                   strip_whitespaces=False)\n",
    "        self.assertEqual(list(self.uut),\n",
    "                         [\"a\", \"test\", \"with\", \"some\", \"\\\\ challenge \"])\n",
    "        self.uut = StringConverter(\"a, test with!some \\\\\\\\\\\\ challenge\\\\ \",\n",
    "                                   list_delimiters=\", !\",\n",
    "                                   strip_whitespaces=True)\n",
    "        self.assertEqual(list(self.uut),\n",
    "                         [\"a\", \"test\", \"with\", \"some\", \"\\\\ challenge \"])\n",
    "        self.uut = StringConverter(\"testval\", list_delimiters=[\",\", \"\u00b8\"])\n",
    "        self.uut.value = \"a\\\\n,bug\u00b8g\"\n",
    "        self.assertEqual(list(self.uut), [\"an\", \"bug\", \"g\"])\n",
    "        self.assertEqual(list(self.uut.__iter__(False)), [\"a\\\\n\", \"bug\", \"g\"])\n",
    "\n",
    "        self.assertTrue(\"bug\" in self.uut)\n",
    "        self.assertFalse(\"but\" in self.uut)\n",
    "\n",
    "        self.uut = StringConverter(\"a, test, \\n\",\n",
    "                                   list_delimiters=[\",\"],\n",
    "                                   strip_whitespaces=True)\n",
    "        self.assertEqual(list(self.uut), [\"a\", \"test\"])\n",
    "        self.uut = StringConverter(\"a, test, \\n\",\n",
    "                                   list_delimiters=[\",\"],\n",
    "                                   strip_whitespaces=False)\n",
    "        self.assertEqual(list(self.uut), [\"a\", \" test\", \" \\n\"])\n",
    "\n",
    "        uut = StringConverter(\"A,B,C  ,  D\\\\x \\\\a,42,\\\\n8 \",\n",
    "                              strip_whitespaces=False)\n",
    "        self.assertEqual(list(uut), [\"A\", \"B\", \"C  \", \"  Dx a\", \"42\", \"n8 \"])\n",
    "\n",
    "    def test_iterator_escape_whitespaces(self):\n",
    "        uut = StringConverter(\"ta, chi, tsu, te, \\\\ to\", list_delimiters=\",\")\n",
    "        self.assertEqual(list(uut), [\"ta\", \"chi\", \"tsu\", \"te\", \" to\"])\n",
    "\n",
    "        uut = StringConverter(r\"/**, \\ *\\ , \\ */\", list_delimiters=\",\")\n",
    "        self.assertEqual(list(uut), [\"/**\", \" * \", \" */\"])\n",
    "\n",
    "        uut = StringConverter(\n",
    "            \"abc\\\\\\\\ , def\\\\ \\\\ \\\\ ,   \\\\\\\\ unstrip \\\\\\\\\\\\  \",\n",
    "            list_delimiters=\",\")\n",
    "        self.assertEqual(list(uut), [\"abc\\\\\", \"def   \", \"\\\\ unstrip \\\\ \"])\n",
    "\n",
    "    def test_iterator_remove_empty_iter_elements(self):\n",
    "        uut = StringConverter(\"a, b, c, , e, , g\", list_delimiters=\",\")\n",
    "        self.assertEqual(list(uut), [\"a\", \"b\", \"c\", \"e\", \"g\"])\n",
    "\n",
    "        uut = StringConverter(\"a, , ,, e, , g\",\n",
    "                              list_delimiters=\",\",\n",
    "                              remove_empty_iter_elements=True)\n",
    "        self.assertEqual(list(uut), [\"a\", \"e\", \"g\"])\n",
    "\n",
    "        uut = StringConverter(\",,, ,\",\n",
    "                              list_delimiters=\",\",\n",
    "                              remove_empty_iter_elements=True)\n",
    "        self.assertEqual(list(uut), [])\n",
    "\n",
    "        uut = StringConverter(\"a, b, c, , e, , g\",\n",
    "                              list_delimiters=\",\",\n",
    "                              remove_empty_iter_elements=False)\n",
    "        self.assertEqual(list(uut), [\"a\", \"b\", \"c\", \"\", \"e\", \"\", \"g\"])\n",
    "\n",
    "        uut = StringConverter(\",,, ,\",\n",
    "                              list_delimiters=\",\",\n",
    "                              remove_empty_iter_elements=False)\n",
    "        self.assertEqual(list(uut), [\"\", \"\", \"\", \"\", \"\"])\n",
    "\n",
    "    def test_dict_escape_whitespaces(self):\n",
    "        uut = StringConverter(\n",
    "            \"\\\\  : \\\\  , hello: \\\\ world, \\\\\\\\ A \\\\\\\\ : B\\\\ \")\n",
    "        self.assertEqual(dict(uut), {\" \": \" \",\n",
    "                                     \"hello\": \" world\",\n",
    "                                     \"\\\\ A \\\\\": \"B \"})\n",
    "\n",
    "        uut = StringConverter(r\"/**, \\ *\\ , \\ */\")\n",
    "        self.assertEqual(dict(uut), {\"/**\": \"\", \" * \": \"\", \" */\": \"\"})\n",
    "\n",
    "        uut = StringConverter(\"abc\\\\\\\\  :    qew, def\\\\ \\\\ \\\\ ,\"\n",
    "                              \"   \\\\\\\\ unstrip \\\\\\\\\\\\  \")\n",
    "        self.assertEqual(dict(uut), {\"abc\\\\\": \"qew\",\n",
    "                                     \"def   \": \"\",\n",
    "                                     \"\\\\ unstrip \\\\ \": \"\"})\n",
    "\n",
    "        uut = StringConverter(\"A:B,C  :  D\\\\x \\\\a,42:\\\\n8 \",\n",
    "                              strip_whitespaces=False)\n",
    "        self.assertEqual(dict(uut), {\"A\": \"B\", \"C  \": \"  Dx a\", \"42\": \"n8 \"})\n",
    "\n",
    "    def test_dict_conversion(self):\n",
    "        self.uut = StringConverter(\"test\")\n",
    "        self.assertEqual(dict(self.uut), {\"test\": \"\"})\n",
    "        self.uut = StringConverter(\"test, t\")\n",
    "        self.assertEqual(dict(self.uut), {\"test\": \"\", \"t\": \"\"})\n",
    "        self.uut = StringConverter(\"test, t: v\")\n",
    "        self.assertEqual(dict(self.uut), {\"test\": \"\", \"t\": \"v\"})\n",
    "\n",
    "        # Check escaping\n",
    "        self.uut = StringConverter(\"test, t\\\\: v\")\n",
    "        self.assertEqual(dict(self.uut), {\"test\": \"\", \"t: v\": \"\"})\n",
    "        self.uut = StringConverter(\"test, t\\\\: v: t\")\n",
    "        self.assertEqual(dict(self.uut), {\"test\": \"\", \"t: v\": \"t\"})\n",
    "        self.uut = StringConverter(\"test\\\\, t\\\\: v: t\")\n",
    "        self.assertEqual(dict(self.uut), {\"test, t: v\": \"t\"})\n",
    "        self.uut = StringConverter(\"test\\\\, t\\\\: v: t\\\\,\")\n",
    "        self.assertEqual(dict(self.uut), {\"test, t: v\": \"t,\"})\n",
    "\n",
    "        # Check that lists ignore colons\n",
    "        self.assertEqual(list(self.uut), [\"test, t: v: t,\"])\n",
    "\n",
    "    def test_bool_conversion(self):\n",
    "        self.assertEqual(bool(self.uut), True)\n",
    "        self.uut.value = \"yeah\"\n",
    "        self.assertEqual(bool(self.uut), True)\n",
    "        self.uut = StringConverter(\"y\")\n",
    "        self.assertEqual(bool(self.uut), True)\n",
    "        self.uut = StringConverter(\"nope\")\n",
    "        self.assertEqual(bool(self.uut), False)\n",
    "\n",
    "        self.uut = StringConverter(\" i dont know \")\n",
    "        self.assertRaises(ValueError, bool, self.uut)\n",
    "\n",
    "    def test_equality_comparision(self):\n",
    "        self.assertEqual(StringConverter(\" i dont know \"),\n",
    "                         StringConverter(\"i dont know\"))\n",
    "        self.assertNotEqual(StringConverter(\" dont know \"),\n",
    "                            StringConverter(\"i dont know \"))\n",
    "        self.assertNotEqual(StringConverter(\"\"),\n",
    "                            StringConverter(\"i dont know \"))\n",
    "        self.assertNotEqual(5, StringConverter(\"i dont know \"))\n",
    "\n",
    "    def test_url(self):\n",
    "        valid_urls = (\n",
    "            # Scheme tests\n",
    "            \"http://url.com\", \"https://url.com\", \"url.com\", \"ftp://url.com\",\n",
    "            \"ftps://url.com\",\n",
    "            # Domain tests\n",
    "            \"http://sub.subsub.url.com\", \"http://sub.url.com\",\n",
    "            \"http://url.co.cc\", \"http://localhost\", \"http://sub.url123.com\",\n",
    "            \"http://url123.co.cc\", \"http://1.1.1.1\",\n",
    "            \"sub.subsub.url.com\", \"sub.url.com\", \"url.co.cc\", \"localhost\",\n",
    "            \"1.1.1.1\", \"255.255.255.255\", \"url123.com\", \"url123.co.cc\",\n",
    "            \"sub.url123.com\",\n",
    "            # Port number\n",
    "            \"localhost:8888\", \"1.1.1.1:80\", \"url.com:123456\",\n",
    "            # Paths\n",
    "            \"url.com/\", \"url.co.in/\", \"url.com/path/to/something\",\n",
    "            \"url.co.in/path/to/something\", \"url.com/path/to/file.php\")\n",
    "        invalid_urls = (\n",
    "            # Invalid types\n",
    "            123, True, None,\n",
    "            # Invalid links\n",
    "            \"unknown://url.com\", \"123\", \"abcd\", \"url.unknown\",\n",
    "            \"user:pass@url.com\", \"http://unknownlocalhost\",\n",
    "            \"local_host/path\")\n",
    "\n",
    "        for url in valid_urls:\n",
    "            try:\n",
    "                StringConverter(url).__url__()\n",
    "            except ValueError as exception:\n",
    "                print(exception)\n",
    "                self.fail(\"URL {} raised ValueError unexpectedly.\".format(url))\n",
    "\n",
    "        for url in invalid_urls:\n",
    "            self.assertRaises(ValueError, self.uut.__url__)\n"
  ],
  "/home/tushar/coala/tests/misc/__init__.py": [],
  "/home/tushar/coala/tests/misc/run_shell_command_testfiles/test_input_program.py": [
    "import sys\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    data = input()\n",
    "    try:\n",
    "        nums = [int(n) for n in data.split()]\n",
    "    except ValueError:\n",
    "        print(\"INVALID INPUT\", file=sys.stderr)\n",
    "    else:\n",
    "        print(sum(nums))\n"
  ],
  "/home/tushar/coala/tests/misc/run_shell_command_testfiles/test_interactive_program.py": [
    "if __name__ == \"__main__\":\n",
    "    print(\"test_program X\")\n",
    "    print(\"Type in a number:\")\n",
    "    num = input()\n",
    "    print(num)\n",
    "    print(\"Exiting program.\")\n"
  ],
  "/home/tushar/coala/tests/misc/run_shell_command_testfiles/test_program.py": [
    "if __name__ == \"__main__\":\n",
    "    print(\"test_program Z\")\n",
    "    print(\"non-interactive mode.\")\n",
    "    print(\"Exiting...\")\n"
  ],
  "/home/tushar/coala/tests/output/ConfWriterTest.py": [
    "import os\n",
    "import tempfile\n",
    "import unittest\n",
    "\n",
    "from coalib.output.ConfWriter import ConfWriter\n",
    "from coalib.parsing.ConfParser import ConfParser\n",
    "\n",
    "\n",
    "class ConfWriterTest(unittest.TestCase):\n",
    "    example_file = (\"to be ignored \\n\"\n",
    "                    \"    save=true\\n\"\n",
    "                    \"    a_default, another = val \\n\"\n",
    "                    \"    TEST = tobeignored  # thats a comment \\n\"\n",
    "                    \"    test = push \\n\"\n",
    "                    \"    t = \\n\"\n",
    "                    \"    [MakeFiles] \\n\"\n",
    "                    \"     j  , ANother = a \\n\"\n",
    "                    \"                   multiline \\n\"\n",
    "                    \"                   value \\n\"\n",
    "                    \"    ; just a omment \\n\"\n",
    "                    \"    ; just a omment \\n\"\n",
    "                    \"    key\\\\ space = value space\\n\"\n",
    "                    \"    key\\\\=equal = value=equal\\n\"\n",
    "                    \"    key\\\\\\\\backslash = value\\\\\\\\backslash\\n\"\n",
    "                    \"    key\\\\,comma = value,comma\\n\"\n",
    "                    \"    key\\\\#hash = value\\\\#hash\\n\"\n",
    "                    \"    key\\\\.dot = value.dot\\n\")\n",
    "\n",
    "    def setUp(self):\n",
    "        self.file = os.path.join(tempfile.gettempdir(), \"ConfParserTestFile\")\n",
    "        with open(self.file, \"w\", encoding='utf-8') as file:\n",
    "            file.write(self.example_file)\n",
    "\n",
    "        self.conf_parser = ConfParser()\n",
    "        self.write_file_name = os.path.join(tempfile.gettempdir(),\n",
    "                                            \"ConfWriterTestFile\")\n",
    "        self.uut = ConfWriter(self.write_file_name)\n",
    "\n",
    "    def tearDown(self):\n",
    "        self.uut.close()\n",
    "        os.remove(self.file)\n",
    "        os.remove(self.write_file_name)\n",
    "\n",
    "    def test_exceptions(self):\n",
    "        self.assertRaises(TypeError, self.uut.write_section, 5)\n",
    "\n",
    "    def test_write(self):\n",
    "        result_file = [\"[Default]\\n\",\n",
    "                       \"save = true\\n\",\n",
    "                       \"a_default, another = val\\n\",\n",
    "                       \"# thats a comment\\n\",\n",
    "                       \"test = push\\n\",\n",
    "                       \"t = \\n\",\n",
    "                       \"\\n\",\n",
    "                       \"[MakeFiles]\\n\",\n",
    "                       \"j, ANother = a\\n\",\n",
    "                       \"multiline\\n\",\n",
    "                       \"value\\n\",\n",
    "                       \"; just a omment\\n\",\n",
    "                       \"; just a omment\\n\",\n",
    "                       \"key\\\\ space = value space\\n\",\n",
    "                       \"key\\\\=equal = value=equal\\n\",\n",
    "                       \"key\\\\\\\\backslash = value\\\\\\\\backslash\\n\",\n",
    "                       \"key\\\\,comma = value,comma\\n\",\n",
    "                       \"key\\\\#hash = value\\\\#hash\\n\",\n",
    "                       \"key\\\\.dot = value.dot\\n\"]\n",
    "        self.uut.write_sections(self.conf_parser.parse(self.file))\n",
    "        self.uut.close()\n",
    "\n",
    "        with open(self.write_file_name, \"r\") as f:\n",
    "            lines = f.readlines()\n",
    "\n",
    "        self.assertEqual(result_file, lines)\n"
  ],
  "/home/tushar/coala/tests/output/ConsoleInteractionTest.py": [
    "import os\n",
    "import unittest\n",
    "from unittest.mock import patch\n",
    "from collections import OrderedDict\n",
    "from os.path import abspath, relpath\n",
    "\n",
    "from pyprint.ConsolePrinter import ConsolePrinter\n",
    "from pyprint.NullPrinter import NullPrinter\n",
    "from pyprint.StringPrinter import StringPrinter\n",
    "\n",
    "from coalib.bearlib.spacing.SpacingHelper import SpacingHelper\n",
    "from coalib.bears.Bear import Bear\n",
    "from coalib.misc.ContextManagers import (\n",
    "    make_temp, retrieve_stdout, simulate_console_inputs)\n",
    "from coalib.output.ConsoleInteraction import (\n",
    "    acquire_actions_and_apply, acquire_settings, get_action_info, nothing_done,\n",
    "    print_affected_files, print_bears, print_result, print_results,\n",
    "    print_results_formatted, print_results_no_input, print_section_beginning,\n",
    "    print_spaces_tabs_in_unicode, show_bears, ask_for_action_and_apply,\n",
    "    print_diffs_info)\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "from coalib.results.Diff import Diff\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.result_actions.ApplyPatchAction import ApplyPatchAction\n",
    "from coalib.results.result_actions.OpenEditorAction import OpenEditorAction\n",
    "from coalib.results.result_actions.ResultAction import ResultAction\n",
    "from coalib.results.SourceRange import SourceRange\n",
    "from coalib.settings.Section import Section\n",
    "from coalib.settings.Setting import Setting\n",
    "from tests.TestUtilities import raise_error\n",
    "\n",
    "STR_GET_VAL_FOR_SETTING = (\"Please enter a value for the setting \\\"{}\\\" ({}) \"\n",
    "                           \"needed by {}: \")\n",
    "STR_LINE_DOESNT_EXIST = (\"The line belonging to the following result \"\n",
    "                         \"cannot be printed because it refers to a line \"\n",
    "                         \"that doesn't seem to exist in the given file.\")\n",
    "STR_PROJECT_WIDE = \"Project wide:\"\n",
    "\n",
    "\n",
    "class TestAction(ResultAction):\n",
    "\n",
    "    def apply(self, result, original_file_dict, file_diff_dict, param):\n",
    "        pass\n",
    "\n",
    "\n",
    "class TestBear(Bear):\n",
    "\n",
    "    LANGUAGES = ('F#', 'Shakespearean Programming Language')\n",
    "\n",
    "    def run(self, setting1, setting2: int=None):\n",
    "        \"\"\"\n",
    "        Test bear Description.\n",
    "\n",
    "        :param setting1: Required Setting.\n",
    "        :param setting2: Optional Setting.\n",
    "        \"\"\"\n",
    "        return None\n",
    "\n",
    "\n",
    "class TestBear2(Bear):\n",
    "\n",
    "    LANGUAGES = 'TestLanguage'\n",
    "\n",
    "    def run(self, setting1):\n",
    "        \"\"\"\n",
    "        Test bear 2 description.\n",
    "\n",
    "        :param setting1: Required Setting.\n",
    "        \"\"\"\n",
    "        return None\n",
    "\n",
    "\n",
    "class SomeBear(Bear):\n",
    "\n",
    "    def run(self):\n",
    "        \"\"\"\n",
    "        Some Description.\n",
    "        \"\"\"\n",
    "        return None\n",
    "\n",
    "\n",
    "class SomeOtherBear(Bear):\n",
    "\n",
    "    def run(self, setting: int=None):\n",
    "        \"\"\"\n",
    "        This is a Bear.\n",
    "        :param setting: This is an optional setting.\n",
    "        \"\"\"\n",
    "        setting = 1\n",
    "        return None\n",
    "\n",
    "\n",
    "class SomeglobalBear(Bear):\n",
    "\n",
    "    def run(self):\n",
    "        \"\"\"\n",
    "        Some global-bear Description.\n",
    "        \"\"\"\n",
    "        return None\n",
    "\n",
    "\n",
    "class SomelocalBear(Bear):\n",
    "\n",
    "    def run(self):\n",
    "        \"\"\"\n",
    "        Some local-bear Description.\n",
    "        \"\"\"\n",
    "        return None\n",
    "\n",
    "\n",
    "class ConsoleInteractionTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.log_printer = LogPrinter(ConsolePrinter(print_colored=False))\n",
    "        self.console_printer = ConsolePrinter(print_colored=False)\n",
    "        self.file_diff_dict = {}\n",
    "        self.section = Section(\"t\")\n",
    "        self.local_bears = OrderedDict([(\"default\", [SomelocalBear]),\n",
    "                                        (\"test\", [SomelocalBear])])\n",
    "        self.global_bears = OrderedDict([(\"default\", [SomeglobalBear]),\n",
    "                                         (\"test\", [SomeglobalBear])])\n",
    "\n",
    "        self.old_open_editor_applicable = OpenEditorAction.is_applicable\n",
    "        OpenEditorAction.is_applicable = staticmethod(lambda *args: False)\n",
    "\n",
    "        self.old_apply_patch_applicable = ApplyPatchAction.is_applicable\n",
    "        ApplyPatchAction.is_applicable = staticmethod(lambda *args: False)\n",
    "\n",
    "    def tearDown(self):\n",
    "        OpenEditorAction.is_applicable = self.old_open_editor_applicable\n",
    "        ApplyPatchAction.is_applicable = self.old_apply_patch_applicable\n",
    "\n",
    "    def test_print_spaces_tabs_in_unicode(self):\n",
    "        printer = StringPrinter()\n",
    "\n",
    "        sh = SpacingHelper(4)\n",
    "\n",
    "        test_string = \"\\the\\tllo world   \"\n",
    "        print_spaces_tabs_in_unicode(\n",
    "            printer,\n",
    "            test_string,\n",
    "            dict(sh.yield_tab_lengths(test_string)),\n",
    "            \"red\")\n",
    "        self.assertEqual(printer.string, \"--->he->llo\u2022world\u2022\u2022\u2022\")\n",
    "\n",
    "        # Test the case when the bullet can't be printed because of encoding\n",
    "        # problems.\n",
    "        def hijack_print(text, *args, **kwargs):\n",
    "            if \"\u2022\" in text:\n",
    "                raise UnicodeEncodeError(\"test-codec\", \"\", 0, 1, \"\")\n",
    "            else:\n",
    "                return StringPrinter.print(printer, text, *args, **kwargs)\n",
    "\n",
    "        printer.print = hijack_print\n",
    "\n",
    "        printer.clear()\n",
    "        test_string = \" he\\tllo  world \"\n",
    "        print_spaces_tabs_in_unicode(printer,\n",
    "                                     test_string,\n",
    "                                     dict(sh.yield_tab_lengths(test_string)),\n",
    "                                     \"red\")\n",
    "        self.assertEqual(printer.string, \".he>llo..world.\")\n",
    "\n",
    "    def test_require_settings(self):\n",
    "        self.assertRaises(TypeError, acquire_settings, self.log_printer, 0)\n",
    "        self.assertEqual(acquire_settings(self.log_printer, {0: 0}), {})\n",
    "\n",
    "        with simulate_console_inputs(0, 1, 2) as generator:\n",
    "            self.assertEqual(acquire_settings(self.log_printer,\n",
    "                                              {\"setting\": [\"help text\",\n",
    "                                                           \"SomeBear\"]}),\n",
    "                             {\"setting\": 0})\n",
    "\n",
    "            self.assertEqual(acquire_settings(self.log_printer,\n",
    "                                              {\"setting\": [\"help text\",\n",
    "                                                           \"SomeBear\",\n",
    "                                                           \"AnotherBear\"]}),\n",
    "                             {\"setting\": 1})\n",
    "\n",
    "            self.assertEqual(acquire_settings(self.log_printer,\n",
    "                                              {\"setting\": [\"help text\",\n",
    "                                                           \"SomeBear\",\n",
    "                                                           \"AnotherBear\",\n",
    "                                                           \"YetAnotherBear\"]}),\n",
    "                             {\"setting\": 2})\n",
    "\n",
    "            self.assertEqual(generator.last_input, 2)\n",
    "\n",
    "    def test_print_diffs_info(self):\n",
    "        file_dict = {\"a\": [\"a\\n\", \"b\\n\", \"c\\n\"], \"b\": [\"old_first\\n\"]}\n",
    "        diff_dict = {\"a\": Diff(file_dict['a']),\n",
    "                     \"b\": Diff(file_dict['b'])}\n",
    "        diff_dict[\"a\"].add_lines(1, [\"test\\n\"])\n",
    "        diff_dict[\"a\"].delete_line(3)\n",
    "        diff_dict[\"b\"].add_lines(0, [\"first\\n\"])\n",
    "        previous_diffs = {\"a\": Diff(file_dict['a'])}\n",
    "        previous_diffs[\"a\"].change_line(2, \"b\\n\", \"b_changed\\n\")\n",
    "        with retrieve_stdout() as stdout:\n",
    "            print_diffs_info(diff_dict, self.console_printer)\n",
    "            self.assertEqual(stdout.getvalue(),\n",
    "                             \"|    | +1 -1 in a\\n\"\n",
    "                             \"|    | +1 -0 in b\\n\")\n",
    "\n",
    "    @patch(\"coalib.output.ConsoleInteraction.acquire_actions_and_apply\")\n",
    "    @patch(\"coalib.output.ConsoleInteraction.ShowPatchAction.\"\n",
    "           \"apply_from_section\")\n",
    "    def test_print_result_interactive_small_patch(self, apply_from_section, _):\n",
    "        file_dict = {\"a\": [\"a\\n\", \"b\\n\", \"c\\n\"], \"b\": [\"old_first\\n\"]}\n",
    "        diff_dict = {\"a\": Diff(file_dict['a']),\n",
    "                     \"b\": Diff(file_dict['b'])}\n",
    "        diff_dict[\"a\"].add_lines(1, [\"test\\n\"])\n",
    "        diff_dict[\"a\"].delete_line(3)\n",
    "        result = Result(\"origin\", \"msg\", diffs=diff_dict)\n",
    "        section = Section(\"test\")\n",
    "\n",
    "        print_result(self.console_printer,\n",
    "                     self.log_printer,\n",
    "                     section,\n",
    "                     self.file_diff_dict,\n",
    "                     result,\n",
    "                     file_dict,\n",
    "                     True)\n",
    "        apply_from_section.assert_called_once_with(\n",
    "            result, file_dict, self.file_diff_dict, section)\n",
    "\n",
    "    @patch(\"coalib.output.ConsoleInteraction.acquire_actions_and_apply\")\n",
    "    @patch(\"coalib.output.ConsoleInteraction.print_diffs_info\")\n",
    "    def test_print_result_interactive_big_patch(self, diffs_info, _):\n",
    "        file_dict = {\"a\": [\"a\\n\", \"b\\n\", \"c\\n\"], \"b\": [\"old_first\\n\"]}\n",
    "        diff_dict = {\"a\": Diff(file_dict['a']),\n",
    "                     \"b\": Diff(file_dict['b'])}\n",
    "        diff_dict[\"a\"].add_lines(1, [\"test\\n\", \"test1\\n\", \"test2\\n\"])\n",
    "        diff_dict[\"a\"].delete_line(3)\n",
    "        diff_dict[\"a\"].add_lines(3, [\"3test\\n\"])\n",
    "        result = Result(\"origin\", \"msg\", diffs=diff_dict)\n",
    "        section = Section(\"test\")\n",
    "\n",
    "        print_result(self.console_printer,\n",
    "                     self.log_printer,\n",
    "                     section,\n",
    "                     self.file_diff_dict,\n",
    "                     result,\n",
    "                     file_dict,\n",
    "                     True)\n",
    "        diffs_info.assert_called_once_with(diff_dict, self.console_printer)\n",
    "\n",
    "    def test_print_result(self):\n",
    "        print_result(self.console_printer,\n",
    "                     self.log_printer,\n",
    "                     None,\n",
    "                     self.file_diff_dict,\n",
    "                     \"illegal value\",\n",
    "                     {})\n",
    "\n",
    "        with simulate_console_inputs(0):\n",
    "            print_result(self.console_printer,\n",
    "                         self.log_printer,\n",
    "                         self.section,\n",
    "                         self.file_diff_dict,\n",
    "                         Result(\"origin\", \"msg\", diffs={}),\n",
    "                         {})\n",
    "\n",
    "        with make_temp() as testfile_path:\n",
    "            file_dict = {\n",
    "                testfile_path: [\"1\\n\", \"2\\n\", \"3\\n\"],\n",
    "                \"f_b\": [\"1\", \"2\", \"3\"]\n",
    "            }\n",
    "            diff = Diff(file_dict[testfile_path])\n",
    "            diff.delete_line(2)\n",
    "            diff.change_line(3, \"3\\n\", \"3_changed\\n\")\n",
    "\n",
    "            ApplyPatchAction.is_applicable = staticmethod(\n",
    "                lambda *args: True)\n",
    "\n",
    "            # Interaction must be closed by the user with `0` if it's not a\n",
    "            # param\n",
    "            with simulate_console_inputs(\"INVALID\",\n",
    "                                         -1,\n",
    "                                         1,\n",
    "                                         0,\n",
    "                                         3) as input_generator:\n",
    "                curr_section = Section(\"\")\n",
    "                print_section_beginning(self.console_printer, curr_section)\n",
    "                print_result(self.console_printer,\n",
    "                             self.log_printer,\n",
    "                             curr_section,\n",
    "                             self.file_diff_dict,\n",
    "                             Result(\"origin\", \"msg\", diffs={\n",
    "                                    testfile_path: diff}),\n",
    "                             file_dict)\n",
    "                self.assertEqual(input_generator.last_input, 3)\n",
    "\n",
    "                self.file_diff_dict.clear()\n",
    "\n",
    "                with open(testfile_path) as f:\n",
    "                    self.assertEqual(f.readlines(), [\"1\\n\", \"3_changed\\n\"])\n",
    "\n",
    "                os.remove(testfile_path + \".orig\")\n",
    "\n",
    "                name, section = get_action_info(curr_section,\n",
    "                                                TestAction().get_metadata(),\n",
    "                                                failed_actions=set())\n",
    "                self.assertEqual(input_generator.last_input, 4)\n",
    "                self.assertEqual(str(section), \" {param : '3'}\")\n",
    "                self.assertEqual(name, \"TestAction\")\n",
    "\n",
    "        # Check if the user is asked for the parameter only the first time.\n",
    "        # Use OpenEditorAction that needs this parameter (editor command).\n",
    "        with simulate_console_inputs(1, \"test_editor\", 0, 1, 0) as generator:\n",
    "            OpenEditorAction.is_applicable = staticmethod(lambda *args: True)\n",
    "\n",
    "            patch_result = Result(\"origin\", \"msg\", diffs={testfile_path: diff})\n",
    "            patch_result.file = \"f_b\"\n",
    "\n",
    "            print_result(self.console_printer,\n",
    "                         self.log_printer,\n",
    "                         curr_section,\n",
    "                         self.file_diff_dict,\n",
    "                         patch_result,\n",
    "                         file_dict)\n",
    "            # choose action, choose editor, choose no action (-1 -> 2)\n",
    "            self.assertEqual(generator.last_input, 2)\n",
    "\n",
    "            # It shoudn't ask for parameter again\n",
    "            print_result(self.console_printer,\n",
    "                         self.log_printer,\n",
    "                         curr_section,\n",
    "                         self.file_diff_dict,\n",
    "                         patch_result,\n",
    "                         file_dict)\n",
    "            self.assertEqual(generator.last_input, 4)\n",
    "\n",
    "    def test_print_affected_files(self):\n",
    "        with retrieve_stdout() as stdout, \\\n",
    "             make_temp() as some_file:\n",
    "            file_dict = {some_file: [\"1\\n\", \"2\\n\", \"3\\n\"]}\n",
    "            affected_code = (SourceRange.from_values(some_file),)\n",
    "            print_affected_files(self.console_printer,\n",
    "                                 self.log_printer,\n",
    "                                 Section(\"\"),\n",
    "                                 Result(\"origin\",\n",
    "                                        \"message\",\n",
    "                                        affected_code=affected_code),\n",
    "                                 file_dict,\n",
    "                                 color=True)\n",
    "            self.assertEqual(stdout.getvalue(),\n",
    "                             \"\\n\"+relpath(some_file)+\"\\n\")\n",
    "\n",
    "    def test_acquire_actions_and_apply(self):\n",
    "        with make_temp() as testfile_path:\n",
    "            file_dict = {testfile_path: [\"1\\n\", \"2\\n\", \"3\\n\"]}\n",
    "            diff = Diff(file_dict[testfile_path])\n",
    "            diff.delete_line(2)\n",
    "            diff.change_line(3, \"3\\n\", \"3_changed\\n\")\n",
    "            with simulate_console_inputs(1, 0) as generator, \\\n",
    "                    retrieve_stdout() as sio:\n",
    "                ApplyPatchAction.is_applicable = staticmethod(\n",
    "                        lambda *args: True)\n",
    "                acquire_actions_and_apply(self.console_printer,\n",
    "                                          self.log_printer,\n",
    "                                          Section(\"\"),\n",
    "                                          self.file_diff_dict,\n",
    "                                          Result(\"origin\", \"message\", diffs={\n",
    "                                           testfile_path: diff}),\n",
    "                                          file_dict)\n",
    "                self.assertEqual(generator.last_input, 1)\n",
    "                self.assertIn(ApplyPatchAction.SUCCESS_MESSAGE, sio.getvalue())\n",
    "\n",
    "            class InvalidateTestAction(ResultAction):\n",
    "\n",
    "                is_applicable = staticmethod(lambda *args: True)\n",
    "\n",
    "                def apply(*args, **kwargs):\n",
    "                    ApplyPatchAction.is_applicable = staticmethod(\n",
    "                        lambda *args: False)\n",
    "\n",
    "            old_applypatch_is_applicable = ApplyPatchAction.is_applicable\n",
    "            ApplyPatchAction.is_applicable = staticmethod(lambda *args: True)\n",
    "            cli_actions = [ApplyPatchAction(), InvalidateTestAction()]\n",
    "\n",
    "            with simulate_console_inputs(2, 1, 0) as generator, \\\n",
    "                    retrieve_stdout() as sio:\n",
    "                acquire_actions_and_apply(self.console_printer,\n",
    "                                          self.log_printer,\n",
    "                                          Section(\"\"),\n",
    "                                          self.file_diff_dict,\n",
    "                                          Result(\"origin\", \"message\",\n",
    "                                                 diffs={testfile_path: diff}),\n",
    "                                          file_dict,\n",
    "                                          cli_actions=cli_actions)\n",
    "                self.assertEqual(generator.last_input, 2)\n",
    "\n",
    "                action_fail = \"Failed to execute the action\"\n",
    "                self.assertNotIn(action_fail, sio.getvalue())\n",
    "\n",
    "                apply_path_desc = ApplyPatchAction().get_metadata().desc\n",
    "                self.assertEqual(sio.getvalue().count(apply_path_desc), 1)\n",
    "\n",
    "            ApplyPatchAction.is_applicable = old_applypatch_is_applicable\n",
    "\n",
    "    def test_ask_for_actions_and_apply(self):\n",
    "        failed_actions = set()\n",
    "        action = TestAction()\n",
    "        args = [self.log_printer, self.console_printer, Section(\"\"),\n",
    "                [action.get_metadata()], {'TestAction': action},\n",
    "                failed_actions, Result(\"origin\", \"message\"), {}, {}]\n",
    "\n",
    "        with simulate_console_inputs(1, 'param1', 1, 'param2') as generator:\n",
    "            action.apply = lambda *args, **kwargs: raise_error(AssertionError)\n",
    "            ask_for_action_and_apply(*args)\n",
    "            self.assertEqual(generator.last_input, 1)\n",
    "            self.assertIn('TestAction', failed_actions)\n",
    "\n",
    "            action.apply = lambda *args, **kwargs: {}\n",
    "            ask_for_action_and_apply(*args)\n",
    "            self.assertEqual(generator.last_input, 3)\n",
    "            self.assertNotIn('TestAction', failed_actions)\n",
    "\n",
    "    def test_print_result_no_input(self):\n",
    "        with make_temp() as testfile_path:\n",
    "            file_dict = {testfile_path: [\"1\\n\", \"2\\n\", \"3\\n\"]}\n",
    "            diff = Diff(file_dict[testfile_path])\n",
    "            diff.delete_line(2)\n",
    "            diff.change_line(3, \"3\\n\", \"3_changed\\n\")\n",
    "            with simulate_console_inputs(1, 2, 3) as generator, \\\n",
    "                    retrieve_stdout() as stdout:\n",
    "                ApplyPatchAction.is_applicable = staticmethod(\n",
    "                      lambda *args: True)\n",
    "                print_results_no_input(self.log_printer,\n",
    "                                       Section(\"someSection\"),\n",
    "                                       [Result(\"origin\", \"message\", diffs={\n",
    "                                           testfile_path: diff})],\n",
    "                                       file_dict,\n",
    "                                       self.file_diff_dict,\n",
    "                                       color=False)\n",
    "                self.assertEqual(generator.last_input, -1)\n",
    "                self.assertEqual(stdout.getvalue(),\n",
    "                                 \"\"\"\n",
    "Project wide:\n",
    "|    | [NORMAL] origin:\n",
    "|    | message\n",
    "\"\"\")\n",
    "\n",
    "    def test_print_section_beginning(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            print_section_beginning(self.console_printer, Section(\"name\"))\n",
    "            self.assertEqual(stdout.getvalue(), \"Executing section name...\\n\")\n",
    "\n",
    "    def test_nothing_done(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            nothing_done(self.log_printer)\n",
    "            self.assertIn(\"No existent section was targeted or enabled. \"\n",
    "                          \"Nothing to do.\\n\",\n",
    "                          stdout.getvalue())\n",
    "\n",
    "    def test_print_results_empty(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            print_results(self.log_printer, Section(\"\"), [], {}, {})\n",
    "            self.assertEqual(stdout.getvalue(), \"\")\n",
    "\n",
    "    def test_print_results_project_wide(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            print_results(self.log_printer,\n",
    "                          Section(\"\"),\n",
    "                          [Result(\"origin\", \"message\")],\n",
    "                          {},\n",
    "                          {},\n",
    "                          color=False)\n",
    "            self.assertEqual(\n",
    "                \"\\n{}\\n|    | [NORMAL] origin:\\n|    | message\"\n",
    "                \"\\n\".format(STR_PROJECT_WIDE),\n",
    "                stdout.getvalue())\n",
    "\n",
    "    def test_print_results_for_file(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            print_results(\n",
    "                self.log_printer,\n",
    "                Section(\"\"),\n",
    "                [Result.from_values(\"SpaceConsistencyBear\",\n",
    "                                    \"Trailing whitespace found\",\n",
    "                                    file=\"filename\",\n",
    "                                    line=2)],\n",
    "                {abspath(\"filename\"): [\"test line\\n\", \"line 2\\n\", \"line 3\\n\"]},\n",
    "                {},\n",
    "                color=False)\n",
    "            self.assertEqual(\"\"\"\\nfilename\n",
    "|   2| line\u20222\n",
    "|    | [NORMAL] SpaceConsistencyBear:\n",
    "|    | Trailing whitespace found\n",
    "\"\"\",\n",
    "                             stdout.getvalue())\n",
    "\n",
    "        with retrieve_stdout() as stdout:\n",
    "            print_results(\n",
    "                self.log_printer,\n",
    "                Section(\"\"),\n",
    "                [Result.from_values(\"SpaceConsistencyBear\",\n",
    "                                    \"Trailing whitespace found\",\n",
    "                                    file=\"filename\",\n",
    "                                    line=5)],\n",
    "                {abspath(\"filename\"): [\"test line\\n\",\n",
    "                                       \"line 2\\n\",\n",
    "                                       \"line 3\\n\",\n",
    "                                       \"line 4\\n\",\n",
    "                                       \"line 5\\n\"]},\n",
    "                {},\n",
    "                color=False)\n",
    "            self.assertEqual(\"\"\"\\nfilename\n",
    "|   5| line\u20225\n",
    "|    | [NORMAL] SpaceConsistencyBear:\n",
    "|    | Trailing whitespace found\n",
    "\"\"\",\n",
    "                             stdout.getvalue())\n",
    "\n",
    "    def test_print_results_sorting(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            print_results(self.log_printer,\n",
    "                          Section(\"\"),\n",
    "                          [Result.from_values(\"SpaceConsistencyBear\",\n",
    "                                              \"Trailing whitespace found\",\n",
    "                                              file=\"file\",\n",
    "                                              line=5),\n",
    "                           Result.from_values(\"SpaceConsistencyBear\",\n",
    "                                              \"Trailing whitespace found\",\n",
    "                                              file=\"file\",\n",
    "                                              line=2)],\n",
    "                          {abspath(\"file\"): [\"test line\\n\",\n",
    "                                             \"line 2\\n\",\n",
    "                                             \"line 3\\n\",\n",
    "                                             \"line 4\\n\",\n",
    "                                             \"line 5\\t\\n\"]},\n",
    "                          {},\n",
    "                          color=False)\n",
    "\n",
    "            self.assertEqual(\"\"\"\n",
    "file\n",
    "|   2| line\u20222\n",
    "|    | [NORMAL] SpaceConsistencyBear:\n",
    "|    | Trailing whitespace found\n",
    "\n",
    "file\n",
    "|   5| line\u20225->\n",
    "|    | [NORMAL] SpaceConsistencyBear:\n",
    "|    | Trailing whitespace found\n",
    "\"\"\",\n",
    "                             stdout.getvalue())\n",
    "\n",
    "    def test_print_results_multiple_ranges(self):\n",
    "        affected_code = (\n",
    "            SourceRange.from_values(\"some_file\", 5, end_line=7),\n",
    "            SourceRange.from_values(\"another_file\", 1, 3, 1, 5),\n",
    "            SourceRange.from_values(\"another_file\", 3, 3, 3, 5))\n",
    "        with retrieve_stdout() as stdout:\n",
    "            print_results(\n",
    "                self.log_printer,\n",
    "                Section(\"\"),\n",
    "                [Result(\"ClangCloneDetectionBear\",\n",
    "                        \"Clone Found\",\n",
    "                        affected_code)],\n",
    "                {abspath(\"some_file\"): [\"line \" + str(i + 1) + \"\\n\"\n",
    "                                        for i in range(10)],\n",
    "                 abspath(\"another_file\"): [\"line \" + str(i + 1) + \"\\n\"\n",
    "                                           for i in range(10)]},\n",
    "                {},\n",
    "                color=False)\n",
    "            self.assertEqual(\"\"\"\n",
    "another_file\n",
    "|   1| line\u20221\n",
    "\n",
    "another_file\n",
    "|   3| line\u20223\n",
    "\n",
    "some_file\n",
    "|   5| line\u20225\n",
    "|   6| line\u20226\n",
    "|   7| line\u20227\n",
    "|    | [NORMAL] ClangCloneDetectionBear:\n",
    "|    | Clone Found\n",
    "\"\"\",\n",
    "                             stdout.getvalue())\n",
    "\n",
    "    def test_print_results_missing_file(self):\n",
    "        self.log_printer = LogPrinter(NullPrinter())\n",
    "        with retrieve_stdout() as stdout:\n",
    "            print_results(\n",
    "                self.log_printer,\n",
    "                Section(\"\"),\n",
    "                [Result(\"t\", \"msg\"),\n",
    "                 Result.from_values(\"t\", \"msg\", file=\"file\", line=5)],\n",
    "                {},\n",
    "                {},\n",
    "                color=False)\n",
    "            self.assertEqual(\"\\n\" + STR_PROJECT_WIDE + \"\\n\"\n",
    "                             \"|    | [NORMAL] t:\\n\"\n",
    "                             \"|    | msg\\n\"\n",
    "                             # Second results file isn't there, no context is\n",
    "                             # printed, only a warning log message which we\n",
    "                             # don't catch\n",
    "                             \"|    | [NORMAL] t:\\n\"\n",
    "                             \"|    | msg\\n\", stdout.getvalue())\n",
    "\n",
    "    def test_print_results_missing_line(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            print_results(\n",
    "                self.log_printer,\n",
    "                Section(\"\"),\n",
    "                [Result.from_values(\"t\", \"msg\", file=\"file\", line=5),\n",
    "                 Result.from_values(\"t\", \"msg\", file=\"file\", line=6)],\n",
    "                {abspath(\"file\"): [\"line \" + str(i + 1) for i in range(5)]},\n",
    "                {},\n",
    "                color=False)\n",
    "            self.assertEqual(\"\\n\"\n",
    "                             \"file\\n\"\n",
    "                             \"|   5| line\u20225\\n\"\n",
    "                             \"|    | [NORMAL] t:\\n\"\n",
    "                             \"|    | msg\\n\"\n",
    "                             \"\\n\"\n",
    "                             \"file\\n\"\n",
    "                             \"|    | {}\\n\"\n",
    "                             \"|    | [NORMAL] t:\\n\"\n",
    "                             \"|    | msg\\n\".format(STR_LINE_DOESNT_EXIST),\n",
    "                             stdout.getvalue())\n",
    "\n",
    "    def test_print_results_without_line(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            print_results(\n",
    "                self.log_printer,\n",
    "                Section(\"\"),\n",
    "                [Result.from_values(\"t\", \"msg\", file=\"file\")],\n",
    "                {abspath(\"file\"): []},\n",
    "                {},\n",
    "                color=False)\n",
    "            self.assertEqual(\n",
    "                \"\\nfile\\n\"\n",
    "                \"|    | [NORMAL] t:\\n\"\n",
    "                \"|    | msg\\n\",\n",
    "                stdout.getvalue())\n",
    "\n",
    "    def test_print_bears_empty(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            bears = {}\n",
    "            print_bears(self.log_printer.printer, bears, True)\n",
    "            self.assertEqual(\"No bears to show.\\n\", stdout.getvalue())\n",
    "        with retrieve_stdout() as stdout:\n",
    "            bears = {}\n",
    "            print_bears(self.log_printer.printer, bears, False)\n",
    "            self.assertEqual(\"No bears to show.\\n\", stdout.getvalue())\n",
    "\n",
    "    def test_print_bears(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            bears = {TestBear: [\"default\", \"docs\"]}\n",
    "            print_bears(self.log_printer.printer, bears, False)\n",
    "            expected_string = \"TestBear:\\n\"\n",
    "            expected_string += \"  Test bear Description.\\n\\n\"\n",
    "            expected_string += \"  Supported languages:\\n\"\n",
    "            expected_string += \"   * F#\\n\"\n",
    "            expected_string += \"   * Shakespearean Programming Language\\n\\n\"\n",
    "            expected_string += \"  Used in:\\n\"\n",
    "            expected_string += \"   * default\\n\"\n",
    "            expected_string += \"   * docs\\n\\n\"\n",
    "            expected_string += \"  Needed Settings:\\n\"\n",
    "            expected_string += \"   * setting1: Required Setting.\\n\\n\"\n",
    "            expected_string += \"  Optional Settings:\\n\"\n",
    "            expected_string += \"   * setting2: Optional Setting. (\"\n",
    "            expected_string += \"Optional, defaults to 'None'.\"\n",
    "            expected_string += \")\\n\\n\"\n",
    "\n",
    "            self.assertEqual(expected_string, stdout.getvalue())\n",
    "\n",
    "    def test_print_bears_no_settings(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            bears = {SomeBear: [\"default\"]}\n",
    "            print_bears(self.log_printer.printer, bears, False)\n",
    "            expected_string = \"SomeBear:\\n\"\n",
    "            expected_string += \"  Some Description.\\n\\n\"\n",
    "            expected_string += (\"  The bear does not provide information \"\n",
    "                                \"about which languages it can analyze.\\n\\n\")\n",
    "            expected_string += \"  Used in:\\n\"\n",
    "            expected_string += \"   * default\\n\\n\"\n",
    "            expected_string += \"  No needed settings.\\n\\n\"\n",
    "            expected_string += \"  No optional settings.\\n\\n\"\n",
    "\n",
    "            self.assertEqual(expected_string, stdout.getvalue())\n",
    "\n",
    "    def test_print_bears_no_needed_settings(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            bears = {SomeOtherBear: [\"test\"]}\n",
    "            print_bears(self.log_printer.printer, bears, False)\n",
    "            expected_string = \"SomeOtherBear:\\n\"\n",
    "            expected_string += \"  This is a Bear.\\n\\n\"\n",
    "            expected_string += (\"  The bear does not provide information \"\n",
    "                                \"about which languages it can analyze.\\n\\n\")\n",
    "            expected_string += \"  Used in:\\n\"\n",
    "            expected_string += \"   * test\\n\\n\"\n",
    "            expected_string += \"  No needed settings.\\n\\n\"\n",
    "            expected_string += \"  Optional Settings:\\n\"\n",
    "            expected_string += \"   * setting: This is an optional setting. (\"\n",
    "            expected_string += \"Optional, defaults to 'None'.\"\n",
    "            expected_string += \")\\n\\n\"\n",
    "\n",
    "            self.assertEqual(expected_string, stdout.getvalue())\n",
    "\n",
    "    def test_print_bears_no_optional_settings(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            bears = {TestBear2: [\"test\"]}\n",
    "            print_bears(self.log_printer.printer, bears, False)\n",
    "            expected_string = \"TestBear2:\\n\"\n",
    "            expected_string += \"  Test bear 2 description.\\n\\n\"\n",
    "            expected_string += \"  Supported languages:\\n\"\n",
    "            expected_string += \"   * TestLanguage\\n\\n\"\n",
    "            expected_string += \"  Used in:\\n\"\n",
    "            expected_string += \"   * test\\n\\n\"\n",
    "            expected_string += \"  Needed Settings:\\n\"\n",
    "            expected_string += \"   * setting1: Required Setting.\\n\\n\"\n",
    "            expected_string += \"  No optional settings.\\n\\n\"\n",
    "\n",
    "            self.assertEqual(expected_string, stdout.getvalue())\n",
    "\n",
    "    def test_print_bears_no_sections(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            bears = {SomeBear: []}\n",
    "            print_bears(self.log_printer.printer, bears, False)\n",
    "            expected_string = \"SomeBear:\\n\"\n",
    "            expected_string += \"  Some Description.\\n\\n\"\n",
    "            expected_string += (\"  The bear does not provide information \"\n",
    "                                \"about which languages it can analyze.\\n\\n\")\n",
    "            expected_string += \"  No sections.\\n\\n\"\n",
    "            expected_string += \"  No needed settings.\\n\\n\"\n",
    "            expected_string += \"  No optional settings.\\n\\n\"\n",
    "\n",
    "            self.assertEqual(expected_string, stdout.getvalue())\n",
    "\n",
    "    def test_show_bears(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            bears = {SomelocalBear: ['default', 'test'],\n",
    "                     SomeglobalBear: ['default', 'test']}\n",
    "            print_bears(self.log_printer.printer, bears, False)\n",
    "            expected_string = stdout.getvalue()\n",
    "        self.maxDiff = None\n",
    "        with retrieve_stdout() as stdout:\n",
    "            show_bears(self.local_bears,\n",
    "                       self.global_bears,\n",
    "                       False,\n",
    "                       self.log_printer.printer)\n",
    "            self.assertEqual(expected_string, stdout.getvalue())\n",
    "\n",
    "        with retrieve_stdout() as stdout:\n",
    "            show_bears(self.local_bears,\n",
    "                       self.global_bears,\n",
    "                       True,\n",
    "                       self.log_printer.printer)\n",
    "            self.assertEqual(\"SomeglobalBear\\n\"\n",
    "                             \"==============\\n\"\n",
    "                             \"Some global-bear Description.\\n\"\n",
    "                             \"\\n\"\n",
    "                             \"SomelocalBear\\n\"\n",
    "                             \"=============\\n\"\n",
    "                             \"Some local-bear Description.\\n\\n\",\n",
    "                             stdout.getvalue())\n",
    "\n",
    "\n",
    "# Own test because this is easy and not tied to the rest\n",
    "class PrintFormattedResultsTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.printer = StringPrinter()\n",
    "        self.logger = LogPrinter(self.printer)\n",
    "        self.section = Section(\"t\")\n",
    "\n",
    "    def test_default_format(self):\n",
    "        expected_string = (\"id:-?[0-9]+:origin:1:file:None:line:None:\"\n",
    "                           \"column:None:end_line:None:end_column:None:\"\n",
    "                           \"severity:1:severity_str:NORMAL:message:2\\n\")\n",
    "        with retrieve_stdout() as stdout:\n",
    "            print_results_formatted(self.logger,\n",
    "                                    self.section,\n",
    "                                    [Result(\"1\", \"2\")],\n",
    "                                    None,\n",
    "                                    None)\n",
    "            self.assertRegex(stdout.getvalue(), expected_string)\n",
    "\n",
    "    def test_multiple_ranges(self):\n",
    "        expected_string = (\n",
    "            \"id:-?[0-9]+:origin:1:.*file:.*another_file:line:5:\"\n",
    "            \"column:3:end_line:5:end_column:5:\"\n",
    "            \"severity:1:severity_str:NORMAL:message:2\\n\"\n",
    "            \"id:-?[0-9]+:origin:1:.*file:.*some_file:line:5:\"\n",
    "            \"column:None:end_line:7:end_column:None:\"\n",
    "            \"severity:1:severity_str:NORMAL:message:2\\n\")\n",
    "        affected_code = (SourceRange.from_values(\"some_file\", 5, end_line=7),\n",
    "                         SourceRange.from_values(\"another_file\", 5, 3, 5, 5))\n",
    "        with retrieve_stdout() as stdout:\n",
    "            print_results_formatted(self.logger,\n",
    "                                    self.section,\n",
    "                                    [Result(\"1\", \"2\", affected_code)],\n",
    "                                    None,\n",
    "                                    None)\n",
    "            self.assertRegex(stdout.getvalue(), expected_string)\n",
    "\n",
    "    def test_bad_format(self):\n",
    "        self.section.append(Setting(\"format_str\", \"{nonexistant}\"))\n",
    "        print_results_formatted(self.logger,\n",
    "                                self.section,\n",
    "                                [Result(\"1\", \"2\")],\n",
    "                                None,\n",
    "                                None)\n",
    "        self.assertRegex(self.printer.string, \".*Unable to print.*\")\n",
    "\n",
    "    def test_good_format(self):\n",
    "        self.section.append(Setting(\"format_str\", \"{origin}\"))\n",
    "        with retrieve_stdout() as stdout:\n",
    "            print_results_formatted(self.logger,\n",
    "                                    self.section,\n",
    "                                    [Result(\"1\", \"2\")],\n",
    "                                    None,\n",
    "                                    None)\n",
    "            self.assertEqual(stdout.getvalue(), \"1\\n\")\n",
    "\n",
    "    def test_empty_list(self):\n",
    "        self.section.append(Setting(\"format_str\", \"{origin}\"))\n",
    "        # Shouldn't attempt to format the string None and will fail badly if\n",
    "        # its done wrong.\n",
    "        print_results_formatted(None,\n",
    "                                self.section,\n",
    "                                [],\n",
    "                                None,\n",
    "                                None,\n",
    "                                None)\n"
  ],
  "/home/tushar/coala/tests/output/InteractionsTest.py": [
    "import unittest\n",
    "\n",
    "from pyprint.NullPrinter import NullPrinter\n",
    "\n",
    "from coalib.output.Interactions import fail_acquire_settings\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "\n",
    "\n",
    "class InteractionsTest(unittest.TestCase):\n",
    "\n",
    "    def test_(self):\n",
    "        log_printer = LogPrinter(NullPrinter())\n",
    "        self.assertRaises(TypeError, fail_acquire_settings, log_printer, None)\n",
    "        self.assertRaises(AssertionError,\n",
    "                          fail_acquire_settings,\n",
    "                          log_printer,\n",
    "                          {\"setting\": [\"description\", \"bear\"]})\n",
    "        self.assertEqual(fail_acquire_settings(log_printer, {}), None)\n"
  ],
  "/home/tushar/coala/tests/output/JSONEncoderTest.py": [
    "import json\n",
    "import unittest\n",
    "from datetime import datetime\n",
    "\n",
    "from coalib.output.JSONEncoder import create_json_encoder\n",
    "\n",
    "\n",
    "class TestClass1(object):\n",
    "\n",
    "    def __init__(self):\n",
    "        self.a = 0\n",
    "\n",
    "\n",
    "class TestClass2(object):\n",
    "\n",
    "    def __init__(self):\n",
    "        self.a = 0\n",
    "        self.b = TestClass1()\n",
    "\n",
    "\n",
    "class TestClass3(object):\n",
    "\n",
    "    def __init__(self):\n",
    "        self.a = 0\n",
    "        self.b = TestClass1()\n",
    "\n",
    "    @staticmethod\n",
    "    def __getitem__(key):\n",
    "        return \"val\"\n",
    "\n",
    "    @staticmethod\n",
    "    def keys():\n",
    "        return [\"key\"]\n",
    "\n",
    "\n",
    "class PropertiedClass(object):\n",
    "\n",
    "    def __init__(self):\n",
    "        self._a = 5\n",
    "\n",
    "    @property\n",
    "    def prop(self):\n",
    "        return self._a\n",
    "\n",
    "\n",
    "class JSONAbleClass(object):\n",
    "\n",
    "    @staticmethod\n",
    "    def __json__():\n",
    "        return ['dont', 'panic']\n",
    "\n",
    "\n",
    "class JSONEncoderTest(unittest.TestCase):\n",
    "    JSONEncoder = create_json_encoder(use_relpath=True)\n",
    "    kw = {\"cls\": JSONEncoder, \"sort_keys\": True}\n",
    "\n",
    "    def test_builtins(self):\n",
    "        self.assertEquals('\"test\"', json.dumps(\"test\", **self.kw))\n",
    "        self.assertEquals('1', json.dumps(1, **self.kw))\n",
    "        self.assertEquals('true', json.dumps(True, **self.kw))\n",
    "        self.assertEquals('null', json.dumps(None, **self.kw))\n",
    "\n",
    "    def test_iter(self):\n",
    "        self.assertEquals('[0, 1]', json.dumps([0, 1], **self.kw))\n",
    "        self.assertEquals('[0, 1]', json.dumps((0, 1), **self.kw))\n",
    "        self.assertEquals('[0, 1]', json.dumps(range(2), **self.kw))\n",
    "\n",
    "    def test_dict(self):\n",
    "        self.assertEquals('{\"0\": 1}', json.dumps({0: 1}, **self.kw))\n",
    "        self.assertEquals('{\"0\": 1}', json.dumps({\"0\": 1}, **self.kw))\n",
    "        self.assertEquals('{\"0\": \"1\"}', json.dumps({\"0\": \"1\"}, **self.kw))\n",
    "\n",
    "    def test_time(self):\n",
    "        tf = datetime.today()\n",
    "        self.assertEquals('\"' + tf.isoformat() + '\"',\n",
    "                          json.dumps(tf, **self.kw))\n",
    "\n",
    "    def test_class1(self):\n",
    "        tc1 = TestClass1()\n",
    "        self.assertEquals('{\"a\": 0}', json.dumps(tc1, **self.kw))\n",
    "        self.assertEquals('[{\"a\": 0}]', json.dumps([tc1], **self.kw))\n",
    "        self.assertEquals('{\"0\": {\"a\": 0}}', json.dumps({0: tc1}, **self.kw))\n",
    "\n",
    "    def test_class2(self):\n",
    "        tc2 = TestClass2()\n",
    "        self.assertEquals('{\"a\": 0, \"b\": {\"a\": 0}}',\n",
    "                          json.dumps(tc2, **self.kw))\n",
    "\n",
    "    def test_class3(self):\n",
    "        tc3 = TestClass3()\n",
    "        self.assertEquals('{\"key\": \"val\"}',\n",
    "                          json.dumps(tc3, **self.kw))\n",
    "\n",
    "    def test_propertied_class(self):\n",
    "        uut = PropertiedClass()\n",
    "        self.assertEqual('{\"prop\": 5}', json.dumps(uut, **self.kw))\n",
    "\n",
    "    def test_jsonable_class(self):\n",
    "        uut = JSONAbleClass()\n",
    "        self.assertEqual('[\"dont\", \"panic\"]', json.dumps(uut, **self.kw))\n",
    "\n",
    "    def test_type_error(self):\n",
    "        with self.assertRaises(TypeError):\n",
    "            json.dumps(1j, **self.kw)\n"
  ],
  "/home/tushar/coala/tests/output/TaggingTest.py": [
    "import os\n",
    "import unittest\n",
    "\n",
    "from pyprint.NullPrinter import NullPrinter\n",
    "\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "from coalib.output.Tagging import (\n",
    "    delete_tagged_results, get_tag_path, load_tagged_results, tag_results)\n",
    "from tests.TestUtilities import raise_error\n",
    "\n",
    "\n",
    "class TaggingTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.log_printer = LogPrinter(NullPrinter())\n",
    "\n",
    "    def test_get_tag_path(self):\n",
    "        self.assertEqual(get_tag_path(\"a\", \"b\", self.log_printer),\n",
    "                         get_tag_path(\"a\", \"b\", self.log_printer))\n",
    "        self.assertNotEqual(get_tag_path(\"a\", \"b\", self.log_printer),\n",
    "                            get_tag_path(\"a\", \"c\", self.log_printer))\n",
    "        self.assertNotEqual(get_tag_path(\"a\", \"b\", self.log_printer),\n",
    "                            get_tag_path(\"c\", \"b\", self.log_printer))\n",
    "\n",
    "    def test_tag_results(self):\n",
    "        path = get_tag_path(\"test_tag_create\", \"test_path\", self.log_printer)\n",
    "        try:\n",
    "            tag_results(\"test_tag_create\", \"test_path\", {}, self.log_printer)\n",
    "            results = load_tagged_results(\"test_tag_create\",\n",
    "                                          \"test_path\",\n",
    "                                          self.log_printer)\n",
    "            self.assertEqual(results, {})\n",
    "        finally:\n",
    "            delete_tagged_results(\"test_tag_create\",\n",
    "                                  \"test_path\",\n",
    "                                  self.log_printer)\n",
    "\n",
    "        none_path = get_tag_path(\"None\", \"test_path\", self.log_printer)\n",
    "        tag_results(\"None\", \"test_path\", {}, self.log_printer)\n",
    "        self.assertFalse(os.path.exists(none_path))\n",
    "        results = load_tagged_results(\"None\", \"test_path\", self.log_printer)\n",
    "        self.assertEquals(results, None)\n",
    "\n",
    "    def test_delete_tagged_results_no_file(self):\n",
    "        path = get_tag_path(\"test_tag_del\", \"test_path\", self.log_printer)\n",
    "        none_path = get_tag_path(\"None\", \"test_path\", self.log_printer)\n",
    "        open(path, \"a\").close()\n",
    "        open(none_path, \"a\").close()\n",
    "        delete_tagged_results(\"None\", \"test_path\", self.log_printer)\n",
    "        self.assertTrue(os.path.exists(none_path))\n",
    "\n",
    "        delete_tagged_results(\"test_tag_del\", \"test_path\", self.log_printer)\n",
    "        self.assertFalse(os.path.exists(path))\n",
    "\n",
    "        delete_tagged_results(\"test_tag_del2\", \"test_path\", self.log_printer)\n",
    "        self.assertFalse(os.path.exists(path))\n",
    "\n",
    "        os.remove(none_path)\n",
    "\n",
    "    def test_permission_error(self):\n",
    "        old_makedirs = os.makedirs\n",
    "        os.makedirs = lambda *args, **kwargs: raise_error(PermissionError)\n",
    "\n",
    "        self.assertEqual(get_tag_path(\"a\", \"b\", self.log_printer), None)\n",
    "        tag_results(\"test_tag\", \"test_path\", {}, self.log_printer)\n",
    "        results = load_tagged_results(\"test_tag\",\n",
    "                                      \"test_path\",\n",
    "                                      self.log_printer)\n",
    "        self.assertEqual(results, None)\n",
    "\n",
    "        os.makedirs = old_makedirs\n"
  ],
  "/home/tushar/coala/tests/output/__init__.py": [],
  "/home/tushar/coala/tests/output/dbus/BuildDbusServiceTest.py": [
    "import unittest\n",
    "from distutils.errors import DistutilsOptionError\n",
    "\n",
    "from setuptools.dist import Distribution\n",
    "\n",
    "from coalib.misc import Constants\n",
    "from coalib.misc.ContextManagers import make_temp\n",
    "from coalib.output.dbus.BuildDbusService import BuildDbusService\n",
    "\n",
    "\n",
    "class BuildDbusServiceTest(unittest.TestCase):\n",
    "\n",
    "    def test_build(self):\n",
    "        dist = Distribution()\n",
    "        uut = BuildDbusService(dist)\n",
    "        self.assertRaises(DistutilsOptionError, uut.finalize_options)\n",
    "        with make_temp() as uut.output:\n",
    "            uut.finalize_options()\n",
    "\n",
    "            uut.run()\n",
    "            with open(uut.output) as file:\n",
    "                result = file.read(1000)\n",
    "\n",
    "            self.assertEqual(\n",
    "                result,\n",
    "                \"[D-BUS Service]\\nNames=\" + Constants.BUS_NAME +\n",
    "                \"\\nExec=coala-dbus\")\n"
  ],
  "/home/tushar/coala/tests/output/dbus/DbusAppTest.py": [
    "import unittest\n",
    "from unittest.case import SkipTest\n",
    "\n",
    "try:\n",
    "    from coalib.output.dbus.DbusApp import DbusApp\n",
    "except ImportError as err:\n",
    "    raise SkipTest('python-dbus is not installed')\n",
    "\n",
    "\n",
    "class DbusAppTest(unittest.TestCase):\n",
    "\n",
    "    def test_docs(self):\n",
    "        uut = DbusApp(app_id=1)\n",
    "        doc1 = __file__\n",
    "        doc2 = __file__ + \".txt\"\n",
    "\n",
    "        uut.create_document(doc1)\n",
    "        self.assertIn(doc1, uut.docs)\n",
    "\n",
    "        uut.dispose_document(doc2)\n",
    "        self.assertNotIn(doc2, uut.docs)\n",
    "        self.assertIn(doc1, uut.docs)\n",
    "\n",
    "        uut.dispose_document(doc1)\n",
    "        self.assertNotIn(doc1, uut.docs)\n"
  ],
  "/home/tushar/coala/tests/output/dbus/DbusDocumentTest.py": [
    "import os\n",
    "import unittest\n",
    "from unittest.case import SkipTest\n",
    "\n",
    "from coalib.misc import Constants\n",
    "\n",
    "try:\n",
    "    from coalib.output.dbus.DbusDocument import DbusDocument\n",
    "except ImportError as err:\n",
    "    raise SkipTest('python-dbus is not installed')\n",
    "\n",
    "\n",
    "class DbusDocumentTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.config_path = os.path.abspath(\n",
    "            os.path.join(os.path.dirname(__file__),\n",
    "                         \"dbus_test_files\",\n",
    "                         \".coafile\"))\n",
    "        self.testcode_c_path = os.path.abspath(\n",
    "            os.path.join(os.path.dirname(__file__),\n",
    "                         \"dbus_test_files\",\n",
    "                         \"testcode.c\"))\n",
    "\n",
    "    def test_path(self):\n",
    "        test_file = \"a\"\n",
    "        uut = DbusDocument(doc_id=1)\n",
    "        self.assertEqual(uut.path, \"\")\n",
    "\n",
    "        uut = DbusDocument(doc_id=1, path=test_file)\n",
    "        self.assertEqual(uut.path, os.path.abspath(test_file))\n",
    "\n",
    "    def test_config(self):\n",
    "        uut = DbusDocument(doc_id=1)\n",
    "        self.assertEqual(uut.FindConfigFile(), \"\")\n",
    "\n",
    "        uut.path = self.testcode_c_path\n",
    "        self.assertEqual(uut.FindConfigFile(), self.config_path)\n",
    "\n",
    "        uut.SetConfigFile(\"config_file\")\n",
    "        self.assertEqual(uut.config_file, \"config_file\")\n",
    "\n",
    "        self.assertEqual(uut.GetConfigFile(), \"config_file\")\n",
    "\n",
    "    def test_analyze(self):\n",
    "        uut = DbusDocument(doc_id=1)\n",
    "        self.assertEqual(uut.Analyze(), [])\n",
    "\n",
    "        uut.path = self.testcode_c_path\n",
    "        self.assertEqual(uut.Analyze(), [])\n",
    "\n",
    "        self.maxDiff = None\n",
    "        uut.SetConfigFile(self.config_path)\n",
    "        output = uut.Analyze()\n",
    "        self.assertEqual(output,\n",
    "                         (1,\n",
    "                          [],\n",
    "                          [['default',\n",
    "                            True,\n",
    "                            [{'debug_msg': '',\n",
    "                              'additional_info': '',\n",
    "                              'file': '',\n",
    "                              'id': output[2][0][2][0]['id'],\n",
    "                              'line_nr': '',\n",
    "                              'message': 'test msg',\n",
    "                              'origin': 'LocalTestBear',\n",
    "                              'severity': 'NORMAL'},\n",
    "                             {'debug_msg': '',\n",
    "                              'additional_info': '',\n",
    "                              'file': self.testcode_c_path,\n",
    "                              'id': output[2][0][2][1]['id'],\n",
    "                              'line_nr': '',\n",
    "                              'message': 'test msg',\n",
    "                              'origin': 'GlobalTestBear',\n",
    "                              'severity': 'NORMAL'}]]]))\n",
    "\n",
    "        uut.path = \"test.unknown_extension\"\n",
    "        output = uut.Analyze()\n",
    "        self.assertEqual(output, (0, [], []))\n",
    "\n",
    "        uut.SetConfigFile(self.config_path + \"2\")\n",
    "        output = uut.Analyze()\n",
    "        self.assertEqual(output[0], 255)\n",
    "        self.assertEqual(output[1][1][\"log_level\"], \"ERROR\")\n",
    "        self.assertEqual(output[1][1][\"message\"], Constants.CRASH_MESSAGE)\n"
  ],
  "/home/tushar/coala/tests/output/dbus/DbusServerTest.py": [
    "import unittest\n",
    "from unittest.case import SkipTest\n",
    "\n",
    "try:\n",
    "    import dbus\n",
    "    import dbus.mainloop\n",
    "\n",
    "    from coalib.output.dbus.DbusServer import DbusServer\n",
    "except ImportError as err:\n",
    "    raise SkipTest('python-dbus is not installed')\n",
    "\n",
    "\n",
    "class DbusServerTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.session_bus = dbus.SessionBus(\n",
    "            mainloop=dbus.mainloop.NULL_MAIN_LOOP)\n",
    "        self.dbus_name = dbus.service.BusName(\"org.coala_analyzer.v1.test\",\n",
    "                                              self.session_bus)\n",
    "\n",
    "    def tearDown(self):\n",
    "        self.session_bus.close()\n",
    "\n",
    "    def test_apps(self):\n",
    "        uut = DbusServer(self.session_bus, \"/org/coala_analyzer/v1/test_apps\")\n",
    "\n",
    "        uut.get_or_create_app(\"app1\")\n",
    "        self.assertEqual(len(uut.apps), 1)\n",
    "        self.assertIn(\"app1\", uut.apps)\n",
    "\n",
    "        uut.get_or_create_app(\"app1\")\n",
    "        self.assertIn(\"app1\", uut.apps)\n",
    "\n",
    "        uut.dispose_app(\"app2\")\n",
    "        self.assertNotIn(\"app2\", uut.apps)\n",
    "        self.assertIn(\"app1\", uut.apps)\n",
    "\n",
    "        uut.dispose_app(\"app1\")\n",
    "        self.assertNotIn(\"app1\", uut.apps)\n",
    "\n",
    "    def test_on_name_lost(self):\n",
    "        uut = DbusServer(self.session_bus,\n",
    "                         \"/org/coala_analyzer/v1/test_on_name_lost\")\n",
    "        uut.create_app(\"app1\")\n",
    "\n",
    "        uut._on_name_lost(\"\", \"\", \"a1\")\n",
    "        self.assertIn(\"app1\", uut.apps)\n",
    "\n",
    "        uut._on_name_lost(\"\", \"app2\", \"\")\n",
    "        self.assertIn(\"app1\", uut.apps)\n",
    "\n",
    "        uut._on_name_lost(\"\", \"app1\", \"\")\n",
    "        self.assertNotIn(\"app1\", uut.apps)\n",
    "\n",
    "    def test_on_disconnected(self):\n",
    "        def on_disconnected_callback():\n",
    "            assert 1 == 2\n",
    "\n",
    "        test_output = 0\n",
    "        uut = DbusServer(self.session_bus,\n",
    "                         \"/org/coala_analyzer/v1/test_callback\",\n",
    "                         on_disconnected_callback)\n",
    "        uut.create_app(\"app1\")\n",
    "        self.assertRaises(AssertionError, uut.dispose_app, \"app1\")\n",
    "\n",
    "    def test_docs(self):\n",
    "        uut = DbusServer(self.session_bus,\n",
    "                         \"/org/coala_analyzer/v1/test_docs\")\n",
    "        uut.create_app(\"app1\")\n",
    "        self.assertIn(\"app1\", uut.apps)\n",
    "\n",
    "        doc1 = __file__\n",
    "        doc2 = __file__ + \".txt\"\n",
    "\n",
    "        uut.create_document(uut.apps[\"app1\"], doc1)\n",
    "        self.assertIn(doc1, uut.apps[\"app1\"].docs)\n",
    "\n",
    "        uut.get_or_create_document(uut.apps[\"app1\"], doc1)\n",
    "        self.assertIn(doc1, uut.apps[\"app1\"].docs)\n",
    "\n",
    "        uut.dispose_document(uut.apps[\"app1\"], doc2)\n",
    "        self.assertIn(\"app1\", uut.apps)\n",
    "        self.assertNotIn(doc2, uut.apps[\"app1\"].docs)\n",
    "        self.assertIn(doc1, uut.apps[\"app1\"].docs)\n",
    "\n",
    "        uut.get_or_create_document(uut.apps[\"app1\"], doc2)\n",
    "        uut.dispose_document(uut.apps[\"app1\"], doc1)\n",
    "        self.assertIn(\"app1\", uut.apps)\n",
    "        self.assertIn(doc2, uut.apps[\"app1\"].docs)\n",
    "\n",
    "        uut.dispose_document(uut.apps[\"app1\"], doc2)\n",
    "        self.assertNotIn(\"app1\", uut.apps)\n",
    "\n",
    "    def test_dbus_methods(self):\n",
    "        uut = DbusServer(self.session_bus,\n",
    "                         \"/org/coala_analyzer/v1/test_dbus_methods\")\n",
    "        doc1 = __file__\n",
    "\n",
    "        uut.CreateDocument(doc1, sender=\"app1\")\n",
    "        self.assertIn(\"app1\", uut.apps)\n",
    "        self.assertIn(doc1, uut.apps[\"app1\"].docs)\n",
    "\n",
    "        uut.DisposeDocument(doc1, sender=\"app1\")\n",
    "        self.assertNotIn(\"app1\", uut.apps)\n",
    "\n",
    "        uut.DisposeDocument(doc1, sender=\"app2\")\n",
    "        self.assertEqual(len(uut.apps), 0)\n"
  ],
  "/home/tushar/coala/tests/output/dbus/DbusTest.py": [
    "import os\n",
    "import subprocess\n",
    "import sys\n",
    "import time\n",
    "import unittest\n",
    "from unittest.case import SkipTest\n",
    "\n",
    "from coalib.misc import Constants\n",
    "\n",
    "try:\n",
    "    import dbus\n",
    "    # Needed to determine if test needs skipping\n",
    "    from gi.repository import GLib\n",
    "except ImportError as err:\n",
    "    raise SkipTest('python-dbus or python-gi is not installed')\n",
    "\n",
    "\n",
    "def make_test_server():\n",
    "    # Make a dbus service in a new process. It cannot be in this process\n",
    "    # as that gives SegmentationFaults because the same bus is being used.\n",
    "\n",
    "    # For some reason this also fails on some systems if moved to another file\n",
    "    return subprocess.Popen([\n",
    "        sys.executable,\n",
    "        '-c',\n",
    "        \"\"\"\n",
    "import sys\n",
    "import dbus\n",
    "import dbus.mainloop.glib\n",
    "from gi.repository import GLib\n",
    "from coalib.output.dbus.DbusServer import DbusServer\n",
    "dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)\n",
    "print('Creating session bus ...')\n",
    "session_bus = dbus.SessionBus()\n",
    "dbus_name = dbus.service.BusName(\"org.coala_analyzer.v1.test\", session_bus)\n",
    "print('Creating DbbusServer object ...')\n",
    "dbus_server = DbusServer(session_bus, \"/org/coala_analyzer/v1/test\",\n",
    "                         on_disconnected=lambda: GLib.idle_add(sys.exit))\n",
    "mainloop = GLib.MainLoop()\n",
    "print('Starting GLib mainloop ...')\n",
    "mainloop.run()\n",
    "\"\"\"],\n",
    "        stdout=subprocess.PIPE,\n",
    "        stderr=subprocess.PIPE)\n",
    "\n",
    "\n",
    "class DbusTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.config_path = os.path.abspath(\n",
    "            os.path.join(os.path.dirname(__file__),\n",
    "                         \"dbus_test_files\",\n",
    "                         \".coafile\"))\n",
    "        self.testcode_c_path = os.path.abspath(\n",
    "            os.path.join(os.path.dirname(__file__),\n",
    "                         \"dbus_test_files\",\n",
    "                         \"testcode.c\"))\n",
    "\n",
    "        self.subprocess = make_test_server()\n",
    "        trials_left = 50\n",
    "\n",
    "        while trials_left > 0:\n",
    "            time.sleep(0.1)\n",
    "            trials_left = trials_left - 1\n",
    "            try:\n",
    "                self.connect_to_test_server()\n",
    "                continue\n",
    "            except dbus.exceptions.DBusException as exception:\n",
    "                if trials_left == 0:\n",
    "                    print(\"Stdout:\")\n",
    "                    print(self.subprocess.stdout.read().decode(\"utf-8\"))\n",
    "                    print(\"Stderr:\")\n",
    "                    print(self.subprocess.stderr.read().decode(\"utf-8\"))\n",
    "                    raise exception\n",
    "\n",
    "    def connect_to_test_server(self):\n",
    "        self.bus = dbus.SessionBus()\n",
    "        self.remote_object = self.bus.get_object(\"org.coala_analyzer.v1.test\",\n",
    "                                                 \"/org/coala_analyzer/v1/test\")\n",
    "\n",
    "    def test_dbus(self):\n",
    "        self.document_object_path = self.remote_object.CreateDocument(\n",
    "            self.testcode_c_path,\n",
    "            dbus_interface=\"org.coala_analyzer.v1\")\n",
    "\n",
    "        self.assertRegex(str(self.document_object_path),\n",
    "                         r\"^/org/coala_analyzer/v1/test/\\d+/documents/\\d+$\")\n",
    "\n",
    "        self.document_object = self.bus.get_object(\n",
    "            \"org.coala_analyzer.v1.test\",\n",
    "            self.document_object_path)\n",
    "\n",
    "        config_file = self.document_object.SetConfigFile(\n",
    "            \"dummy_config\",\n",
    "            dbus_interface=\"org.coala_analyzer.v1\")\n",
    "        self.assertEqual(config_file, \"dummy_config\")\n",
    "\n",
    "        config_file = self.document_object.GetConfigFile(\n",
    "            dbus_interface=\"org.coala_analyzer.v1\")\n",
    "        self.assertEqual(config_file, \"dummy_config\")\n",
    "\n",
    "        config_file = self.document_object.FindConfigFile(\n",
    "            dbus_interface=\"org.coala_analyzer.v1\")\n",
    "        self.assertEqual(config_file, self.config_path)\n",
    "\n",
    "        analysis = self.document_object.Analyze(\n",
    "            dbus_interface=\"org.coala_analyzer.v1\")\n",
    "\n",
    "        self.maxDiff = None\n",
    "        print(analysis)\n",
    "\n",
    "        # Run some basic analysis with good debug messages.\n",
    "        self.assertEqual(analysis[0], 1, \"Exit code was not 1.\")\n",
    "        self.assertEqual(len(analysis[1]), 0, \"Unexpected log messages found.\")\n",
    "\n",
    "        sections = analysis[2]\n",
    "        self.assertEqual(len(sections), 1, \"Expected only 1 section to run.\")\n",
    "\n",
    "        section = sections[0]\n",
    "        self.assertEqual(section[0], \"default\",\n",
    "                         \"Expected section to be named 'default'.\")\n",
    "        self.assertTrue(section[1], \"Section did not execute successfully.\")\n",
    "        self.assertEqual(len(section[2]), 2, \"Expected 2 results in section.\")\n",
    "\n",
    "        # Remove the ids as they are hashes and cannot be asserted.\n",
    "        for result in section[2]:\n",
    "            result['id'] = 0\n",
    "\n",
    "        # We also test as a dictionary as dbus should be able to convert\n",
    "        # it into the correct python types.\n",
    "        self.assertEqual(analysis,\n",
    "                         (1,\n",
    "                          [],\n",
    "                          [('default',\n",
    "                            True,\n",
    "                            [{'debug_msg': '',\n",
    "                              'additional_info': '',\n",
    "                              'file': '',\n",
    "                              'id': 0,\n",
    "                              'line_nr': \"\",\n",
    "                              'message': 'test msg',\n",
    "                              'origin': 'LocalTestBear',\n",
    "                              'severity': 'NORMAL'},\n",
    "                             {'debug_msg': '',\n",
    "                              'additional_info': '',\n",
    "                              'file': self.testcode_c_path,\n",
    "                              'id': 0,\n",
    "                              'line_nr': \"\",\n",
    "                              'message': 'test msg',\n",
    "                              'origin': 'GlobalTestBear',\n",
    "                              'severity': 'NORMAL'}])]))\n",
    "\n",
    "        config_file = self.document_object.SetConfigFile(\n",
    "            self.config_path + \"2\",\n",
    "            dbus_interface=\"org.coala_analyzer.v1\")\n",
    "        analysis = self.document_object.Analyze(\n",
    "            dbus_interface=\"org.coala_analyzer.v1\")\n",
    "        self.assertEqual(analysis[0], 255)\n",
    "        self.assertEqual(analysis[1][1][\"log_level\"], \"ERROR\")\n",
    "        self.assertEqual(analysis[1][1][\"message\"], Constants.CRASH_MESSAGE)\n",
    "\n",
    "        # Skip file if file pattern doesn't match\n",
    "        # Also test if 2 documents can be opened simultaneously\n",
    "        self.document_object_path = self.remote_object.CreateDocument(\n",
    "            \"test.unknown_ext\",\n",
    "            dbus_interface=\"org.coala_analyzer.v1\")\n",
    "        self.document_object = self.bus.get_object(\n",
    "            \"org.coala_analyzer.v1.test\",\n",
    "            self.document_object_path)\n",
    "        config_file = self.document_object.SetConfigFile(\n",
    "            self.config_path,\n",
    "            dbus_interface=\"org.coala_analyzer.v1\")\n",
    "        analysis = self.document_object.Analyze(\n",
    "            dbus_interface=\"org.coala_analyzer.v1\")\n",
    "        self.assertEqual(analysis, (0, [], []))\n",
    "\n",
    "        self.remote_object.DisposeDocument(\n",
    "            self.testcode_c_path,\n",
    "            dbus_interface=\"org.coala_analyzer.v1\")\n",
    "\n",
    "        self.remote_object.DisposeDocument(\n",
    "            \"test.unknown_ext\",\n",
    "            dbus_interface=\"org.coala_analyzer.v1\")\n",
    "\n",
    "    def tearDown(self):\n",
    "        if self.subprocess:\n",
    "            self.subprocess.kill()\n"
  ],
  "/home/tushar/coala/tests/output/dbus/__init__.py": [],
  "/home/tushar/coala/tests/output/dbus/dbus_test_files/GlobalTestBear.py": [
    "from coalib.bears.GlobalBear import GlobalBear\n",
    "from coalib.results.Result import Result\n",
    "\n",
    "\n",
    "class GlobalTestBear(GlobalBear):  # pragma: no cover\n",
    "\n",
    "    def run(self, required_arg: bool):\n",
    "        for filename in self.file_dict:\n",
    "            return [Result.from_values(\"GlobalTestBear\", \"test msg\", filename)]\n"
  ],
  "/home/tushar/coala/tests/output/dbus/dbus_test_files/LocalTestBear.py": [
    "from coalib.bears.LocalBear import LocalBear\n",
    "from coalib.results.HiddenResult import HiddenResult\n",
    "from coalib.results.Result import Result\n",
    "\n",
    "\n",
    "class LocalTestBear(LocalBear):  # pragma: no cover\n",
    "\n",
    "    def run(self, filename, file):\n",
    "        return [Result(\"LocalTestBear\", \"test msg\"),\n",
    "                HiddenResult(\"LocalTestBear\", \"hidden msg\")]\n"
  ],
  "/home/tushar/coala/tests/output/printers/ListLogPrinterTest.py": [
    "import unittest\n",
    "from datetime import datetime\n",
    "\n",
    "from coalib.output.printers.ListLogPrinter import ListLogPrinter\n",
    "from coalib.output.printers.LOG_LEVEL import LOG_LEVEL\n",
    "from coalib.processes.communication.LogMessage import LogMessage\n",
    "\n",
    "\n",
    "class ListLogPrinterTest(unittest.TestCase):\n",
    "\n",
    "    def test_logging(self):\n",
    "        uut = ListLogPrinter()\n",
    "        ts = datetime.today()\n",
    "        ts_str = ts.strftime(\"%X\")\n",
    "\n",
    "        uut.log_level = LOG_LEVEL.INFO\n",
    "        uut.warn(\"Test value\", timestamp=ts)\n",
    "        uut.print(\"Test 2\", timestamp=ts)  # Should go to INFO\n",
    "        uut.debug(\"Test 2\", timestamp=ts)  # Should not be logged\n",
    "\n",
    "        self.assertEqual(uut.logs,\n",
    "                         [LogMessage(LOG_LEVEL.WARNING,\n",
    "                                     \"Test value\",\n",
    "                                     timestamp=ts),\n",
    "                          LogMessage(LOG_LEVEL.INFO,\n",
    "                                     \"Test 2\",\n",
    "                                     timestamp=ts)])\n",
    "\n",
    "        self.assertRaises(TypeError, uut.log_message, \"message\")\n"
  ],
  "/home/tushar/coala/tests/output/printers/LogPrinterTest.py": [
    "import unittest\n",
    "from datetime import datetime\n",
    "\n",
    "from pyprint.NullPrinter import NullPrinter\n",
    "from pyprint.Printer import Printer\n",
    "from pyprint.StringPrinter import StringPrinter\n",
    "\n",
    "from coalib.misc import Constants\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "from coalib.processes.communication.LogMessage import LOG_LEVEL, LogMessage\n",
    "\n",
    "\n",
    "class LogPrinterTest(unittest.TestCase):\n",
    "    timestamp = datetime.today()\n",
    "    log_message = LogMessage(LOG_LEVEL.ERROR,\n",
    "                             Constants.COMPLEX_TEST_STRING,\n",
    "                             timestamp=timestamp)\n",
    "\n",
    "    def test_interface(self):\n",
    "        uut = LogPrinter(Printer())\n",
    "        self.assertRaises(NotImplementedError,\n",
    "                          uut.log_message,\n",
    "                          self.log_message)\n",
    "\n",
    "    def test_get_printer(self):\n",
    "        self.assertIs(LogPrinter(None).printer, None)\n",
    "        printer = Printer()\n",
    "        self.assertIs(LogPrinter(printer).printer, printer)\n",
    "\n",
    "    def test_logging(self):\n",
    "        uut = LogPrinter(StringPrinter(), timestamp_format=\"\")\n",
    "        uut.log_message(self.log_message, end=\"\")\n",
    "        self.assertEqual(uut.printer.string, str(self.log_message))\n",
    "\n",
    "        uut = LogPrinter(StringPrinter(), log_level=LOG_LEVEL.DEBUG)\n",
    "        uut.log_message(self.log_message, end=\"\")\n",
    "        self.assertEqual(\n",
    "            uut.printer.string,\n",
    "            \"[ERROR][\" + self.timestamp.strftime(\"%X\") + \"] \" +\n",
    "            Constants.COMPLEX_TEST_STRING)\n",
    "\n",
    "        uut.printer.clear()\n",
    "        uut.log(LOG_LEVEL.ERROR,\n",
    "                Constants.COMPLEX_TEST_STRING,\n",
    "                timestamp=self.timestamp,\n",
    "                end=\"\")\n",
    "        self.assertEqual(\n",
    "            uut.printer.string,\n",
    "            \"[ERROR][\" + self.timestamp.strftime(\"%X\") + \"] \" +\n",
    "            Constants.COMPLEX_TEST_STRING)\n",
    "\n",
    "        uut.printer.clear()\n",
    "        uut.debug(Constants.COMPLEX_TEST_STRING,\n",
    "                  \"d\",\n",
    "                  timestamp=self.timestamp,\n",
    "                  end=\"\")\n",
    "        self.assertEqual(\n",
    "            uut.printer.string,\n",
    "            \"[DEBUG][\" + self.timestamp.strftime(\"%X\") + \"] \" +\n",
    "            Constants.COMPLEX_TEST_STRING + \" d\")\n",
    "\n",
    "        uut.printer.clear()\n",
    "        uut.log_level = LOG_LEVEL.INFO\n",
    "        uut.debug(Constants.COMPLEX_TEST_STRING,\n",
    "                  timestamp=self.timestamp,\n",
    "                  end=\"\")\n",
    "        self.assertEqual(uut.printer.string, \"\")\n",
    "\n",
    "        uut.printer.clear()\n",
    "        uut.info(Constants.COMPLEX_TEST_STRING,\n",
    "                 \"d\",\n",
    "                 timestamp=self.timestamp,\n",
    "                 end=\"\")\n",
    "        self.assertEqual(\n",
    "            uut.printer.string,\n",
    "            \"[INFO][\" + self.timestamp.strftime(\"%X\") + \"] \" +\n",
    "            Constants.COMPLEX_TEST_STRING + \" d\")\n",
    "\n",
    "        uut.log_level = LOG_LEVEL.WARNING\n",
    "        uut.printer.clear()\n",
    "        uut.debug(Constants.COMPLEX_TEST_STRING,\n",
    "                  timestamp=self.timestamp,\n",
    "                  end=\"\")\n",
    "        self.assertEqual(uut.printer.string, \"\")\n",
    "\n",
    "        uut.printer.clear()\n",
    "        uut.warn(Constants.COMPLEX_TEST_STRING,\n",
    "                 \"d\",\n",
    "                 timestamp=self.timestamp,\n",
    "                 end=\"\")\n",
    "        self.assertEqual(\n",
    "            uut.printer.string,\n",
    "            \"[WARNING][\" + self.timestamp.strftime(\"%X\") + \"] \" +\n",
    "            Constants.COMPLEX_TEST_STRING + \" d\")\n",
    "\n",
    "        uut.printer.clear()\n",
    "        uut.err(Constants.COMPLEX_TEST_STRING,\n",
    "                \"d\",\n",
    "                timestamp=self.timestamp,\n",
    "                end=\"\")\n",
    "        self.assertEqual(\n",
    "            uut.printer.string,\n",
    "            \"[ERROR][\" + self.timestamp.strftime(\"%X\") + \"] \" +\n",
    "            Constants.COMPLEX_TEST_STRING + \" d\")\n",
    "\n",
    "        uut.log_level = LOG_LEVEL.DEBUG\n",
    "        uut.printer.clear()\n",
    "        uut.log_exception(\n",
    "            \"Something failed.\",\n",
    "            NotImplementedError(Constants.COMPLEX_TEST_STRING),\n",
    "            timestamp=self.timestamp)\n",
    "        self.assertTrue(uut.printer.string.startswith(\n",
    "            \"[ERROR][\" + self.timestamp.strftime(\"%X\") +\n",
    "            \"] Something failed.\\n\" +\n",
    "            \"[DEBUG][\" + self.timestamp.strftime(\"%X\") +\n",
    "            \"] Exception was:\"))\n",
    "\n",
    "        uut.log_level = LOG_LEVEL.INFO\n",
    "        uut.printer.clear()\n",
    "        logged = uut.log_exception(\n",
    "            \"Something failed.\",\n",
    "            NotImplementedError(Constants.COMPLEX_TEST_STRING),\n",
    "            timestamp=self.timestamp,\n",
    "            end=\"\")\n",
    "        self.assertTrue(uut.printer.string.startswith(\n",
    "            \"[ERROR][\" + self.timestamp.strftime(\"%X\") +\n",
    "            \"] Something failed.\"))\n",
    "\n",
    "    def test_raises(self):\n",
    "        uut = LogPrinter(NullPrinter())\n",
    "        self.assertRaises(TypeError, uut.log, 5)\n",
    "        self.assertRaises(TypeError, uut.log_exception, \"message\", 5)\n",
    "        self.assertRaises(TypeError, uut.log_message, 5)\n"
  ],
  "/home/tushar/coala/tests/output/printers/__init__.py": [],
  "/home/tushar/coala/tests/parsing/CliParsingTest.py": [
    "import argparse\n",
    "import unittest\n",
    "\n",
    "from coalib.parsing.CliParsing import parse_cli, check_conflicts\n",
    "\n",
    "\n",
    "class CliParserTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.test_arg_parser = argparse.ArgumentParser()\n",
    "        self.test_arg_parser.add_argument('-t', nargs='+', dest='test')\n",
    "        self.test_arg_parser.add_argument('-S',\n",
    "                                          '--settings',\n",
    "                                          nargs='+',\n",
    "                                          dest='settings')\n",
    "\n",
    "    @staticmethod\n",
    "    def dict_from_sections(parsed_sections):\n",
    "        parsed_dict = {}\n",
    "        for section_name, section in parsed_sections.items():\n",
    "            parsed_dict[section_name] = (\n",
    "                set([(key,\n",
    "                      str(value)) for key, value in section.contents.items()]))\n",
    "        return parsed_dict\n",
    "\n",
    "    def test_parse_cli(self):\n",
    "        # regular parse\n",
    "        parsed_sections = parse_cli(\n",
    "            ['-t', 'ignored1', 'ignored2',\n",
    "             '-t', 'taken',\n",
    "             '-S', 'section1.key1,section2.key2=value1,value2',\n",
    "             'section2.key2=only_this_value',\n",
    "             'SECTION2.key2a=k2a',\n",
    "             'invalid.=shouldnt_be_shown',\n",
    "             '.=not_either',\n",
    "             '.key=only_in_default',\n",
    "             'default_key1,default_key2=single_value',\n",
    "             'default_key3=first_value,second_value'],\n",
    "            arg_parser=self.test_arg_parser)\n",
    "        expected_dict = {\n",
    "            'default': {\n",
    "                (\"test\", \"taken\"),\n",
    "                (\"key\", \"only_in_default\"),\n",
    "                (\"default_key1\", \"single_value\"),\n",
    "                (\"default_key2\", \"single_value\"),\n",
    "                (\"default_key3\", \"first_value,second_value\")},\n",
    "            'section1': {\n",
    "                (\"key1\", \"value1,value2\")},\n",
    "            'section2': {\n",
    "                (\"key2\", \"only_this_value\"),\n",
    "                (\"key2a\", \"k2a\")}}\n",
    "        self.assertEqual(parsed_sections[\"default\"].name, \"Default\")\n",
    "        self.assertEqual(self.dict_from_sections(parsed_sections),\n",
    "                         expected_dict)\n",
    "\n",
    "    def test_check_conflicts(self):\n",
    "        sections = parse_cli(arg_list=[\"--save\", \"--no-config\"])\n",
    "        with self.assertRaises(SystemExit) as cm:\n",
    "            check_conflicts(sections)\n",
    "            self.assertEqual(cm.exception.code, 2)\n",
    "\n",
    "        sections = parse_cli(arg_list=[\"--no-config\", \"-S\", \"val=42\"])\n",
    "        self.assertTrue(check_conflicts(sections))\n"
  ],
  "/home/tushar/coala/tests/parsing/ConfParserTest.py": [
    "import os\n",
    "import tempfile\n",
    "import unittest\n",
    "from collections import OrderedDict\n",
    "\n",
    "from coalib.parsing.ConfParser import ConfParser\n",
    "from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "class ConfParserTest(unittest.TestCase):\n",
    "    example_file = \"\"\"to be ignored\n",
    "    a_default, another = val\n",
    "    TEST = tobeignored  # do you know that thats a comment\n",
    "    test = push\n",
    "    t =\n",
    "    escaped_\\\\=equal = escaped_\\\\#hash\n",
    "    escaped_\\\\\\\\backslash = escaped_\\\\ space\n",
    "    escaped_\\\\,comma = escaped_\\\\.dot\n",
    "    [MakeFiles]\n",
    "     j  , another = a\n",
    "                   multiline\n",
    "                   value\n",
    "    # just a omment\n",
    "    # just a omment\n",
    "    nokey. = value\n",
    "    default.test = content\n",
    "    makefiles.lastone = val\n",
    "\n",
    "    [EMPTY_ELEM_STRIP]\n",
    "    A = a, b, c\n",
    "    B = a, ,, d\n",
    "    C = ,,,\n",
    "    \"\"\"\n",
    "\n",
    "    def setUp(self):\n",
    "        self.tempdir = tempfile.gettempdir()\n",
    "        self.file = os.path.join(self.tempdir, \".coafile\")\n",
    "        self.nonexistentfile = os.path.join(self.tempdir, \"e81k7bd98t\")\n",
    "        with open(self.file, \"w\") as file:\n",
    "            file.write(self.example_file)\n",
    "\n",
    "        self.uut = ConfParser()\n",
    "        try:\n",
    "            os.remove(self.nonexistentfile)\n",
    "        except FileNotFoundError:\n",
    "            pass\n",
    "\n",
    "        self.sections = self.uut.parse(self.file)\n",
    "\n",
    "    def tearDown(self):\n",
    "        os.remove(self.file)\n",
    "\n",
    "    def test_parse_nonexisting_file(self):\n",
    "        self.assertRaises(FileNotFoundError,\n",
    "                          self.uut.parse,\n",
    "                          self.nonexistentfile)\n",
    "        self.assertNotEqual(self.uut.parse(self.file, True), self.sections)\n",
    "\n",
    "    def test_parse_nonexisting_section(self):\n",
    "        self.assertRaises(IndexError,\n",
    "                          self.uut.get_section,\n",
    "                          \"inexistent section\")\n",
    "\n",
    "    def test_parse_default_section(self):\n",
    "        default_should = OrderedDict([\n",
    "            ('a_default', 'val'),\n",
    "            ('another', 'val'),\n",
    "            ('comment0', '# do you know that thats a comment'),\n",
    "            ('test', 'content'),\n",
    "            ('t', ''),\n",
    "            ('escaped_=equal', 'escaped_#hash'),\n",
    "            ('escaped_\\\\backslash', 'escaped_ space'),\n",
    "            ('escaped_,comma', 'escaped_.dot')])\n",
    "\n",
    "        key, val = self.sections.popitem(last=False)\n",
    "        self.assertTrue(isinstance(val, Section))\n",
    "        self.assertEqual(key, 'default')\n",
    "\n",
    "        is_dict = OrderedDict()\n",
    "        for k in val:\n",
    "            is_dict[k] = str(val[k])\n",
    "        self.assertEqual(is_dict, default_should)\n",
    "\n",
    "    def test_parse_makefiles_section(self):\n",
    "        makefiles_should = OrderedDict([\n",
    "            ('j', 'a\\nmultiline\\nvalue'),\n",
    "            ('another', 'a\\nmultiline\\nvalue'),\n",
    "            ('comment1', '# just a omment'),\n",
    "            ('comment2', '# just a omment'),\n",
    "            ('lastone', 'val'),\n",
    "            ('comment3', ''),\n",
    "            ('a_default', 'val'),\n",
    "            ('comment0', '# do you know that thats a comment'),\n",
    "            ('test', 'content'),\n",
    "            ('t', ''),\n",
    "            ('escaped_=equal', 'escaped_#hash'),\n",
    "            ('escaped_\\\\backslash', 'escaped_ space'),\n",
    "            ('escaped_,comma', 'escaped_.dot')])\n",
    "\n",
    "        # Pop off the default section.\n",
    "        self.sections.popitem(last=False)\n",
    "\n",
    "        key, val = self.sections.popitem(last=False)\n",
    "        self.assertTrue(isinstance(val, Section))\n",
    "        self.assertEqual(key, 'makefiles')\n",
    "\n",
    "        is_dict = OrderedDict()\n",
    "        for k in val:\n",
    "            is_dict[k] = str(val[k])\n",
    "        self.assertEqual(is_dict, makefiles_should)\n",
    "\n",
    "        self.assertEqual(val[\"comment1\"].key, \"comment1\")\n",
    "\n",
    "    def test_parse_empty_elem_strip_section(self):\n",
    "        empty_elem_strip_should = OrderedDict([\n",
    "            ('a', 'a, b, c'),\n",
    "            ('b', 'a, ,, d'),\n",
    "            ('c', ',,,'),\n",
    "            ('comment4', ''),\n",
    "            ('a_default', 'val'),\n",
    "            ('another', 'val'),\n",
    "            ('comment0', '# do you know that thats a comment'),\n",
    "            ('test', 'content'),\n",
    "            ('t', ''),\n",
    "            ('escaped_=equal', 'escaped_#hash'),\n",
    "            ('escaped_\\\\backslash', 'escaped_ space'),\n",
    "            ('escaped_,comma', 'escaped_.dot')])\n",
    "\n",
    "        # Pop off the default and makefiles section.\n",
    "        self.sections.popitem(last=False)\n",
    "        self.sections.popitem(last=False)\n",
    "\n",
    "        key, val = self.sections.popitem(last=False)\n",
    "        self.assertTrue(isinstance(val, Section))\n",
    "        self.assertEqual(key, 'empty_elem_strip')\n",
    "\n",
    "        is_dict = OrderedDict()\n",
    "        for k in val:\n",
    "            is_dict[k] = str(val[k])\n",
    "        self.assertEqual(is_dict, empty_elem_strip_should)\n",
    "\n",
    "    def test_remove_empty_iter_elements(self):\n",
    "        # Test with empty-elem stripping.\n",
    "        uut = ConfParser(remove_empty_iter_elements=True)\n",
    "        uut.parse(self.file)\n",
    "        self.assertEqual(list(uut.get_section(\"EMPTY_ELEM_STRIP\")[\"A\"]),\n",
    "                         [\"a\", \"b\", \"c\"])\n",
    "        self.assertEqual(list(uut.get_section(\"EMPTY_ELEM_STRIP\")[\"B\"]),\n",
    "                         [\"a\", \"d\"])\n",
    "        self.assertEqual(list(uut.get_section(\"EMPTY_ELEM_STRIP\")[\"C\"]),\n",
    "                         [])\n",
    "\n",
    "        # Test without stripping.\n",
    "        uut = ConfParser(remove_empty_iter_elements=False)\n",
    "        uut.parse(self.file)\n",
    "        self.assertEqual(list(uut.get_section(\"EMPTY_ELEM_STRIP\")[\"A\"]),\n",
    "                         [\"a\", \"b\", \"c\"])\n",
    "        self.assertEqual(list(uut.get_section(\"EMPTY_ELEM_STRIP\")[\"B\"]),\n",
    "                         [\"a\", \"\", \"\", \"d\"])\n",
    "        self.assertEqual(list(uut.get_section(\"EMPTY_ELEM_STRIP\")[\"C\"]),\n",
    "                         [\"\", \"\", \"\", \"\"])\n",
    "\n",
    "    def test_config_directory(self):\n",
    "        self.uut.parse(self.tempdir)\n"
  ],
  "/home/tushar/coala/tests/parsing/GlobTestDir/SubDir1/File11.py": [],
  "/home/tushar/coala/tests/parsing/GlobTestDir/SubDir1/File12.py": [],
  "/home/tushar/coala/tests/parsing/GlobbingTest.py": [
    "\"\"\"\n",
    "Tests Globbing and related functions\n",
    "\n",
    "Test Files are local and permanent and organized as follows:\n",
    "\n",
    "GlobTestDir\n",
    "\u251c\u2500\u2500 SubDir1\n",
    "\u2502   \u251c\u2500\u2500 File11.py\n",
    "\u2502   \u2514\u2500\u2500 File12.py\n",
    "\u2502 SubDir2\n",
    "\u2502   \u251c\u2500\u2500 File(with)parentheses.txt\n",
    "\u2502   \u2514\u2500\u2500 File[with]brackets.txt\n",
    "\u251c\u2500\u2500 File1.x\n",
    "\u251c\u2500\u2500 File2.y\n",
    "\u2514\u2500\u2500 File3.z\n",
    "\"\"\"\n",
    "import os\n",
    "import re\n",
    "import unittest\n",
    "\n",
    "from coalib.parsing.Globbing import (\n",
    "    _iter_alternatives, _iter_choices, _position_is_bracketed, fnmatch, glob,\n",
    "    glob_escape)\n",
    "\n",
    "\n",
    "class TestFiles:\n",
    "    \"\"\"\n",
    "    Testfiles to check glob patterns on\n",
    "    \"\"\"\n",
    "    glob_test_root = os.path.split(__file__)[0]\n",
    "    glob_test_dir = os.path.join(glob_test_root, 'GlobTestDir')\n",
    "    dir1 = os.path.join(glob_test_dir, 'SubDir1')\n",
    "    file11 = os.path.join(dir1, 'File11.py')\n",
    "    file12 = os.path.join(dir1, 'File12.py')\n",
    "    dir2 = os.path.join(glob_test_dir, 'SubDir2')\n",
    "    file_paren = os.path.join(dir2, 'File(with)parentheses.txt')\n",
    "    file_brack = os.path.join(dir2, 'File[with]brackets.txt')\n",
    "    file1 = os.path.join(glob_test_dir, 'File1.x')\n",
    "    file2 = os.path.join(glob_test_dir, 'File2.y')\n",
    "    file3 = os.path.join(glob_test_dir, 'File3.z')\n",
    "\n",
    "\n",
    "class GlobbingHelperFunctionsTest(unittest.TestCase):\n",
    "\n",
    "    def test_positions(self):\n",
    "        # pattern: [bracketed values]\n",
    "        pattern_positions_dict = {\n",
    "            \"[]\": [],\n",
    "            \"[a]\": [1],\n",
    "            \"[][]\": [1, 2],\n",
    "            \"[]]]\": [1],\n",
    "            \"[[[]\": [1, 2],\n",
    "            \"[[[][]]]\": [1, 2, 5],\n",
    "            \"][\": [],\n",
    "            \"][][\": [],\n",
    "            \"[!]\": [],\n",
    "            \"[!c]\": [1, 2],\n",
    "            \"[!\": []\n",
    "            }\n",
    "        for pattern, bracketed_positions in pattern_positions_dict.items():\n",
    "            for pos in range(len(pattern)):\n",
    "                if pos in bracketed_positions:\n",
    "                    self.assertTrue(_position_is_bracketed(pattern, pos))\n",
    "                else:\n",
    "                    self.assertFalse(_position_is_bracketed(pattern, pos))\n",
    "\n",
    "    def test_choices(self):\n",
    "        # pattern: [choices]\n",
    "        pattern_choices_dict = {\n",
    "            \"\": [\"\"],\n",
    "            \"a\": [\"a\"],\n",
    "            \"a|b\": [\"a\", \"b\"],\n",
    "            \"a|b|c\": [\"a\", \"b\", \"c\"],\n",
    "            \"a|b[|]c\": [\"a\", \"b[|]c\"],\n",
    "            \"a|[b|c]\": [\"a\", \"[b|c]\"],\n",
    "            \"a[|b|c]\": [\"a[|b|c]\"],\n",
    "            \"[a|b|c]\": [\"[a|b|c]\"],\n",
    "            \"[a]|[b]|[c]\": [\"[a]\", \"[b]\", \"[c]\"],\n",
    "            \"[[a]|[b]|[c]\": [\"[[a]\", \"[b]\", \"[c]\"]\n",
    "            }\n",
    "        for pattern, choices in pattern_choices_dict.items():\n",
    "            self.assertEqual(list(_iter_choices(pattern)), choices)\n",
    "\n",
    "    def test_alternatives(self):\n",
    "        # pattern: [alternatives]\n",
    "        pattern_alternatives_dict = {\n",
    "            \"\": [\"\"],\n",
    "            \"(ab)\": [\"ab\"],\n",
    "            \"a|b\": [\"a|b\"],\n",
    "            \"()\": [\"\"],\n",
    "            \"(|)\": [\"\"],\n",
    "            \"(a|b)\": [\"a\", \"b\"],\n",
    "            \"(a|b|c)\": [\"a\", \"b\", \"c\"],\n",
    "            \"a(b|c)\": [\"ab\", \"ac\"],\n",
    "            \"(a|b)(c|d)\": [\"ac\", \"ad\", \"bc\", \"bd\"],\n",
    "            \"(a|b(c|d)\": [\"(a|bc\", \"(a|bd\"],\n",
    "            \"(a[|]b)\": [\"a[|]b\"],\n",
    "            \"[(]a|b)\": [\"[(]a|b)\"],\n",
    "            }\n",
    "        for pattern, alternatives in pattern_alternatives_dict.items():\n",
    "            self.assertEqual(sorted(list(_iter_alternatives(pattern))),\n",
    "                             sorted(alternatives))\n",
    "\n",
    "\n",
    "class GlobEscapeTest(unittest.TestCase):\n",
    "\n",
    "    def test_glob_escape(self):\n",
    "        input_strings = [\n",
    "            \"test\",\n",
    "            \"test[\",\n",
    "            \"test []\",\n",
    "            \"test [[]\",\n",
    "            \"test ]] str [\",\n",
    "            \"test[][]\",\n",
    "            \"test(\",\n",
    "            \"test)\",\n",
    "            \"test()\",\n",
    "            \"test (1)\"]\n",
    "        output_strings = [\n",
    "            \"test\",\n",
    "            \"test[[]\",\n",
    "            \"test [[][]]\",\n",
    "            \"test [[][[][]]\",\n",
    "            \"test []][]] str [[]\",\n",
    "            \"test[[][]][[][]]\",\n",
    "            \"test[(]\",\n",
    "            \"test[)]\",\n",
    "            \"test[(][)]\",\n",
    "            \"test [(]1[)]\"]\n",
    "        for unescaped_str, escaped_str in zip(input_strings, output_strings):\n",
    "            self.assertEqual(glob_escape(unescaped_str), escaped_str)\n",
    "\n",
    "\n",
    "class FnmatchTest(unittest.TestCase):\n",
    "\n",
    "    def _test_fnmatch(self, pattern, matches, non_matches):\n",
    "        for match in matches:\n",
    "            self.assertTrue(fnmatch(match, pattern))\n",
    "        for non_match in non_matches:\n",
    "            self.assertFalse(fnmatch(non_match, pattern))\n",
    "\n",
    "    def test_circumflex_in_set(self):\n",
    "        pattern = \"[^abc]\"\n",
    "        matches = [\"^\", \"a\", \"b\", \"c\"]\n",
    "        non_matches = [\"d\", \"e\", \"f\", \"g\"]\n",
    "        self._test_fnmatch(pattern, matches, non_matches)\n",
    "\n",
    "    def test_negative_set(self):\n",
    "        pattern = \"[!ab]\"\n",
    "        matches = [\"c\", \"d\"]\n",
    "        non_matches = [\"a\", \"b\"]\n",
    "        self._test_fnmatch(pattern, matches, non_matches)\n",
    "\n",
    "    def test_escaped_bracket(self):\n",
    "        pattern = \"[]ab]\"\n",
    "        matches = [\"]\", \"a\", \"b\"]\n",
    "        non_matches = [\"[]ab]\", \"ab]\"]\n",
    "        self._test_fnmatch(pattern, matches, non_matches)\n",
    "\n",
    "    def test_empty_set(self):\n",
    "        pattern = \"a[]b\"\n",
    "        matches = [\"a[]b\"]\n",
    "        non_matches = [\"a\", \"b\", \"[\", \"]\", \"ab\"]\n",
    "        self._test_fnmatch(pattern, matches, non_matches)\n",
    "\n",
    "    def test_home_dir(self):\n",
    "        pattern = os.path.join(\"~\", \"a\", \"b\")\n",
    "        matches = [os.path.expanduser(os.path.join(\"~\", \"a\", \"b\"))]\n",
    "        non_matches = [os.path.join(\"~\", \"a\", \"b\")]\n",
    "        self._test_fnmatch(pattern, matches, non_matches)\n",
    "\n",
    "    def test_alternatives(self):\n",
    "        pattern = \"(a|b)\"\n",
    "        matches = [\"a\", \"b\"]\n",
    "        non_matches = [\"(a|b)\", \"a|b\"]\n",
    "        self._test_fnmatch(pattern, matches, non_matches)\n",
    "\n",
    "    def test_set_precedence(self):\n",
    "        pattern = \"(a|[b)]\"\n",
    "        matches = [\"(a|b\", \"(a|)\"]\n",
    "        non_matches = [\"a]\", \"[b]\"]\n",
    "        self._test_fnmatch(pattern, matches, non_matches)\n",
    "\n",
    "    def test_questionmark(self):\n",
    "        pattern = \"a?b\"\n",
    "        matches = [\"axb\", \"ayb\"]\n",
    "        non_matches = [\"ab\", \"aXXb\"]\n",
    "        self._test_fnmatch(pattern, matches, non_matches)\n",
    "\n",
    "    def test_asterisk(self):\n",
    "        pattern = \"a*b\"\n",
    "        matches = [\"axb\", \"ayb\"]\n",
    "        non_matches = [\"aXbX\", os.path.join(\"a\", \"b\")]\n",
    "        self._test_fnmatch(pattern, matches, non_matches)\n",
    "\n",
    "    def test_double_asterisk(self):\n",
    "        pattern = \"a**b\"\n",
    "        matches = [\"axb\", \"ayb\", os.path.join(\"a\", \"b\")]\n",
    "        non_matches = [\"aXbX\"]\n",
    "        self._test_fnmatch(pattern, matches, non_matches)\n",
    "\n",
    "    def test_multiple_patterns(self):\n",
    "        pattern = [\"a**b\", \"a**c\"]\n",
    "        matches = [\"axb\", \"axc\"]\n",
    "        non_matches = [\"aXbX\", \"aXcX\"]\n",
    "        self._test_fnmatch(pattern, matches, non_matches)\n",
    "\n",
    "        pattern = []\n",
    "        matches = [\"anything\", \"anything_else\"]\n",
    "        non_matches = []\n",
    "        self._test_fnmatch(pattern, matches, non_matches)\n",
    "\n",
    "\n",
    "class GlobTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.maxDiff = None\n",
    "\n",
    "    def _test_glob(self, pattern, file_list):\n",
    "        results = sorted([os.path.normcase(g) for g in glob(pattern)])\n",
    "        file_list = sorted([os.path.normcase(f) for f in file_list])\n",
    "        self.assertEqual([i for i in results\n",
    "                          if re.search(r\"(__pycache__|\\.pyc)\", i) is None],\n",
    "                         file_list)\n",
    "\n",
    "    def test_collect_files(self):\n",
    "        pattern = os.path.join(TestFiles.glob_test_dir, 'Sub*', 'File1?.py')\n",
    "        file_list = [TestFiles.file11, TestFiles.file12]\n",
    "        self._test_glob(pattern, file_list)\n",
    "\n",
    "    def test_collect_dirs(self):\n",
    "        pattern = os.path.join(TestFiles.glob_test_dir, 'Sub*' + os.sep)\n",
    "        file_list = [TestFiles.dir1+os.sep, TestFiles.dir2+os.sep]\n",
    "        self._test_glob(pattern, file_list)\n",
    "\n",
    "    def test_collect_specific_dir(self):\n",
    "        pattern = os.path.join(TestFiles.dir1 + os.sep)\n",
    "        file_list = [TestFiles.dir1+os.sep]\n",
    "        self._test_glob(pattern, file_list)\n",
    "\n",
    "    def test_collect_flat(self):\n",
    "        pattern = os.path.join(TestFiles.glob_test_dir, '*')\n",
    "        file_list = [TestFiles.dir1,\n",
    "                     TestFiles.dir2,\n",
    "                     TestFiles.file1,\n",
    "                     TestFiles.file2,\n",
    "                     TestFiles.file3]\n",
    "        self._test_glob(pattern, file_list)\n",
    "\n",
    "    def test_collect_all(self):\n",
    "        pattern = os.path.join(TestFiles.glob_test_dir, '**', '*')\n",
    "        file_list = [TestFiles.dir1,\n",
    "                     TestFiles.dir2,\n",
    "                     TestFiles.file1,\n",
    "                     TestFiles.file2,\n",
    "                     TestFiles.file3,\n",
    "                     TestFiles.file11,\n",
    "                     TestFiles.file12,\n",
    "                     TestFiles.file_paren,\n",
    "                     TestFiles.file_brack]\n",
    "        self._test_glob(pattern, file_list)\n",
    "\n",
    "    def test_collect_basename(self):\n",
    "        pattern = TestFiles.glob_test_dir\n",
    "        file_list = [TestFiles.glob_test_dir]\n",
    "        self._test_glob(pattern, file_list)\n",
    "\n",
    "    def test_collect_none(self):\n",
    "        pattern = ''\n",
    "        file_list = []\n",
    "        self._test_glob(pattern, file_list)\n",
    "\n",
    "    def test_collect_specific(self):\n",
    "        pattern = os.path.join(TestFiles.file12)\n",
    "        file_list = [TestFiles.file12]\n",
    "        self._test_glob(pattern, file_list)\n",
    "\n",
    "    def test_collect_parentheses(self):\n",
    "        pattern = os.path.join(TestFiles.glob_test_dir,\n",
    "                               'SubDir[12]',\n",
    "                               'File[(]with)parentheses.txt')\n",
    "        file_list = [TestFiles.file_paren]\n",
    "        self._test_glob(pattern, file_list)\n",
    "\n",
    "    def test_collect_brackets(self):\n",
    "        pattern = os.path.join(TestFiles.glob_test_dir,\n",
    "                               'SubDir[12]',\n",
    "                               'File[[]with[]]brackets.txt')\n",
    "        file_list = [TestFiles.file_brack]\n",
    "        self._test_glob(pattern, file_list)\n",
    "\n",
    "    def test_collect_or(self):\n",
    "        pattern = os.path.join(TestFiles.glob_test_dir, \"File?.(x|y|z)\")\n",
    "        file_list = [TestFiles.file1, TestFiles.file2, TestFiles.file3]\n",
    "        self._test_glob(pattern, file_list)\n",
    "\n",
    "    def test_wildcard_dir(self):\n",
    "        pattern = os.path.join(TestFiles.glob_test_dir, \"SubDir?\", \"File11.py\")\n",
    "        file_list = [TestFiles.file11]\n",
    "        self._test_glob(pattern, file_list)\n",
    "\n",
    "    def test_collect_recursive(self):\n",
    "        pattern = os.path.join(TestFiles.glob_test_dir, \"**\", \"*\")\n",
    "        file_list = [TestFiles.file1,\n",
    "                     TestFiles.file2,\n",
    "                     TestFiles.file3,\n",
    "                     TestFiles.file11,\n",
    "                     TestFiles.file12,\n",
    "                     TestFiles.file_paren,\n",
    "                     TestFiles.file_brack,\n",
    "                     TestFiles.dir1,\n",
    "                     TestFiles.dir2]\n",
    "        self._test_glob(pattern, file_list)\n",
    "\n",
    "    def test_collect_invalid(self):\n",
    "        pattern = \"NOPE\"\n",
    "        file_list = []\n",
    "        self._test_glob(pattern, file_list)\n",
    "\n",
    "    def test_no_dirname_recursive(self):\n",
    "        old_curdir = os.curdir\n",
    "        os.curdir = TestFiles.glob_test_dir\n",
    "        pattern = '**'\n",
    "        file_list = [TestFiles.file1,\n",
    "                     TestFiles.file2,\n",
    "                     TestFiles.file3,\n",
    "                     TestFiles.file11,\n",
    "                     TestFiles.file12,\n",
    "                     TestFiles.file_paren,\n",
    "                     TestFiles.file_brack,\n",
    "                     TestFiles.dir1,\n",
    "                     TestFiles.dir2]\n",
    "        results = sorted([os.path.normcase(os.path.join(os.curdir, g))\n",
    "                          for g in glob(pattern)])\n",
    "        file_list = sorted([os.path.normcase(f) for f in file_list])\n",
    "        self.assertEqual([i for i in results\n",
    "                          if re.search(r\"(__pycache__|\\.pyc)\", i) is None],\n",
    "                         file_list)\n",
    "        os.curdir = old_curdir\n",
    "\n",
    "    def test_no_dirname(self):\n",
    "        old_curdir = os.curdir\n",
    "        os.curdir = TestFiles.glob_test_dir\n",
    "        pattern = '*Dir?'\n",
    "        file_list = [TestFiles.dir1,\n",
    "                     TestFiles.dir2]\n",
    "        results = sorted([os.path.normcase(os.path.join(os.curdir, g))\n",
    "                          for g in glob(pattern)])\n",
    "        file_list = sorted([os.path.normcase(f) for f in file_list])\n",
    "        self.assertEqual(results, file_list)\n",
    "        os.curdir = old_curdir\n"
  ],
  "/home/tushar/coala/tests/parsing/LineParserTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.parsing.LineParser import LineParser\n",
    "\n",
    "\n",
    "class LineParserTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.uut = LineParser(comment_seperators=('#', ';'))\n",
    "\n",
    "    def test_empty_line(self):\n",
    "        self.check_data_set(\"\")\n",
    "        self.check_data_set(\"\\n \\n \\n\")\n",
    "\n",
    "    def test_comment_parsing(self):\n",
    "        self.check_data_set(\"# comment only$\u00a7\\n\",\n",
    "                            output_comment=\"# comment only$\u00a7\")\n",
    "        self.check_data_set(\"   ; comment only  \\n\",\n",
    "                            output_comment=\"; comment only\")\n",
    "        self.check_data_set(\"   ; \\\\comment only  \\n\",\n",
    "                            output_comment=\"; comment only\")\n",
    "        self.check_data_set(\"#\", output_comment=\"#\")\n",
    "\n",
    "    def test_section_override(self):\n",
    "        self.check_data_set(r\"a.b, \\a\\.\\b\\ c=\",\n",
    "                            output_keys=[(\"a\", \"b\"), (\"\", r\"\\a.\\b c\")])\n",
    "\n",
    "    def test_multi_value_parsing(self):\n",
    "        self.check_data_set(\n",
    "            \"a, b\\\\ \\\\=, section.c= = :()&/ \\\\\\\\#heres a comment \\n\",\n",
    "            output_section='',\n",
    "            output_keys=[(\"\", 'a'), (\"\", 'b ='), (\"section\", 'c')],\n",
    "            output_value='= :()&/ \\\\\\\\',\n",
    "            output_comment='#heres a comment')\n",
    "\n",
    "    def test_multi_line_parsing(self):\n",
    "        self.check_data_set(\" a,b,d another value \",\n",
    "                            output_value=\"a,b,d another value\")\n",
    "        self.check_data_set(\" a,b,d\\\\= another value \",\n",
    "                            output_value=\"a,b,d\\\\= another value\")\n",
    "\n",
    "    def test_section_name_parsing(self):\n",
    "        self.check_data_set(\" [   a section name   ]      # with comment   \\n\",\n",
    "                            'a section name',\n",
    "                            output_comment=\"# with comment\")\n",
    "        self.check_data_set(\" [   a section name]   ]         \\n\",\n",
    "                            'a section name]')\n",
    "        self.check_data_set(\" [   a section name\\\\]   ]         \\n\",\n",
    "                            'a section name]')\n",
    "        self.check_data_set(\" [   a section name\\\\;   ]         \\n\",\n",
    "                            'a section name;')\n",
    "\n",
    "        self.uut.section_name_surroundings[\"Section:\"] = ''\n",
    "        self.check_data_set(\"[  sec]; thats a normal section\",\n",
    "                            output_section=\"sec\",\n",
    "                            output_comment=\"; thats a normal section\")\n",
    "        self.check_data_set(\"  Section:  sEc]\\\\\\\\; thats a new section\",\n",
    "                            output_section=\"sEc]\\\\\",\n",
    "                            output_comment=\"; thats a new section\")\n",
    "        self.check_data_set(\"  Section:  sec]\\\\\\\\\\\\\\\\; thats a new section\",\n",
    "                            output_section=\"sec]\\\\\\\\\",\n",
    "                            output_comment=\"; thats a new section\")\n",
    "        self.check_data_set(\"  Section:  sec]\\\\\\\\\\\\; thats a new section\",\n",
    "                            output_section=\"sec]\\\\; thats a new section\")\n",
    "\n",
    "    def check_data_set(self,\n",
    "                       line,\n",
    "                       output_section=\"\",\n",
    "                       output_keys=None,\n",
    "                       output_value='',\n",
    "                       output_comment=''):\n",
    "        output_keys = output_keys or []\n",
    "\n",
    "        section_name, keys, value, comment = self.uut.parse(line)\n",
    "\n",
    "        self.assertEqual(section_name, output_section)\n",
    "        self.assertEqual(keys, output_keys)\n",
    "        self.assertEqual(value, output_value)\n",
    "        self.assertEqual(comment, output_comment)\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/ConvertToRawTest.py": [
    "from coalib.parsing.StringProcessing import convert_to_raw\n",
    "from tests.parsing.StringProcessing.StringProcessingTestBase import (\n",
    "    StringProcessingTestBase)\n",
    "\n",
    "\n",
    "class ConvertToRawTest(StringProcessingTestBase):\n",
    "\n",
    "    def test_convert_to_raw(self):\n",
    "        # In (input, output) format\n",
    "        test_data = [\n",
    "            (r\"test\", r\"test\"),\n",
    "            (r\"test_path\", r\"test_path\"),\n",
    "            (r\"test, path\", r\"test, path\"),\n",
    "            (r\"test\\ path\", r\"test\\ path\"),\n",
    "            (r\"test\\path\", r\"test\\\\path\"),\n",
    "            (r\"test\\\\path\", r\"test\\\\path\"),\n",
    "            (r\"test\\=path\", r\"test\\=path\"),\n",
    "            (r\"test=path\", r\"test=path\"),\n",
    "            (r\"value\\=as\\something\", r\"value\\=as\\\\something\")]\n",
    "        for test in test_data:\n",
    "            self.assertEqual(convert_to_raw(test[0], \",.=# \"), test[1])\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/EscapeTest.py": [
    "from coalib.parsing.StringProcessing import escape\n",
    "from tests.parsing.StringProcessing.StringProcessingTestBase import (\n",
    "    StringProcessingTestBase)\n",
    "\n",
    "\n",
    "class EscapeTest(StringProcessingTestBase):\n",
    "    # Test escape() using a single character to escape and default parameters.\n",
    "\n",
    "    def test_normal_behaviour(self):\n",
    "        expected_results = [\n",
    "            r\"out1 \\'escaped-escape:        \\\\ \\' out2\",\n",
    "            r\"out1 \\'escaped-quote:         \\\\' \\' out2\",\n",
    "            r\"out1 \\'escaped-anything:      \\X \\' out2\",\n",
    "            r\"out1 \\'two escaped escapes: \\\\\\\\ \\' out2\",\n",
    "            r\"out1 \\'escaped-quote at end:   \\\\'\\' out2\",\n",
    "            r\"out1 \\'escaped-escape at end:  \\\\\\' out2\",\n",
    "            r\"out1           \\'str1\\' out2 \\'str2\\' out2\",\n",
    "            r\"out1 \\\\'        \\'str1\\' out2 \\'str2\\' out2\",\n",
    "            r\"out1 \\\\\\\\'      \\'str1\\' out2 \\'str2\\' out2\",\n",
    "            r\"out1 \\\\        \\'str1\\' out2 \\'str2\\' out2\",\n",
    "            r\"out1 \\\\\\\\      \\'str1\\' out2 \\'str2\\' out2\",\n",
    "            r\"out1         \\\\\\'str1\\' out2 \\'str2\\' out2\",\n",
    "            r\"out1       \\\\\\\\\\'str1\\' out2 \\'str2\\' out2\",\n",
    "            r\"out1           \\'str1\\'\\'str2\\'\\'str3\\' out2\",\n",
    "            r\"\",\n",
    "            r\"out1 out2 out3\",\n",
    "            self.bs,\n",
    "            2 * self.bs]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            escape,\n",
    "            {(test_string, \"'\"): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)})\n",
    "\n",
    "    # Tests escape() with more than one char to escape and an escape sequence\n",
    "    # that consists of more than one char.\n",
    "    def test_advanced(self):\n",
    "        expected_results = [\n",
    "            r\"out()1 'e()scaped-e()scape:        \\\\ ' out2\",\n",
    "            r\"out()1 'e()scaped-quote:         \\' ' out2\",\n",
    "            r\"out()1 'e()scaped-anything:      \\X ' out2\",\n",
    "            r\"out()1 'two e()scaped e()scape()s: \\\\\\\\ ' out2\",\n",
    "            r\"out()1 'e()scaped-quote at end:   \\'' out2\",\n",
    "            r\"out()1 'e()scaped-e()scape at end:  \\\\' out2\",\n",
    "            r\"out()1           '()str()1' out2 '()str2' out2\",\n",
    "            r\"out()1 \\'        '()str()1' out2 '()str2' out2\",\n",
    "            r\"out()1 \\\\\\'      '()str()1' out2 '()str2' out2\",\n",
    "            r\"out()1 \\\\        '()str()1' out2 '()str2' out2\",\n",
    "            r\"out()1 \\\\\\\\      '()str()1' out2 '()str2' out2\",\n",
    "            r\"out()1         \\\\'()str()1' out2 '()str2' out2\",\n",
    "            r\"out()1       \\\\\\\\'()str()1' out2 '()str2' out2\",\n",
    "            r\"out()1           '()str()1''()str2''()str()()3' out2\",\n",
    "            r\"\",\n",
    "            r\"out()1 out2 out()()3\",\n",
    "            self.bs,\n",
    "            2 * self.bs]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            escape,\n",
    "            {(test_string, \"1s33\", \"()\"): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)})\n",
    "\n",
    "    # Tests the realistic case when needing to escape spaces inside a shell\n",
    "    # with carets.\n",
    "    def test_windows_shell_space_escape(self):\n",
    "        expected_results = [\n",
    "            r\"out1^ 'escaped-escape:^ ^ ^ ^ ^ ^ ^ ^ \\\\^ '^ out2\",\n",
    "            r\"out1^ 'escaped-quote:^ ^ ^ ^ ^ ^ ^ ^ ^ \\'^ '^ out2\",\n",
    "            r\"out1^ 'escaped-anything:^ ^ ^ ^ ^ ^ \\X^ '^ out2\",\n",
    "            r\"out1^ 'two^ escaped^ escapes:^ \\\\\\\\^ '^ out2\",\n",
    "            r\"out1^ 'escaped-quote^ at^ end:^ ^ ^ \\''^ out2\",\n",
    "            r\"out1^ 'escaped-escape^ at^ end:^ ^ \\\\'^ out2\",\n",
    "            r\"out1^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 'str1'^ out2^ 'str2'^ out2\",\n",
    "            r\"out1^ \\'^ ^ ^ ^ ^ ^ ^ ^ 'str1'^ out2^ 'str2'^ out2\",\n",
    "            r\"out1^ \\\\\\'^ ^ ^ ^ ^ ^ 'str1'^ out2^ 'str2'^ out2\",\n",
    "            r\"out1^ \\\\^ ^ ^ ^ ^ ^ ^ ^ 'str1'^ out2^ 'str2'^ out2\",\n",
    "            r\"out1^ \\\\\\\\^ ^ ^ ^ ^ ^ 'str1'^ out2^ 'str2'^ out2\",\n",
    "            r\"out1^ ^ ^ ^ ^ ^ ^ ^ ^ \\\\'str1'^ out2^ 'str2'^ out2\",\n",
    "            r\"out1^ ^ ^ ^ ^ ^ ^ \\\\\\\\'str1'^ out2^ 'str2'^ out2\",\n",
    "            r\"out1^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 'str1''str2''str3'^ out2\",\n",
    "            r\"\",\n",
    "            r\"out1^ out2^ out3\",\n",
    "            self.bs,\n",
    "            2 * self.bs]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            escape,\n",
    "            {(test_string, \" \", \"^\"): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)})\n",
    "\n",
    "    # Tests using iterators instead of strings for the chars to escape. This\n",
    "    # allows to escape complete strings and not only chars.\n",
    "    def test_iterators_not_strings(self):\n",
    "        expected_results = [\n",
    "            r\"\\out1 'escaped-escape:        \\\\ ' out2\",\n",
    "            r\"\\out1 'escaped-quote:         \\' ' out2\",\n",
    "            r\"\\out1 'escaped-anything:      \\X ' out2\",\n",
    "            r\"\\out1 'two escaped escapes: \\\\\\\\ ' out2\",\n",
    "            r\"\\out1 'escaped-quote at end:   \\'' out2\",\n",
    "            r\"\\out1 'escaped-escape at end:  \\\\' out2\",\n",
    "            r\"\\out1           'str1' out2 '\\str2' out2\",\n",
    "            r\"\\out1 \\'        'str1' out2 '\\str2' out2\",\n",
    "            r\"\\out1 \\\\\\'      'str1' out2 '\\str2' out2\",\n",
    "            r\"\\out1 \\\\        'str1' out2 '\\str2' out2\",\n",
    "            r\"\\out1 \\\\\\\\      'str1' out2 '\\str2' out2\",\n",
    "            r\"\\out1         \\\\'str1' out2 '\\str2' out2\",\n",
    "            r\"\\out1       \\\\\\\\'str1' out2 '\\str2' out2\",\n",
    "            r\"\\out1           'str1''\\str2''str3' out2\",\n",
    "            r\"\",\n",
    "            r\"\\out1 out2 out3\",\n",
    "            self.bs,\n",
    "            2 * self.bs]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            escape,\n",
    "            {(test_string, (\"out1\", \"str2\")): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)})\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/InBetweenMatchTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.parsing.StringProcessing import InBetweenMatch, Match\n",
    "\n",
    "\n",
    "class InBetweenMatchTest(unittest.TestCase):\n",
    "\n",
    "    def test_invalid(self):\n",
    "        self.assertRaises(ValueError,\n",
    "                          InBetweenMatch,\n",
    "                          Match(\"a\", 10),\n",
    "                          Match(\"b\", -1),\n",
    "                          Match(\"c\", 12))\n",
    "\n",
    "        self.assertRaises(ValueError,\n",
    "                          InBetweenMatch.from_values,\n",
    "                          \"X\",\n",
    "                          1,\n",
    "                          \"QAD\",\n",
    "                          2,\n",
    "                          \"LK\",\n",
    "                          1)\n",
    "\n",
    "        self.assertRaises(ValueError,\n",
    "                          InBetweenMatch.from_values,\n",
    "                          \"1\",\n",
    "                          50,\n",
    "                          \"2\",\n",
    "                          22,\n",
    "                          \"3\",\n",
    "                          28)\n",
    "\n",
    "    def test_properties(self):\n",
    "        uut = InBetweenMatch(Match(\"ABC\", 0), Match(\"DEF\", 3), Match(\"GHI\", 6))\n",
    "\n",
    "        self.assertEqual(str(uut.begin), \"ABC\")\n",
    "        self.assertEqual(uut.begin.position, 0)\n",
    "        self.assertEqual(str(uut.inside), \"DEF\")\n",
    "        self.assertEqual(uut.inside.position, 3)\n",
    "        self.assertEqual(str(uut.end), \"GHI\")\n",
    "        self.assertEqual(uut.end.position, 6)\n",
    "\n",
    "    def test_from_values(self):\n",
    "        uut = InBetweenMatch.from_values(\"hello\", 47, \"world\", 77, \"rises\", 90)\n",
    "\n",
    "        self.assertEqual(str(uut.begin), \"hello\")\n",
    "        self.assertEqual(uut.begin.position, 47)\n",
    "        self.assertEqual(str(uut.inside), \"world\")\n",
    "        self.assertEqual(uut.inside.position, 77)\n",
    "        self.assertEqual(str(uut.end), \"rises\")\n",
    "        self.assertEqual(uut.end.position, 90)\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/LimitTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.parsing.StringProcessing.Filters import limit\n",
    "\n",
    "\n",
    "class LimitTest(unittest.TestCase):\n",
    "    sequence = (1, 5, 19, 22, -3, 18, 99, 500, 2015)\n",
    "\n",
    "    def test_finite(self):\n",
    "        for test_limit in (1, 2, 3, 7, 8, 10, 22, 500000):\n",
    "            self.assertEqual(tuple(limit(self.sequence, test_limit)),\n",
    "                             self.sequence[0:test_limit])\n",
    "\n",
    "    def test_infinite(self):\n",
    "        for test_limit in (0, -1, -2, -6555123):\n",
    "            self.assertEqual(tuple(limit(self.sequence, test_limit)),\n",
    "                             self.sequence)\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/MatchTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.parsing.StringProcessing import Match\n",
    "\n",
    "\n",
    "class MatchTest(unittest.TestCase):\n",
    "\n",
    "    def test_properties(self):\n",
    "        uut = Match(\"ABC\", 0)\n",
    "\n",
    "        self.assertEqual(uut.match, \"ABC\")\n",
    "        self.assertEqual(str(uut), \"ABC\")\n",
    "        self.assertEqual(uut.position, 0)\n",
    "        self.assertEqual(uut.end_position, 3)\n",
    "        self.assertEqual(uut.range, (0, 3))\n",
    "        self.assertEqual(len(uut), 3)\n",
    "\n",
    "    def test_properties2(self):\n",
    "        uut = Match(\"alea iacta est\", 48)\n",
    "\n",
    "        self.assertEqual(uut.match, \"alea iacta est\")\n",
    "        self.assertEqual(str(uut), \"alea iacta est\")\n",
    "        self.assertEqual(uut.position, 48)\n",
    "        self.assertEqual(uut.end_position, 62)\n",
    "        self.assertEqual(uut.range, (48, 62))\n",
    "        self.assertEqual(len(uut), 14)\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/NestedSearchInBetweenTest.py": [
    "from coalib.parsing.StringProcessing import (\n",
    "    InBetweenMatch, nested_search_in_between)\n",
    "from tests.parsing.StringProcessing.StringProcessingTestBase import (\n",
    "    StringProcessingTestBase)\n",
    "\n",
    "\n",
    "class NestedSearchInBetweenTest(StringProcessingTestBase):\n",
    "    bs = StringProcessingTestBase.bs\n",
    "\n",
    "    test_basic_expected_results = [\n",
    "        [(\"(\", 0, \"\", 1, \")\", 1),\n",
    "         (\"(\", 6, \"This is a word\", 7, \")\", 21),\n",
    "         (\"(\", 25, \"(in a word) another \", 26, \")\", 46)],\n",
    "        [(\"(\", 4, \"((((((((((((((((((1)2)3))))))))))))))))\", 5, \")\", 44)],\n",
    "        [(\"(\", 6, \"do (it ) more \", 7, \")\", 21),\n",
    "         (\"(\", 41, \"\", 42, \")\", 42),\n",
    "         (\"(\", 44, \"hello.\", 45, \")\", 51)],\n",
    "        [(\"(\", 0, \"\", 1, \")\", 1),\n",
    "         (\"(\", 8, r\"This\\ is a word\" + bs, 9, \")\", 25),\n",
    "         (\"(\", 29, r\"(in a\\\\\\ word\\\\\\\\\\) another \" + bs, 30, \")\", 59)],\n",
    "        [(\"(\", 5,\n",
    "          r\"\\(\\((((((\\\\\\(((((((((((1)2)3))\\\\\\\\\\)))))))))))))\\)\" + bs, 6,\n",
    "          \")\", 57)],\n",
    "        [(\"(\", 7, \"do (it ) more \", 8, \")\", 22),\n",
    "         (\"(\", 45, \"\", 46, \")\", 46),\n",
    "         (\"(\", 48, \"hello.\", 49, \")\", 55)]]\n",
    "\n",
    "    # Test the basic functionality of nested_search_in_between().\n",
    "    def test_basic(self):\n",
    "        self.assertResultsEqual(\n",
    "            nested_search_in_between,\n",
    "            {(self.search_in_between_begin_pattern,\n",
    "              self.search_in_between_end_pattern,\n",
    "              test_string,\n",
    "              0,\n",
    "              False,\n",
    "              False): [InBetweenMatch.from_values(*args)\n",
    "                       for args in result]\n",
    "             for test_string, result in zip(\n",
    "                 self.search_in_between_test_strings,\n",
    "                 self.test_basic_expected_results)},\n",
    "            list)\n",
    "\n",
    "    # Test nested_search_in_between() when feeding it with the same begin- and\n",
    "    # end-sequences.\n",
    "    def test_same_pattern(self):\n",
    "        self.assertResultsEqual(\n",
    "            nested_search_in_between,\n",
    "            {(pattern, pattern, test_string, 0, False, False): []\n",
    "             for test_string in self.search_in_between_test_strings\n",
    "             for pattern in [self.search_in_between_begin_pattern,\n",
    "                             self.search_in_between_end_pattern]},\n",
    "            list)\n",
    "\n",
    "    # Test nested_search_in_between() for its max_match parameter.\n",
    "    def test_max_match(self):\n",
    "        self.assertResultsEqual(\n",
    "            nested_search_in_between,\n",
    "            {(self.search_in_between_begin_pattern,\n",
    "              self.search_in_between_end_pattern,\n",
    "              test_string,\n",
    "              max_match,\n",
    "              False,\n",
    "              False): [InBetweenMatch.from_values(*args)\n",
    "                       for args in result]\n",
    "             for max_match in [1, 2, 5, 22]\n",
    "             for test_string, result in zip(\n",
    "                 self.search_in_between_test_strings,\n",
    "                 [elem[0:max_match]\n",
    "                     for elem in self.test_basic_expected_results])},\n",
    "            list)\n",
    "\n",
    "    # Test nested_search_in_between() with a regex pattern.\n",
    "    def test_regex_pattern(self):\n",
    "        self.assertResultsEqual(\n",
    "            nested_search_in_between,\n",
    "            {(r\"(?:)\\(\", r\"\\)(?:)\", test_string, 0, False, True):\n",
    "             [InBetweenMatch.from_values(*args) for args in result]\n",
    "             for test_string, result in zip(\n",
    "                 self.search_in_between_test_strings,\n",
    "                 self.test_basic_expected_results)},\n",
    "            list)\n",
    "\n",
    "    # Test nested_search_in_between() for its auto_trim feature.\n",
    "    def test_auto_trim(self):\n",
    "        expected_results = [\n",
    "            [(\"(\", 6, \"This is a word\", 7, \")\", 21),\n",
    "             (\"(\", 25, \"(in a word) another \", 26, \")\", 46)],\n",
    "            [(\"(\", 4, \"((((((((((((((((((1)2)3))))))))))))))))\", 5, \")\", 44)],\n",
    "            [(\"(\", 6, \"do (it ) more \", 7, \")\", 21),\n",
    "             (\"(\", 44, \"hello.\", 45, \")\", 51)],\n",
    "            [(\"(\", 8, r\"This\\ is a word\" + self.bs, 9, \")\", 25),\n",
    "             (\"(\", 29,\n",
    "              r\"(in a\\\\\\ word\\\\\\\\\\) another \" + self.bs, 30,\n",
    "              \")\", 59)],\n",
    "            [(\"(\",\n",
    "              5,\n",
    "              r\"\\(\\((((((\\\\\\(((((((((((1)2)3))\\\\\\\\\\)))))))))))))\\)\" + self.bs,\n",
    "              6,\n",
    "              \")\",\n",
    "              57)],\n",
    "            [(\"(\", 7, \"do (it ) more \", 8, \")\", 22),\n",
    "             (\"(\", 48, \"hello.\", 49, \")\", 55)]]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            nested_search_in_between,\n",
    "            {(begin_pattern,\n",
    "              end_pattern,\n",
    "              test_string,\n",
    "              0,\n",
    "              True,\n",
    "              use_regex): [InBetweenMatch.from_values(*args)\n",
    "                           for args in result]\n",
    "             for test_string, result in zip(\n",
    "                 self.search_in_between_test_strings,\n",
    "                 expected_results)\n",
    "             for use_regex, begin_pattern, end_pattern in [\n",
    "                 (True, r\"\\(\", r\"\\)\"),\n",
    "                 (False,\n",
    "                  self.search_in_between_begin_pattern,\n",
    "                  self.search_in_between_end_pattern)]},\n",
    "            list)\n",
    "\n",
    "    # Test for special cases that exposed bugs earlier.\n",
    "    def test_special(self):\n",
    "        self.assertResultsEqual(\n",
    "            nested_search_in_between,\n",
    "            {(\"(\", \")\", \"a)b(c\", 0, True, False): []},\n",
    "            list)\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/PositionIsEscapedTest.py": [
    "\n",
    "from coalib.parsing.StringProcessing import position_is_escaped\n",
    "from tests.parsing.StringProcessing.StringProcessingTestBase import (\n",
    "    StringProcessingTestBase)\n",
    "\n",
    "\n",
    "class PositionIsEscapedTest(StringProcessingTestBase):\n",
    "    # Test the position_is_escaped() function.\n",
    "\n",
    "    def test_basic(self):\n",
    "        expected_results = [\n",
    "            30 * [False] + [True] + 7 * [False],\n",
    "            30 * [False] + [True] + 7 * [False],\n",
    "            30 * [False] + [True] + 7 * [False],\n",
    "            28 * [False] + [True, False, True] + 7 * [False],\n",
    "            31 * [False] + [True] + 6 * [False],\n",
    "            31 * [False] + [True] + 6 * [False],\n",
    "            38 * [False],\n",
    "            6 * [False] + [True] + 31 * [False],\n",
    "            6 * [False] + [True, False, True] + 29 * [False],\n",
    "            6 * [False] + [True] + 31 * [False],\n",
    "            6 * [False] + [True, False, True] + 29 * [False],\n",
    "            14 * [False] + [True] + 23 * [False],\n",
    "            12 * [False] + [True, False, True] + 23 * [False],\n",
    "            38 * [False],\n",
    "            [],\n",
    "            14 * [False],\n",
    "            [False],\n",
    "            [False, True]]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            position_is_escaped,\n",
    "            {(test_string, position): result\n",
    "             for test_string, string_result in zip(self.test_strings,\n",
    "                                                   expected_results)\n",
    "             for position, result in zip(range(len(test_string)),\n",
    "                                         string_result)})\n",
    "\n",
    "    # Test position_is_escaped() with a more special test string.\n",
    "    def test_extended(self):\n",
    "        test_string = r\"\\\\\\\\\\abcabccba###\\\\13q4ujsabbc\\+'**'ac###.#.####-ba\"\n",
    "        result_dict = {\n",
    "            0: False,\n",
    "            1: True,\n",
    "            2: False,\n",
    "            3: True,\n",
    "            4: False,\n",
    "            5: True,\n",
    "            6: False,\n",
    "            7: False,\n",
    "            17: False,\n",
    "            18: True,\n",
    "            19: False,\n",
    "            30: False,\n",
    "            31: True,\n",
    "            50: False,\n",
    "            51: False,\n",
    "            6666666: False,\n",
    "            -1: False,\n",
    "            -20: True,\n",
    "            -21: False}\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            position_is_escaped,\n",
    "            {(test_string, position): result\n",
    "             for position, result in result_dict.items()})\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/SearchForTest.py": [
    "\n",
    "from coalib.parsing.StringProcessing import search_for\n",
    "from tests.parsing.StringProcessing.StringProcessingTestBase import (\n",
    "    StringProcessingTestBase)\n",
    "\n",
    "\n",
    "class SearchForTest(StringProcessingTestBase):\n",
    "    # Match either \"out1\" or \"out2\".\n",
    "    test_basic_pattern = \"out1|out2\"\n",
    "    # These are the expected results for the zero-group of the\n",
    "    # returned MatchObject's.\n",
    "    test_basic_expected_results = [\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [],\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [],\n",
    "        []]\n",
    "\n",
    "    @staticmethod\n",
    "    def list_zero_group(it):\n",
    "        \"\"\"\n",
    "        Collects all MatchObject elements from the given iterator and extracts\n",
    "        their first matching group (group 0).\n",
    "\n",
    "        :param it: The input iterator where to collect from.\n",
    "        \"\"\"\n",
    "        return [elem.group(0) for elem in it]\n",
    "\n",
    "    # Test the search_for() function.\n",
    "    def test_basic(self):\n",
    "        expected_results = self.test_basic_expected_results\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            search_for,\n",
    "            {(self.test_basic_pattern, test_string, 0, 0, True): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)},\n",
    "            self.list_zero_group)\n",
    "\n",
    "    # Test search_for() with a simple pattern.\n",
    "    def test_simple_pattern(self):\n",
    "        expected_results = [\n",
    "            i * [r\"'\"] for i in\n",
    "                [2, 3, 2, 2, 3, 2, 4, 5, 5, 4, 4, 4, 4, 6, 0, 0, 0, 0]]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            search_for,\n",
    "            {(r\"'\", test_string, 0, 0, use_regex): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)\n",
    "             for use_regex in [True, False]},\n",
    "            self.list_zero_group)\n",
    "\n",
    "    # Test search_for() with an empty pattern.\n",
    "    def test_empty_pattern(self):\n",
    "        expected_results = [\n",
    "            (len(elem) + 1) * [r\"\"] for elem in self.test_strings]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            search_for,\n",
    "            {(r\"\", test_string, 0, 0, use_regex): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)\n",
    "             for use_regex in [True, False]},\n",
    "            self.list_zero_group)\n",
    "\n",
    "    # Test search_for() for its max_match parameter.\n",
    "    def test_max_match(self):\n",
    "        search_pattern = self.test_basic_pattern\n",
    "        expected_master_results = self.test_basic_expected_results\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            search_for,\n",
    "            {(search_pattern, test_string, 0, max_match, True): result\n",
    "             for max_match in [1, 2, 3, 4, 5, 6, 987, 100928321]\n",
    "             for test_string, result in zip(\n",
    "                 self.test_strings,\n",
    "                 [elem[0: max_match] for elem in expected_master_results])},\n",
    "            self.list_zero_group)\n",
    "\n",
    "    # Test search_for() with regexes disabled.\n",
    "    def test_disabled_regex(self):\n",
    "        search_pattern = r\"\\'\"\n",
    "        expected_results = [\n",
    "            [],\n",
    "            [search_pattern],\n",
    "            [],\n",
    "            [],\n",
    "            [search_pattern],\n",
    "            [search_pattern],\n",
    "            [],\n",
    "            [search_pattern],\n",
    "            [search_pattern],\n",
    "            [],\n",
    "            [],\n",
    "            [search_pattern],\n",
    "            [search_pattern],\n",
    "            [],\n",
    "            [],\n",
    "            [],\n",
    "            [],\n",
    "            []]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            search_for,\n",
    "            {(search_pattern, test_string, 0, 0, False): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)},\n",
    "            self.list_zero_group)\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/SearchInBetweenTest.py": [
    "\n",
    "from coalib.parsing.StringProcessing import InBetweenMatch, search_in_between\n",
    "from tests.parsing.StringProcessing.StringProcessingTestBase import (\n",
    "    StringProcessingTestBase)\n",
    "\n",
    "\n",
    "class SearchInBetweenTest(StringProcessingTestBase):\n",
    "    bs = StringProcessingTestBase.bs\n",
    "\n",
    "    test_basic_pattern = \"'\"\n",
    "    test_basic_expected_results = [\n",
    "        [(test_basic_pattern, 5,\n",
    "          r\"escaped-escape:        \\\\ \", 6,\n",
    "          test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 5,\n",
    "          \"escaped-quote:         \" + bs, 6,\n",
    "          test_basic_pattern, 30)],\n",
    "        [(test_basic_pattern, 5,\n",
    "          r\"escaped-anything:      \\X \", 6,\n",
    "          test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 5,\n",
    "          r\"two escaped escapes: \\\\\\\\ \", 6,\n",
    "          test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 5,\n",
    "          \"escaped-quote at end:   \" + bs, 6,\n",
    "          test_basic_pattern, 31)],\n",
    "        [(test_basic_pattern, 5,\n",
    "          \"escaped-escape at end:  \" + 2 * bs, 6,\n",
    "          test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 15, \"str1\", 16, test_basic_pattern, 20),\n",
    "         (test_basic_pattern, 27, \"str2\", 28, test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 6, \"        \", 7, test_basic_pattern, 15),\n",
    "         (test_basic_pattern, 20, \" out2 \", 21, test_basic_pattern, 27)],\n",
    "        [(test_basic_pattern, 8, \"      \", 9, test_basic_pattern, 15),\n",
    "         (test_basic_pattern, 20, \" out2 \", 21, test_basic_pattern, 27)],\n",
    "        [(test_basic_pattern, 15, \"str1\", 16, test_basic_pattern, 20),\n",
    "         (test_basic_pattern, 27, \"str2\", 28, test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 15, \"str1\", 16, test_basic_pattern, 20),\n",
    "         (test_basic_pattern, 27, \"str2\", 28, test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 15, \"str1\", 16, test_basic_pattern, 20),\n",
    "         (test_basic_pattern, 27, \"str2\", 28, test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 15, \"str1\", 16, test_basic_pattern, 20),\n",
    "         (test_basic_pattern, 27, \"str2\", 28, test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 15, \"str1\", 16, test_basic_pattern, 20),\n",
    "         (test_basic_pattern, 21, \"str2\", 22, test_basic_pattern, 26),\n",
    "         (test_basic_pattern, 27, \"str3\", 28, test_basic_pattern, 32)],\n",
    "        [],\n",
    "        [],\n",
    "        [],\n",
    "        []]\n",
    "\n",
    "    # Test the basic search_in_between() functionality.\n",
    "    def test_basic(self):\n",
    "        expected_results = self.test_basic_expected_results\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            search_in_between,\n",
    "            {(self.test_basic_pattern,\n",
    "              self.test_basic_pattern,\n",
    "              test_string,\n",
    "              0,\n",
    "              False,\n",
    "              use_regex): [InBetweenMatch.from_values(*args)\n",
    "                           for args in result]\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)\n",
    "             for use_regex in [True, False]},\n",
    "            list)\n",
    "\n",
    "    # Test the search_in_between() while varying the max_match\n",
    "    # parameter.\n",
    "    def test_max_match(self):\n",
    "        search_pattern = self.test_basic_pattern\n",
    "        expected_master_results = self.test_basic_expected_results\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            search_in_between,\n",
    "            {(search_pattern,\n",
    "              search_pattern,\n",
    "              test_string,\n",
    "              max_match,\n",
    "              False,\n",
    "              use_regex): [InBetweenMatch.from_values(*args)\n",
    "                           for args in result]\n",
    "             for max_match in [1, 2, 3, 4, 5, 100]\n",
    "             for test_string, result in zip(\n",
    "                 self.test_strings,\n",
    "                 [elem[0: max_match] for elem in expected_master_results])\n",
    "             for use_regex in [True, False]},\n",
    "            list)\n",
    "\n",
    "    # Test the search_in_between() function with different regex\n",
    "    # patterns.\n",
    "    def test_regex_pattern(self):\n",
    "        expected_results = [\n",
    "            [(\"abc\", 0, \"\", 3, \"abc\", 3)],\n",
    "            [(\"ab\", 0, \"c\", 2, \"ab\", 3)],\n",
    "            [(\"ab\", 0, \"c\", 2, \"ab\", 3),\n",
    "             (\"ab\", 21, r\"bc\\+'**'\", 23, \"ac\", 31)],\n",
    "            [(self.bs, 12, \"\", 13, self.bs, 13)],\n",
    "            [(\"###\", 9, r\"\\\\13q4ujsabbc\\+'**'ac\", 12, \"###\", 33),\n",
    "             (\"#\", 37, \".\", 38, \"####\", 39)],\n",
    "            [(\"a\", 0, \"\", 1, \"b\", 1),\n",
    "             (\"a\", 3, \"\", 4, \"b\", 4),\n",
    "             (\"b\", 7, \"\", 8, \"a\", 8),\n",
    "             (\"##\", 9, \"\", 11, \"#\\\\\", 11),\n",
    "             (\"a\", 21, \"\", 22, \"b\", 22),\n",
    "             (\"b\", 23, r\"c\\+'**'\", 24, \"a\", 31),\n",
    "             (\"##\", 33, \"\", 35, \"#.\", 35),\n",
    "             (\"#.\", 37, \"\", 39, \"##\", 39),\n",
    "             (\"##\", 41, \"-\", 43, \"b\", 44)],\n",
    "            [(\"abcabc\", 0, r\"cba###\\\\13q4ujs\", 6, \"abbc\", 21)],\n",
    "            [(\"1\", 14, \"3q4ujsabbc\" + self.bs, 15, \"+\", 26)]]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            search_in_between,\n",
    "            {(pattern,\n",
    "              pattern,\n",
    "              self.multi_pattern_test_string,\n",
    "              0,\n",
    "              False,\n",
    "              True): [InBetweenMatch.from_values(*args)\n",
    "                      for args in result]\n",
    "             for pattern, result in zip(self.multi_patterns,\n",
    "                                        expected_results)},\n",
    "            list)\n",
    "\n",
    "    # Test the search_in_between() function for its\n",
    "    # remove_empty_matches feature.\n",
    "    def test_auto_trim(self):\n",
    "        expected_results = [\n",
    "            [],\n",
    "            [(\";\", 2, 5 * self.bs, 3, \";\", 8),\n",
    "             (\";\", 12, r\"\\\\\\'\", 13, \";\", 17),\n",
    "             (\";\", 18, self.bs, 19, \";\", 20),\n",
    "             (\";\", 25, \"+ios\", 26, \";\", 30)],\n",
    "            [(\";\", 1, \"2\", 2, \";\", 3),\n",
    "             (\";\", 5, \"4\", 6, \";\", 7),\n",
    "             (\";\", 9, \"6\", 10, \";\", 11)],\n",
    "            [(\";\", 1, \"2\", 2, \";\", 3),\n",
    "             (\";\", 5, \"4\", 6, \";\", 7),\n",
    "             (\";\", 9, \"6\", 10, \";\", 11)],\n",
    "            [],\n",
    "            [],\n",
    "            [],\n",
    "            [],\n",
    "            [(\";\", 3, \"a\", 4, \";\", 5)]]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            search_in_between,\n",
    "            {(self.auto_trim_test_pattern,\n",
    "              self.auto_trim_test_pattern,\n",
    "              test_string,\n",
    "              0,\n",
    "              True,\n",
    "              use_regex): [InBetweenMatch.from_values(*args)\n",
    "                           for args in result]\n",
    "             for test_string, result in zip(self.auto_trim_test_strings,\n",
    "                                            expected_results)\n",
    "             for use_regex in [True, False]},\n",
    "            list)\n",
    "\n",
    "    # Test the search_in_between() function for its use_regex parameter.\n",
    "    def test_disabled_regex(self):\n",
    "        search_pattern = r\"\\'\"\n",
    "        expected_results = [[] for x in range(len(self.test_strings))]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            search_in_between,\n",
    "            {(search_pattern,\n",
    "              search_pattern,\n",
    "              test_string,\n",
    "              0,\n",
    "              # For remove_empty_matches both works, True and False.\n",
    "              auto_trim,\n",
    "              False): [InBetweenMatch.from_values(*args)\n",
    "                       for args in result]\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)\n",
    "             for auto_trim in [True, False]},\n",
    "            list)\n",
    "\n",
    "    # Test the search_in_between() function using the test-strings specific\n",
    "    # for search-in-between functions.\n",
    "    def test_extended(self):\n",
    "        expected_results = [\n",
    "            [(\"(\", 0, \"\", 1, \")\", 1),\n",
    "             (\"(\", 6, \"This is a word\", 7, \")\", 21),\n",
    "             (\"(\", 25, \"(in a word\", 26, \")\", 36)],\n",
    "            [(\"(\", 4, \"((((((((((((((((((1\", 5, \")\", 24)],\n",
    "            [(\"(\", 6, \"do (it \", 7, \")\", 14),\n",
    "             (\"(\", 41, \"\", 42, \")\", 42),\n",
    "             (\"(\", 44, \"hello.\", 45, \")\", 51)],\n",
    "            [(\"(\", 0, \"\", 1, \")\", 1),\n",
    "             (\"(\", 8, r\"This\\ is a word\" + self.bs, 9, \")\", 25),\n",
    "             (\"(\", 29, r\"(in a\\\\\\ word\" + 5 * self.bs, 30, \")\", 48)],\n",
    "            [(\"(\", 5, r\"\\(\\((((((\\\\\\(((((((((((1\", 6, \")\", 30)],\n",
    "            [(\"(\", 7, \"do (it \", 8, \")\", 15),\n",
    "             (\"(\", 45, \"\", 46, \")\", 46),\n",
    "             (\"(\", 48, \"hello.\", 49, \")\", 55)]]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            search_in_between,\n",
    "            {(begin_pattern,\n",
    "              end_pattern,\n",
    "              test_string,\n",
    "              0,\n",
    "              False,\n",
    "              use_regex): [InBetweenMatch.from_values(*args)\n",
    "                           for args in result]\n",
    "             for test_string, result in zip(\n",
    "                 self.search_in_between_test_strings,\n",
    "                 expected_results)\n",
    "             for use_regex, begin_pattern, end_pattern in\n",
    "             [(True, r\"\\(\", r\"\\)\"),\n",
    "              (False,\n",
    "               self.search_in_between_begin_pattern,\n",
    "               self.search_in_between_end_pattern)]},\n",
    "            list)\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/SplitTest.py": [
    "\n",
    "from coalib.parsing.StringProcessing import split\n",
    "from tests.parsing.StringProcessing.StringProcessingTestBase import (\n",
    "    StringProcessingTestBase)\n",
    "\n",
    "\n",
    "class SplitTest(StringProcessingTestBase):\n",
    "    bs = StringProcessingTestBase.bs\n",
    "\n",
    "    test_basic_pattern = r\"'\"\n",
    "    test_basic_expected_results = [\n",
    "        [r\"out1 \", r\"escaped-escape:        \\\\ \", r\" out2\"],\n",
    "        [r\"out1 \", r\"escaped-quote:         \" + bs, r\" \", r\" out2\"],\n",
    "        [r\"out1 \", r\"escaped-anything:      \\X \", r\" out2\"],\n",
    "        [r\"out1 \", r\"two escaped escapes: \\\\\\\\ \", r\" out2\"],\n",
    "        [r\"out1 \", r\"escaped-quote at end:   \" + bs, r\"\", r\" out2\"],\n",
    "        [r\"out1 \", r\"escaped-escape at end:  \" + 2 * bs, r\" out2\"],\n",
    "        [r\"out1           \", r\"str1\", r\" out2 \", r\"str2\", r\" out2\"],\n",
    "        [r\"out1 \" + bs, r\"        \", r\"str1\", r\" out2 \", r\"str2\", r\" out2\"],\n",
    "        [r\"out1 \" + 3 * bs, r\"      \", r\"str1\", r\" out2 \", r\"str2\", r\" out2\"],\n",
    "        [r\"out1 \\\\        \", r\"str1\", r\" out2 \", r\"str2\", r\" out2\"],\n",
    "        [r\"out1 \\\\\\\\      \", r\"str1\", r\" out2 \", r\"str2\", r\" out2\"],\n",
    "        [r\"out1         \" + 2 * bs, r\"str1\", r\" out2 \", r\"str2\", r\" out2\"],\n",
    "        [r\"out1       \" + 4 * bs, r\"str1\", r\" out2 \", r\"str2\", r\" out2\"],\n",
    "        [r\"out1           \", r\"str1\", r\"\", r\"str2\", r\"\", r\"str3\", r\" out2\"],\n",
    "        [r\"\"],\n",
    "        [r\"out1 out2 out3\"],\n",
    "        [bs],\n",
    "        [2 * bs]]\n",
    "\n",
    "    # Test the basic split() functionality.\n",
    "    def test_basic(self):\n",
    "        split_pattern = self.test_basic_pattern\n",
    "        expected_results = self.test_basic_expected_results\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            split,\n",
    "            {(split_pattern, test_string, 0, False, use_regex): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)\n",
    "             for use_regex in [True, False]},\n",
    "            list)\n",
    "\n",
    "    # Test the split() function while varying the max_split parameter.\n",
    "    def test_max_split(self):\n",
    "        split_pattern = self.test_basic_pattern\n",
    "        expected_master_results = self.test_basic_expected_results\n",
    "\n",
    "        for max_split in [1, 2, 3, 4, 5, 6, 7, 8, 9, 112]:\n",
    "            expected_results = [\n",
    "                elem[0: max_split] for elem in expected_master_results]\n",
    "\n",
    "            for res, master in zip(expected_results, expected_master_results):\n",
    "                if max_split < len(master):\n",
    "                    # max_split is less the length of our master result list,\n",
    "                    # need to append the rest as a joined string.\n",
    "                    res.append(str.join(split_pattern, master[max_split:]))\n",
    "\n",
    "            self.assertResultsEqual(\n",
    "                split,\n",
    "                {(split_pattern,\n",
    "                  test_string,\n",
    "                  max_split,\n",
    "                  False,\n",
    "                  use_regex): result\n",
    "                 for test_string, result in zip(self.test_strings,\n",
    "                                                expected_results)\n",
    "                 for use_regex in [True, False]},\n",
    "                list)\n",
    "\n",
    "    # Test the split() function with different regex patterns.\n",
    "    def test_regex_pattern(self):\n",
    "        expected_results = [\n",
    "            [r\"\", r\"\", r\"cba###\\\\13q4ujsabbc\\+'**'ac###.#.####-ba\"],\n",
    "            [r\"\", r\"c\", r\"ccba###\\\\13q4ujs\", r\"bc\\+'**'ac###.#.####-ba\"],\n",
    "            [r\"\", r\"c\", r\"ccba###\\\\13q4ujs\", r\"bc\\+'**'\", r\"###.#.####-ba\"],\n",
    "            [r\"abcabccba###\", r\"\", r\"13q4ujsabbc\", r\"+'**'ac###.#.####-ba\"],\n",
    "            [r\"abcabccba\", r\"\\\\13q4ujsabbc\\+'**'ac\", r\".\", r\".\", r\"-ba\"],\n",
    "            [r\"\", r\"\", r\"c\", r\"\", r\"cc\", r\"\", r\"\", r\"\", r\"\\13q4ujs\", r\"\", r\"\",\n",
    "                r\"c\\+'**'\", r\"c\", r\"\", r\"\", r\"\", r\"\", r\"-\", r\"\", r\"\"],\n",
    "            [r\"\", r\"cba###\\\\13q4ujs\", r\"\\+'**'\", r\"###.#.####-ba\"],\n",
    "            [r\"abcabccba###\" + 2 * self.bs, r\"3q4ujsabbc\" + self.bs,\n",
    "                r\"'**'ac###.#.####-ba\"]]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            split,\n",
    "            {(pattern, self.multi_pattern_test_string, 0, False, True): result\n",
    "             for pattern, result in zip(self.multi_patterns,\n",
    "                                        expected_results)},\n",
    "            list)\n",
    "\n",
    "    # Test the split() function for its remove_empty_matches feature.\n",
    "    def test_auto_trim(self):\n",
    "        expected_results = [\n",
    "            [],\n",
    "            [2 * self.bs, 5 * self.bs, r\"\\\\#\", r\"\\\\\\'\", self.bs, 4 * self.bs,\n",
    "                r\"+ios\"],\n",
    "            [r\"1\", r\"2\", r\"3\", r\"4\", r\"5\", r\"6\"],\n",
    "            [r\"1\", r\"2\", r\"3\", r\"4\", r\"5\", r\"6\", r\"7\"],\n",
    "            [],\n",
    "            [r\"Hello world\"],\n",
    "            [self.bs],\n",
    "            [2 * self.bs],\n",
    "            [r\"abc\", r\"a\", r\"asc\"]]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            split,\n",
    "            {(self.auto_trim_test_pattern,\n",
    "              test_string,\n",
    "              0,\n",
    "              True,\n",
    "              use_regex): result\n",
    "             for test_string, result in zip(self.auto_trim_test_strings,\n",
    "                                            expected_results)\n",
    "             for use_regex in [True, False]},\n",
    "            list)\n",
    "\n",
    "    # Test the split() function with regexes disabled.\n",
    "    def test_disabled_regex(self):\n",
    "        expected_results = [\n",
    "            [r\"out1 'escaped-escape:        \\\\ ' out2\"],\n",
    "            [r\"out1 'escaped-quote:         \", r\" ' out2\"],\n",
    "            [r\"out1 'escaped-anything:      \\X ' out2\"],\n",
    "            [r\"out1 'two escaped escapes: \\\\\\\\ ' out2\"],\n",
    "            [r\"out1 'escaped-quote at end:   \", r\"' out2\"],\n",
    "            [r\"out1 'escaped-escape at end:  \" + self.bs, r\" out2\"],\n",
    "            [r\"out1           'str1' out2 'str2' out2\"],\n",
    "            [r\"out1 \", r\"        'str1' out2 'str2' out2\"],\n",
    "            [r\"out1 \\\\\", r\"      'str1' out2 'str2' out2\"],\n",
    "            [r\"out1 \\\\        'str1' out2 'str2' out2\"],\n",
    "            [r\"out1 \\\\\\\\      'str1' out2 'str2' out2\"],\n",
    "            [r\"out1         \" + self.bs, r\"str1' out2 'str2' out2\"],\n",
    "            [r\"out1       \" + 3 * self.bs, r\"str1' out2 'str2' out2\"],\n",
    "            [r\"out1           'str1''str2''str3' out2\"],\n",
    "            [r\"\"],\n",
    "            [r\"out1 out2 out3\"],\n",
    "            [self.bs],\n",
    "            [2 * self.bs]]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            split,\n",
    "            {(r\"\\'\", test_string, 0, False, False): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)},\n",
    "            list)\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/StringProcessingTestBase.py": [
    "import unittest\n",
    "\n",
    "\n",
    "class StringProcessingTestBase(unittest.TestCase):\n",
    "    # The backslash character. Needed since there are limitations when\n",
    "    # using backslashes at the end of raw-strings in front of the\n",
    "    # terminating \" or '.\n",
    "    bs = \"\\\\\"\n",
    "\n",
    "    # Basic test strings all StringProcessing functions should test.\n",
    "    test_strings = [\n",
    "        r\"out1 'escaped-escape:        \\\\ ' out2\",\n",
    "        r\"out1 'escaped-quote:         \\' ' out2\",\n",
    "        r\"out1 'escaped-anything:      \\X ' out2\",\n",
    "        r\"out1 'two escaped escapes: \\\\\\\\ ' out2\",\n",
    "        r\"out1 'escaped-quote at end:   \\'' out2\",\n",
    "        r\"out1 'escaped-escape at end:  \\\\' out2\",\n",
    "        r\"out1           'str1' out2 'str2' out2\",\n",
    "        r\"out1 \\'        'str1' out2 'str2' out2\",\n",
    "        r\"out1 \\\\\\'      'str1' out2 'str2' out2\",\n",
    "        r\"out1 \\\\        'str1' out2 'str2' out2\",\n",
    "        r\"out1 \\\\\\\\      'str1' out2 'str2' out2\",\n",
    "        r\"out1         \\\\'str1' out2 'str2' out2\",\n",
    "        r\"out1       \\\\\\\\'str1' out2 'str2' out2\",\n",
    "        r\"out1           'str1''str2''str3' out2\",\n",
    "        r\"\",\n",
    "        r\"out1 out2 out3\",\n",
    "        bs,\n",
    "        2 * bs]\n",
    "\n",
    "    # Test string for multi-pattern tests (since we want to variate the\n",
    "    # pattern, not the test string).\n",
    "    multi_pattern_test_string = (r\"abcabccba###\\\\13q4ujsabbc\\+'**'ac\"\n",
    "                                 r\"###.#.####-ba\")\n",
    "    # Multiple patterns for the multi-pattern tests.\n",
    "    multi_patterns = [r\"abc\",\n",
    "                      r\"ab\",\n",
    "                      r\"ab|ac\",\n",
    "                      2 * bs,\n",
    "                      r\"#+\",\n",
    "                      r\"(a)|(b)|(#.)\",\n",
    "                      r\"(?:a(b)*c)+\",\n",
    "                      r\"1|\\+\"]\n",
    "\n",
    "    # Test strings for the remove_empty_matches feature (alias auto-trim).\n",
    "    auto_trim_test_pattern = r\";\"\n",
    "    auto_trim_test_strings = [r\";;;;;;;;;;;;;;;;\",\n",
    "                              r\"\\\\;\\\\\\\\\\;\\\\#;\\\\\\';;\\;\\\\\\\\;+ios;;\",\n",
    "                              r\"1;2;3;4;5;6;\",\n",
    "                              r\"1;2;3;4;5;6;7\",\n",
    "                              r\"\",\n",
    "                              r\"Hello world\",\n",
    "                              r\"\\;\",\n",
    "                              r\"\\\\;\",\n",
    "                              r\"abc;a;;;;;asc\"]\n",
    "\n",
    "    # Test strings for search-in-between functions.\n",
    "    search_in_between_begin_pattern = r\"(\"\n",
    "    search_in_between_end_pattern = r\")\"\n",
    "    search_in_between_test_strings = [\n",
    "        r\"()assk(This is a word)and((in a word) another ) one anyway.\",\n",
    "        r\"bcc5(((((((((((((((((((1)2)3)))))))))))))))))\",\n",
    "        r\"Let's (do (it ) more ) complicated ) ) ) () (hello.)\",\n",
    "        r\"()assk\\\\(This\\ is a word\\)and((in a\\\\\\ word\\\\\\\\\\) another \\)) \"\n",
    "            r\"one anyway.\",\n",
    "        r\"bcc5\\(\\(\\((((((\\\\\\(((((((((((1)2)3))\\\\\\\\\\)))))))))))))\\)\\)\",\n",
    "        r\"Let's \\(do (it ) more ) \\\\ complicated ) ) ) () (hello.)\\\\z\"]\n",
    "\n",
    "    @staticmethod\n",
    "    def _construct_message(func, args, kwargs):\n",
    "        \"\"\"\n",
    "        Constructs the error message for the call result assertions.\n",
    "\n",
    "        :param func:   The function that was called.\n",
    "        :param args:   The argument tuple the function was invoked with.\n",
    "        :param kwargs: The named arguments dict the function was invoked with.\n",
    "        :param return: The error message.\n",
    "        \"\"\"\n",
    "        args = [repr(x) for x in args]\n",
    "        kwargs = [str(key) + '=' + repr(value)\n",
    "                  for key, value in kwargs.items()]\n",
    "\n",
    "        return \"Called {}({}).\".format(func.__name__, \", \".join(args + kwargs))\n",
    "\n",
    "    def assertResultsEqual(self,\n",
    "                           func,\n",
    "                           invocation_and_results,\n",
    "                           postprocess=lambda result: result):\n",
    "        \"\"\"\n",
    "        Tests each given invocation against the given results with the\n",
    "        specified function.\n",
    "\n",
    "        :param func:                   The function to test.\n",
    "        :param invocation_and_results: A dict containing the invocation tuple\n",
    "                                       as key and the result as value.\n",
    "        :param postprocess:            A function that shall process the\n",
    "                                       returned result from the tested\n",
    "                                       function. The function must accept only\n",
    "                                       one parameter as postprocessing input.\n",
    "                                       Performs no postprocessing by default.\n",
    "        \"\"\"\n",
    "        for args, result in invocation_and_results.items():\n",
    "            self.assertEqual(\n",
    "                postprocess(func(*args)),\n",
    "                result,\n",
    "                self._construct_message(func, args, {}))\n",
    "\n",
    "    def assertResultsEqualEx(self,\n",
    "                             func,\n",
    "                             invocation_and_results,\n",
    "                             postprocess=lambda result: result):\n",
    "        \"\"\"\n",
    "        Tests each given invocation against the given results with the\n",
    "        specified function. This is an extended version of\n",
    "        ``assertResultsEqual()`` that supports also ``**kwargs``.\n",
    "\n",
    "        :param func:                   The function to test.\n",
    "        :param invocation_and_results: A dict containing the invocation tuple\n",
    "                                       as key and the result as value. The\n",
    "                                       tuple contains (args, kwargs).\n",
    "        :param postprocess:            A function that shall process the\n",
    "                                       returned result from the tested\n",
    "                                       function. The function must accept only\n",
    "                                       one parameter as postprocessing input.\n",
    "                                       Performs no postprocessing by default.\n",
    "        \"\"\"\n",
    "        for (args, kwargs), result in invocation_and_results.items():\n",
    "            self.assertEqual(\n",
    "                postprocess(func(*args, **kwargs)),\n",
    "                result,\n",
    "                self._construct_message(func, args, kwargs))\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/TrimEmptyMatchesTest.py": [
    "import re\n",
    "import unittest\n",
    "\n",
    "from coalib.parsing.StringProcessing.Filters import trim_empty_matches\n",
    "\n",
    "\n",
    "class TrimEmptyMatchesTest(unittest.TestCase):\n",
    "    # Maps the given iterator of MatchObject's to their zero-group, so it can\n",
    "    # be compared and collects the results into a tuple.\n",
    "    comparable_map = lambda matches: tuple(map(lambda x: x.group(0), matches))\n",
    "\n",
    "    def test_single_group(self):\n",
    "        comparable_map = TrimEmptyMatchesTest.comparable_map\n",
    "\n",
    "        teststring = \"AHelloB   s A B ABAB do what you want.\"\n",
    "        regex = \"A(.*?)B\"\n",
    "\n",
    "        # Using the iterator itself would require to invoke re.finditer again\n",
    "        # and again before each assert.\n",
    "        real = tuple(re.finditer(regex, teststring))\n",
    "\n",
    "        # Ensure our regex is working like expected.\n",
    "        self.assertEqual(comparable_map(real),\n",
    "                         (\"AHelloB\", \"A B\", \"AB\", \"AB\"))\n",
    "\n",
    "        # Default mode checks for group 0.\n",
    "        self.assertEqual(comparable_map(trim_empty_matches(real)),\n",
    "                         (\"AHelloB\", \"A B\", \"AB\", \"AB\"))\n",
    "\n",
    "        self.assertEqual(comparable_map(trim_empty_matches(real, (1,))),\n",
    "                         (\"AHelloB\", \"A B\"))\n",
    "\n",
    "        self.assertEqual(comparable_map(trim_empty_matches(real, (0, 1))),\n",
    "                         (\"AHelloB\", \"A B\", \"AB\", \"AB\"))\n",
    "\n",
    "        self.assertEqual(comparable_map(trim_empty_matches(real, (1, 0))),\n",
    "                         (\"AHelloB\", \"A B\", \"AB\", \"AB\"))\n",
    "\n",
    "    def test_multi_group(self):\n",
    "        comparable_map = TrimEmptyMatchesTest.comparable_map\n",
    "\n",
    "        teststring = (\"A1B2C3D no match.'~ Awhat doByouCthink??D ABisCD ABCD\"\n",
    "                      \"AneverBCmindD  __ ABCXD ABC\")\n",
    "        regex = \"A(.*?)B(.*?)C(?P<cd>.*?)D\"\n",
    "\n",
    "        real = tuple(re.finditer(regex, teststring))\n",
    "\n",
    "        # Check again if our regex works.\n",
    "        self.assertEqual(comparable_map(real),\n",
    "                         (\"A1B2C3D\", \"Awhat doByouCthink??D\", \"ABisCD\", \"ABCD\",\n",
    "                          \"AneverBCmindD\", \"ABCXD\"))\n",
    "\n",
    "        self.assertEqual(comparable_map(trim_empty_matches(real)),\n",
    "                         (\"A1B2C3D\", \"Awhat doByouCthink??D\", \"ABisCD\", \"ABCD\",\n",
    "                          \"AneverBCmindD\", \"ABCXD\"))\n",
    "\n",
    "        self.assertEqual(comparable_map(trim_empty_matches(real, (1, 3))),\n",
    "                         (\"A1B2C3D\", \"Awhat doByouCthink??D\", \"AneverBCmindD\",\n",
    "                          \"ABCXD\"))\n",
    "\n",
    "        self.assertEqual(comparable_map(trim_empty_matches(real, (2,))),\n",
    "                         (\"A1B2C3D\", \"Awhat doByouCthink??D\", \"ABisCD\"))\n",
    "\n",
    "        self.assertEqual(comparable_map(trim_empty_matches(real, (\"cd\",))),\n",
    "                         (\"A1B2C3D\", \"Awhat doByouCthink??D\", \"AneverBCmindD\",\n",
    "                          \"ABCXD\"))\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/UnescapeTest.py": [
    "\n",
    "from coalib.parsing.StringProcessing import unescape\n",
    "from tests.parsing.StringProcessing.StringProcessingTestBase import (\n",
    "    StringProcessingTestBase)\n",
    "\n",
    "\n",
    "class UnescapeTest(StringProcessingTestBase):\n",
    "    # Test the unescape() function.\n",
    "\n",
    "    def test_basic(self):\n",
    "        expected_results = [\n",
    "            r\"out1 'escaped-escape:        \\ ' out2\",\n",
    "            r\"out1 'escaped-quote:         ' ' out2\",\n",
    "            r\"out1 'escaped-anything:      X ' out2\",\n",
    "            r\"out1 'two escaped escapes: \\\\ ' out2\",\n",
    "            r\"out1 'escaped-quote at end:   '' out2\",\n",
    "            r\"out1 'escaped-escape at end:  \\' out2\",\n",
    "            r\"out1           'str1' out2 'str2' out2\",\n",
    "            r\"out1 '        'str1' out2 'str2' out2\",\n",
    "            r\"out1 \\'      'str1' out2 'str2' out2\",\n",
    "            r\"out1 \\        'str1' out2 'str2' out2\",\n",
    "            r\"out1 \\\\      'str1' out2 'str2' out2\",\n",
    "            r\"out1         \\'str1' out2 'str2' out2\",\n",
    "            r\"out1       \\\\'str1' out2 'str2' out2\",\n",
    "            r\"out1           'str1''str2''str3' out2\",\n",
    "            r\"\",\n",
    "            r\"out1 out2 out3\",\n",
    "            r\"\",\n",
    "            self.bs]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescape,\n",
    "            {(test_string,): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)})\n",
    "\n",
    "    # Test unescape() with custom test strings that could uncover special\n",
    "    # flaws.\n",
    "    def test_extended(self):\n",
    "        self.assertEqual(unescape(\"hello\\\\\"), \"hello\")\n",
    "        self.assertEqual(unescape(\"te\\\\st\\\\\\\\\"), \"test\\\\\")\n",
    "        self.assertEqual(unescape(\"\\\\\\\\\\\\\"), \"\\\\\")\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/UnescapedSearchForTest.py": [
    "\n",
    "from coalib.parsing.StringProcessing import unescaped_search_for\n",
    "from tests.parsing.StringProcessing.StringProcessingTestBase import (\n",
    "    StringProcessingTestBase)\n",
    "\n",
    "\n",
    "class UnescapedSearchForTest(StringProcessingTestBase):\n",
    "    # Match either \"out1\" or \"out2\".\n",
    "    test_basic_pattern = \"out1|out2\"\n",
    "    # These are the expected results for the zero-group of the\n",
    "    # returned MatchObject's.\n",
    "    test_basic_expected_results = [\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\", r\"out2\"],\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [],\n",
    "        [r\"out1\", r\"out2\"],\n",
    "        [],\n",
    "        []]\n",
    "\n",
    "    @staticmethod\n",
    "    def list_zero_group(it):\n",
    "        \"\"\"\n",
    "        Collects all MatchObject elements from the given iterator and extracts\n",
    "        their first matching group (group 0).\n",
    "\n",
    "        :param it: The input iterator where to collect from.\n",
    "        \"\"\"\n",
    "        return [elem.group(0) for elem in it]\n",
    "\n",
    "    # Test the unescaped_search_for() function.\n",
    "    def test_basic(self):\n",
    "        expected_results = self.test_basic_expected_results\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_search_for,\n",
    "            {(self.test_basic_pattern, test_string, 0, 0, True): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)},\n",
    "            self.list_zero_group)\n",
    "\n",
    "    # Test unescaped_search_for() with a simple pattern.\n",
    "    def test_simple_pattern(self):\n",
    "        expected_results = [\n",
    "            2 * [r\"'\"],\n",
    "            2 * [r\"'\"],\n",
    "            2 * [r\"'\"],\n",
    "            2 * [r\"'\"],\n",
    "            2 * [r\"'\"],\n",
    "            2 * [r\"'\"],\n",
    "            4 * [r\"'\"],\n",
    "            4 * [r\"'\"],\n",
    "            4 * [r\"'\"],\n",
    "            4 * [r\"'\"],\n",
    "            4 * [r\"'\"],\n",
    "            4 * [r\"'\"],\n",
    "            4 * [r\"'\"],\n",
    "            6 * [r\"'\"],\n",
    "            [],\n",
    "            [],\n",
    "            [],\n",
    "            []]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_search_for,\n",
    "            {(r\"'\", test_string, 0, 0, use_regex): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)\n",
    "             for use_regex in [True, False]},\n",
    "            self.list_zero_group)\n",
    "\n",
    "    # Test unescaped_search_for() with an empty pattern.\n",
    "    def test_empty_pattern(self):\n",
    "        # Since an empty pattern can also be escaped, the result contains\n",
    "        # special cases. Especially we check the completely matched string (and\n",
    "        # not only the matched pattern itself) we need to place also the\n",
    "        # matched escape characters inside the result list consumed from the\n",
    "        # internal regex of unescaped_search_for().\n",
    "        expected_results = [\n",
    "            38 * [r\"\"],\n",
    "            38 * [r\"\"],\n",
    "            38 * [r\"\"],\n",
    "            37 * [r\"\"],\n",
    "            38 * [r\"\"],\n",
    "            38 * [r\"\"],\n",
    "            39 * [r\"\"],\n",
    "            38 * [r\"\"],\n",
    "            37 * [r\"\"],\n",
    "            38 * [r\"\"],\n",
    "            37 * [r\"\"],\n",
    "            38 * [r\"\"],\n",
    "            37 * [r\"\"],\n",
    "            39 * [r\"\"],\n",
    "            [r\"\"],\n",
    "            15 * [r\"\"],\n",
    "            [r\"\"],\n",
    "            2 * [r\"\"]]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_search_for,\n",
    "            {(r\"\", test_string, 0, 0, use_regex): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)\n",
    "             for use_regex in [True, False]},\n",
    "            self.list_zero_group)\n",
    "\n",
    "    # Test unescaped_search_for() for its max_match parameter.\n",
    "    def test_max_match(self):\n",
    "        search_pattern = self.test_basic_pattern\n",
    "        expected_master_results = self.test_basic_expected_results\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_search_for,\n",
    "            {(search_pattern, test_string, 0, max_match, True): result\n",
    "             for max_match in [1, 2, 3, 4, 5, 6, 987, 1122334455]\n",
    "             for test_string, result in zip(\n",
    "                 self.test_strings,\n",
    "                 [elem[0: max_match] for elem in expected_master_results])},\n",
    "            self.list_zero_group)\n",
    "\n",
    "    # Test unescaped_search_for() for its max_match parameter with matches\n",
    "    # that are also escaped.\n",
    "    def test_max_match_escaping_flaw(self):\n",
    "        expected_master_results = [\n",
    "            2 * [r\"'\"],\n",
    "            2 * [r\"'\"],\n",
    "            2 * [r\"'\"],\n",
    "            2 * [r\"'\"],\n",
    "            2 * [r\"'\"],\n",
    "            2 * [r\"'\"],\n",
    "            4 * [r\"'\"],\n",
    "            4 * [r\"'\"],\n",
    "            4 * [r\"'\"],\n",
    "            4 * [r\"'\"],\n",
    "            4 * [r\"'\"],\n",
    "            4 * [r\"'\"],\n",
    "            4 * [r\"'\"],\n",
    "            6 * [r\"'\"],\n",
    "            [],\n",
    "            [],\n",
    "            [],\n",
    "            []]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_search_for,\n",
    "            {(r\"'\", test_string, 0, max_match, use_regex): result\n",
    "             for max_match in [1, 2, 3, 4, 5, 6, 100]\n",
    "             for test_string, result in zip(\n",
    "                 self.test_strings,\n",
    "                 [elem[0: max_match] for elem in expected_master_results])\n",
    "             for use_regex in [True, False]},\n",
    "            self.list_zero_group)\n",
    "\n",
    "    # Test unescaped_search_for() with regexes disabled.\n",
    "    def test_disabled_regex(self):\n",
    "        search_pattern = r\"\\'\"\n",
    "        expected_results = [\n",
    "            [],\n",
    "            [search_pattern],\n",
    "            [],\n",
    "            [],\n",
    "            [search_pattern],\n",
    "            [],\n",
    "            [],\n",
    "            [search_pattern],\n",
    "            [search_pattern],\n",
    "            [],\n",
    "            [],\n",
    "            [],\n",
    "            [],\n",
    "            [],\n",
    "            [],\n",
    "            [],\n",
    "            [],\n",
    "            []]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_search_for,\n",
    "            {(search_pattern, test_string, 0, 0, False): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)},\n",
    "            self.list_zero_group)\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/UnescapedSearchInBetweenTest.py": [
    "\n",
    "from coalib.parsing.StringProcessing import (\n",
    "    InBetweenMatch, unescaped_search_in_between)\n",
    "from tests.parsing.StringProcessing.StringProcessingTestBase import (\n",
    "    StringProcessingTestBase)\n",
    "\n",
    "\n",
    "class UnescapedSearchInBetweenTest(StringProcessingTestBase):\n",
    "    bs = StringProcessingTestBase.bs\n",
    "\n",
    "    test_basic_pattern = \"'\"\n",
    "    test_basic_expected_results = [\n",
    "        [(test_basic_pattern, 5,\n",
    "          r\"escaped-escape:        \\\\ \", 6,\n",
    "          test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 5,\n",
    "          r\"escaped-quote:         \\' \",\n",
    "          6, test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 5,\n",
    "          r\"escaped-anything:      \\X \", 6,\n",
    "          test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 5,\n",
    "          r\"two escaped escapes: \\\\\\\\ \", 6,\n",
    "          test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 5,\n",
    "          r\"escaped-quote at end:   \\'\", 6,\n",
    "          test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 5,\n",
    "          \"escaped-escape at end:  \" + 2 * bs, 6,\n",
    "          test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 15, \"str1\", 16, test_basic_pattern, 20),\n",
    "         (test_basic_pattern, 27, \"str2\", 28, test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 15, \"str1\", 16, test_basic_pattern, 20),\n",
    "         (test_basic_pattern, 27, \"str2\", 28, test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 15, \"str1\", 16, test_basic_pattern, 20),\n",
    "         (test_basic_pattern, 27, \"str2\", 28, test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 15, \"str1\", 16, test_basic_pattern, 20),\n",
    "         (test_basic_pattern, 27, \"str2\", 28, test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 15, \"str1\", 16, test_basic_pattern, 20),\n",
    "         (test_basic_pattern, 27, \"str2\", 28, test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 15, \"str1\", 16, test_basic_pattern, 20),\n",
    "         (test_basic_pattern, 27, \"str2\", 28, test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 15, \"str1\", 16, test_basic_pattern, 20),\n",
    "         (test_basic_pattern, 27, \"str2\", 28, test_basic_pattern, 32)],\n",
    "        [(test_basic_pattern, 15, \"str1\", 16, test_basic_pattern, 20),\n",
    "         (test_basic_pattern, 21, \"str2\", 22, test_basic_pattern, 26),\n",
    "         (test_basic_pattern, 27, \"str3\", 28, test_basic_pattern, 32)],\n",
    "        [],\n",
    "        [],\n",
    "        [],\n",
    "        []]\n",
    "\n",
    "    # Test the basic unescaped_search_in_between() functionality.\n",
    "    def test_basic(self):\n",
    "        expected_results = self.test_basic_expected_results\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_search_in_between,\n",
    "            {(self.test_basic_pattern,\n",
    "              self.test_basic_pattern,\n",
    "              test_string,\n",
    "              0,\n",
    "              False,\n",
    "              use_regex): [InBetweenMatch.from_values(*args)\n",
    "                           for args in result]\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)\n",
    "             for use_regex in [True, False]},\n",
    "            list)\n",
    "\n",
    "    # Test the unescaped_search_in_between() while varying the max_match\n",
    "    # parameter.\n",
    "    def test_max_match(self):\n",
    "        search_pattern = self.test_basic_pattern\n",
    "        expected_master_results = self.test_basic_expected_results\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_search_in_between,\n",
    "            {(search_pattern,\n",
    "              search_pattern,\n",
    "              test_string,\n",
    "              max_match,\n",
    "              False,\n",
    "              use_regex): [InBetweenMatch.from_values(*args)\n",
    "                           for args in result]\n",
    "             for max_match in [1, 2, 3, 4, 5, 100]\n",
    "             for test_string, result in zip(\n",
    "                 self.test_strings,\n",
    "                 [elem[0: max_match] for elem in expected_master_results])\n",
    "             for use_regex in [True, False]},\n",
    "            list)\n",
    "\n",
    "    # Test the unescaped_search_in_between() function with different regex\n",
    "    # patterns.\n",
    "    def test_regex_pattern(self):\n",
    "        expected_results = [\n",
    "            [(\"abc\", 0, \"\", 3, \"abc\", 3)],\n",
    "            [(\"ab\", 0, \"c\", 2, \"ab\", 3)],\n",
    "            [(\"ab\", 0, \"c\", 2, \"ab\", 3),\n",
    "             (\"ab\", 21, r\"bc\\+'**'\", 23, \"ac\", 31)],\n",
    "            [(self.bs, 12, r\"\\13q4ujsabbc\", 13, self.bs, 25)],\n",
    "            [(\"###\", 9, r\"\\\\13q4ujsabbc\\+'**'ac\", 12, \"###\", 33),\n",
    "             (\"#\", 37, \".\", 38, \"####\", 39)],\n",
    "            [(\"a\", 0, \"\", 1, \"b\", 1),\n",
    "             (\"a\", 3, \"\", 4, \"b\", 4),\n",
    "             (\"b\", 7, \"\", 8, \"a\", 8),\n",
    "             (\"##\", 9, \"\", 11, \"#\\\\\", 11),\n",
    "             (\"a\", 21, \"\", 22, \"b\", 22),\n",
    "             (\"b\", 23, r\"c\\+'**'\", 24, \"a\", 31),\n",
    "             (\"##\", 33, \"\", 35, \"#.\", 35),\n",
    "             (\"#.\", 37, \"\", 39, \"##\", 39),\n",
    "             (\"##\", 41, \"-\", 43, \"b\", 44)],\n",
    "            [(\"abcabc\", 0, r\"cba###\\\\13q4ujs\", 6, \"abbc\", 21)],\n",
    "            []]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_search_in_between,\n",
    "            {(pattern,\n",
    "              pattern,\n",
    "              self.multi_pattern_test_string,\n",
    "              0,\n",
    "              False,\n",
    "              True): [InBetweenMatch.from_values(*args)\n",
    "                      for args in result]\n",
    "             for pattern, result in zip(self.multi_patterns,\n",
    "                                        expected_results)},\n",
    "            list)\n",
    "\n",
    "    # Test the unescaped_search_in_between() function for its\n",
    "    # remove_empty_matches feature.\n",
    "    def test_auto_trim(self):\n",
    "        expected_results = [\n",
    "            [],\n",
    "            [(\";\", 2, r\"\\\\\\\\\\;\\\\#\", 3, \";\", 12),\n",
    "             (\";\", 25, \"+ios\", 26, \";\", 30)],\n",
    "            [(\";\", 1, \"2\", 2, \";\", 3),\n",
    "             (\";\", 5, \"4\", 6, \";\", 7),\n",
    "             (\";\", 9, \"6\", 10, \";\", 11)],\n",
    "            [(\";\", 1, \"2\", 2, \";\", 3),\n",
    "             (\";\", 5, \"4\", 6, \";\", 7),\n",
    "             (\";\", 9, \"6\", 10, \";\", 11)],\n",
    "            [],\n",
    "            [],\n",
    "            [],\n",
    "            [],\n",
    "            [(\";\", 3, \"a\", 4, \";\", 5)]]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_search_in_between,\n",
    "            {(self.auto_trim_test_pattern,\n",
    "              self.auto_trim_test_pattern,\n",
    "              test_string,\n",
    "              0,\n",
    "              True,\n",
    "              use_regex): [InBetweenMatch.from_values(*args)\n",
    "                           for args in result]\n",
    "             for test_string, result in zip(self.auto_trim_test_strings,\n",
    "                                            expected_results)\n",
    "             for use_regex in [True, False]},\n",
    "            list)\n",
    "\n",
    "    # Test the unescaped_search_in_between() function for its use_regex\n",
    "    # parameter.\n",
    "    def test_disabled_regex(self):\n",
    "        search_pattern = r\"'()?\"\n",
    "        expected_results = [[] for x in range(len(self.test_strings))]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_search_in_between,\n",
    "            {(search_pattern,\n",
    "              search_pattern,\n",
    "              test_string,\n",
    "              0,\n",
    "              # For remove_empty_matches both works, True and False.\n",
    "              auto_trim,\n",
    "              False): [InBetweenMatch.from_values(*args)\n",
    "                       for args in result]\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)\n",
    "             for auto_trim in [True, False]},\n",
    "            list)\n",
    "\n",
    "    # Test the unescaped_search_in_between() function using the test-strings\n",
    "    # specific for search-in-between functions.\n",
    "    def test_extended(self):\n",
    "        expected_results = [\n",
    "            [(\"(\", 0, \"\", 1, \")\", 1),\n",
    "             (\"(\", 6, \"This is a word\", 7, \")\", 21),\n",
    "             (\"(\", 25, \"(in a word\", 26, \")\", 36)],\n",
    "            [(\"(\", 4, \"((((((((((((((((((1\", 5, \")\", 24)],\n",
    "            [(\"(\", 6, \"do (it \", 7, \")\", 14),\n",
    "             (\"(\", 41, \"\", 42, \")\", 42),\n",
    "             (\"(\", 44, \"hello.\", 45, \")\", 51)],\n",
    "            [(\"(\", 0, \"\", 1, \")\", 1),\n",
    "             (\"(\", 8,\n",
    "              r\"This\\ is a word\\)and((in a\\\\\\ word\\\\\\\\\\) another \\)\", 9,\n",
    "              \")\", 60)],\n",
    "            [(\"(\", 10, r\"((((\\\\\\(((((((((((1\", 11, \")\", 30)],\n",
    "            [(\"(\", 11, \"it \", 12, \")\", 15),\n",
    "             (\"(\", 45, \"\", 46, \")\", 46),\n",
    "             (\"(\", 48, \"hello.\", 49, \")\", 55)]]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_search_in_between,\n",
    "            {(begin_pattern,\n",
    "              end_pattern,\n",
    "              test_string,\n",
    "              0,\n",
    "              False,\n",
    "              use_regex): [InBetweenMatch.from_values(*args)\n",
    "                           for args in result]\n",
    "             for test_string, result in zip(\n",
    "                 self.search_in_between_test_strings,\n",
    "                 expected_results)\n",
    "             for use_regex, begin_pattern, end_pattern in\n",
    "             [(True, r\"\\(\", r\"\\)\"),\n",
    "              (False,\n",
    "               self.search_in_between_begin_pattern,\n",
    "               self.search_in_between_end_pattern)]},\n",
    "            list)\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/UnescapedSplitTest.py": [
    "\n",
    "from coalib.parsing.StringProcessing import unescaped_split\n",
    "from tests.parsing.StringProcessing.StringProcessingTestBase import (\n",
    "    StringProcessingTestBase)\n",
    "\n",
    "\n",
    "class UnescapedSplitTest(StringProcessingTestBase):\n",
    "    bs = StringProcessingTestBase.bs\n",
    "\n",
    "    test_basic_pattern = r\"'\"\n",
    "    test_basic_expected_results = [\n",
    "        [r\"out1 \", r\"escaped-escape:        \\\\ \", r\" out2\"],\n",
    "        [r\"out1 \", r\"escaped-quote:         \\' \", r\" out2\"],\n",
    "        [r\"out1 \", r\"escaped-anything:      \\X \", r\" out2\"],\n",
    "        [r\"out1 \", r\"two escaped escapes: \\\\\\\\ \", r\" out2\"],\n",
    "        [r\"out1 \", r\"escaped-quote at end:   \\'\", r\" out2\"],\n",
    "        [r\"out1 \", r\"escaped-escape at end:  \" + 2 * bs, r\" out2\"],\n",
    "        [r\"out1           \", r\"str1\", r\" out2 \", r\"str2\", r\" out2\"],\n",
    "        [r\"out1 \\'        \", r\"str1\", r\" out2 \", r\"str2\", r\" out2\"],\n",
    "        [r\"out1 \\\\\\'      \", r\"str1\", r\" out2 \", r\"str2\", r\" out2\"],\n",
    "        [r\"out1 \\\\        \", r\"str1\", r\" out2 \", r\"str2\", r\" out2\"],\n",
    "        [r\"out1 \\\\\\\\      \", r\"str1\", r\" out2 \", r\"str2\", r\" out2\"],\n",
    "        [r\"out1         \" + 2 * bs, r\"str1\", r\" out2 \", r\"str2\", r\" out2\"],\n",
    "        [r\"out1       \" + 4 * bs, r\"str1\", r\" out2 \", r\"str2\", r\" out2\"],\n",
    "        [r\"out1           \", r\"str1\", r\"\", r\"str2\", r\"\", r\"str3\", r\" out2\"],\n",
    "        [r\"\"],\n",
    "        [r\"out1 out2 out3\"],\n",
    "        [bs],\n",
    "        [2 * bs]]\n",
    "\n",
    "    # Test the basic unescaped_split() functionality.\n",
    "    def test_basic(self):\n",
    "        split_pattern = self.test_basic_pattern\n",
    "        expected_results = self.test_basic_expected_results\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_split,\n",
    "            {(split_pattern, test_string, 0, False, use_regex): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)\n",
    "             for use_regex in [True, False]},\n",
    "            list)\n",
    "\n",
    "    # Test the unescaped_split() function while varying the max_split\n",
    "    # parameter.\n",
    "    def test_max_split(self):\n",
    "        split_pattern = self.test_basic_pattern\n",
    "        expected_master_results = self.test_basic_expected_results\n",
    "\n",
    "        for max_split in [1, 2, 3, 4, 5, 6, 7, 8, 9, 112]:\n",
    "            expected_results = [\n",
    "                elem[0: max_split] for elem in expected_master_results]\n",
    "\n",
    "            for res, master in zip(expected_results, expected_master_results):\n",
    "                if max_split < len(master):\n",
    "                    # max_split is less the length of our master result list,\n",
    "                    # need to append the rest as a joined string.\n",
    "                    res.append(str.join(split_pattern, master[max_split:]))\n",
    "\n",
    "            self.assertResultsEqual(\n",
    "                unescaped_split,\n",
    "                {(split_pattern,\n",
    "                  test_string,\n",
    "                  max_split,\n",
    "                  False,\n",
    "                  use_regex): result\n",
    "                 for test_string, result in zip(self.test_strings,\n",
    "                                                expected_results)\n",
    "                 for use_regex in [True, False]},\n",
    "                list)\n",
    "\n",
    "    # Test the unescaped_split() function with different regex patterns.\n",
    "    def test_regex_pattern(self):\n",
    "        expected_results = [\n",
    "            [r\"\", r\"\", r\"cba###\\\\13q4ujsabbc\\+'**'ac###.#.####-ba\"],\n",
    "            [r\"\", r\"c\", r\"ccba###\\\\13q4ujs\", r\"bc\\+'**'ac###.#.####-ba\"],\n",
    "            [r\"\", r\"c\", r\"ccba###\\\\13q4ujs\", r\"bc\\+'**'\", r\"###.#.####-ba\"],\n",
    "            [r\"abcabccba###\", r\"\\13q4ujsabbc\", r\"+'**'ac###.#.####-ba\"],\n",
    "            [r\"abcabccba\", r\"\\\\13q4ujsabbc\\+'**'ac\", r\".\", r\".\", r\"-ba\"],\n",
    "            [r\"\", r\"\", r\"c\", r\"\", r\"cc\", r\"\", r\"\", r\"\", r\"\\13q4ujs\", r\"\", r\"\",\n",
    "                r\"c\\+'**'\", r\"c\", r\"\", r\"\", r\"\", r\"\", r\"-\", r\"\", r\"\"],\n",
    "            [r\"\", r\"cba###\\\\13q4ujs\", r\"\\+'**'\", r\"###.#.####-ba\"],\n",
    "            [r\"abcabccba###\" + 2 * self.bs,\n",
    "                r\"3q4ujsabbc\\+'**'ac###.#.####-ba\"]]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_split,\n",
    "            {(pattern, self.multi_pattern_test_string, 0, False, True): result\n",
    "             for pattern, result in zip(self.multi_patterns,\n",
    "                                        expected_results)},\n",
    "            list)\n",
    "\n",
    "    # Test the unescaped_split() function for its remove_empty_matches feature.\n",
    "    def test_auto_trim(self):\n",
    "        expected_results = [\n",
    "            [],\n",
    "            [2 * self.bs, r\"\\\\\\\\\\;\\\\#\", r\"\\\\\\'\", r\"\\;\\\\\\\\\", r\"+ios\"],\n",
    "            [r\"1\", r\"2\", r\"3\", r\"4\", r\"5\", r\"6\"],\n",
    "            [r\"1\", r\"2\", r\"3\", r\"4\", r\"5\", r\"6\", r\"7\"],\n",
    "            [],\n",
    "            [r\"Hello world\"],\n",
    "            [r\"\\;\"],\n",
    "            [2 * self.bs],\n",
    "            [r\"abc\", r\"a\", r\"asc\"]]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_split,\n",
    "            {(self.auto_trim_test_pattern,\n",
    "              test_string,\n",
    "              0,\n",
    "              True,\n",
    "              use_regex): result\n",
    "             for test_string, result in zip(self.auto_trim_test_strings,\n",
    "                                            expected_results)\n",
    "             for use_regex in [True, False]},\n",
    "            list)\n",
    "\n",
    "    # Test the unescaped_split() function with regexes disabled.\n",
    "    def test_disabled_regex(self):\n",
    "        expected_results = [[x] for x in self.test_strings]\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_split,\n",
    "            {(r\"'()\", test_string, 0, False, False): result\n",
    "             for test_string, result in zip(self.test_strings,\n",
    "                                            expected_results)},\n",
    "            list)\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/UnescapedStripTest.py": [
    "\n",
    "from coalib.parsing.StringProcessing import unescaped_rstrip, unescaped_strip\n",
    "from tests.parsing.StringProcessing.StringProcessingTestBase import (\n",
    "    StringProcessingTestBase)\n",
    "\n",
    "\n",
    "class UnescapedStripTest(StringProcessingTestBase):\n",
    "    test_strings2 = (\"hello\\\\\",\n",
    "                     \"te\\\\st\\\\\\\\\",\n",
    "                     r\"A\\ \",\n",
    "                     r\"A\\       \",\n",
    "                     r\"   A \\ \\  \",\n",
    "                     r\"    \\ A \\    \",\n",
    "                     r\"  \\\\ A\",\n",
    "                     r\" \\\\\\\\\\  \",\n",
    "                     r\" \\\\\\\\  \")\n",
    "\n",
    "    def test_rstrip(self):\n",
    "        expected_results = (\"hello\\\\\",\n",
    "                            \"te\\\\st\\\\\\\\\",\n",
    "                            r\"A\\ \",\n",
    "                            r\"A\\ \",\n",
    "                            r\"   A \\ \\ \",\n",
    "                            r\"    \\ A \\ \",\n",
    "                            r\"  \\\\ A\",\n",
    "                            r\" \\\\\\\\\\ \",\n",
    "                            \" \\\\\\\\\\\\\\\\\")\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_rstrip,\n",
    "            {(test_string,): result\n",
    "             for test_string, result in zip(self.test_strings2,\n",
    "                                            expected_results)})\n",
    "\n",
    "    def test_strip(self):\n",
    "        expected_results = (\"hello\\\\\",\n",
    "                            \"te\\\\st\\\\\\\\\",\n",
    "                            r\"A\\ \",\n",
    "                            r\"A\\ \",\n",
    "                            r\"A \\ \\ \",\n",
    "                            r\"\\ A \\ \",\n",
    "                            r\"\\\\ A\",\n",
    "                            r\"\\\\\\\\\\ \",\n",
    "                            \"\\\\\\\\\\\\\\\\\")\n",
    "\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_strip,\n",
    "            {(test_string,): result\n",
    "             for test_string, result in zip(self.test_strings2,\n",
    "                                            expected_results)})\n",
    "\n",
    "    def test_no_whitespaced_strings(self):\n",
    "        # When no leading or trailing whitespaces exist, nothing should happen.\n",
    "        # By the way: self.test_strings comes from the base class.\n",
    "        self.assertResultsEqual(\n",
    "            unescaped_strip,\n",
    "            {(test_string,): test_string\n",
    "             for test_string in self.test_strings})\n"
  ],
  "/home/tushar/coala/tests/parsing/StringProcessing/__init__.py": [],
  "/home/tushar/coala/tests/parsing/__init__.py": [],
  "/home/tushar/coala/tests/processes/BearRunningTest.py": [
    "import multiprocessing\n",
    "import queue\n",
    "import unittest\n",
    "\n",
    "from coalib.bears.GlobalBear import GlobalBear\n",
    "from coalib.bears.LocalBear import LocalBear\n",
    "from coalib.processes.BearRunning import (\n",
    "    LOG_LEVEL, LogMessage, run, send_msg, task_done)\n",
    "from coalib.processes.CONTROL_ELEMENT import CONTROL_ELEMENT\n",
    "from coalib.results.Result import RESULT_SEVERITY, Result\n",
    "from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "class LocalTestBear(LocalBear):\n",
    "\n",
    "    def run(self, filename, file):\n",
    "        if filename == \"file1\":\n",
    "            raise Exception(\"Just to throw anything here.\")\n",
    "        return [Result.from_values(\"LocalTestBear\",\n",
    "                                   \"something went wrong\",\n",
    "                                   filename)]\n",
    "\n",
    "\n",
    "class SimpleBear(LocalBear):\n",
    "\n",
    "    def run(self,\n",
    "            filename,\n",
    "            file,\n",
    "            *args,\n",
    "            dependency_results=None,\n",
    "            **kwargs):\n",
    "        return [Result.from_values(\"SimpleBear\",\n",
    "                                   \"something went wrong\",\n",
    "                                   filename),\n",
    "                # This result should not be passed to DependentBear\n",
    "                Result.from_values(\"FakeBear\",\n",
    "                                   \"something went wrong\",\n",
    "                                   filename),\n",
    "                Result.from_values(\"SimpleBear\",\n",
    "                                   \"another thing went wrong\",\n",
    "                                   filename)]\n",
    "\n",
    "\n",
    "class DependentBear(LocalBear):\n",
    "\n",
    "    def run(self,\n",
    "            filename,\n",
    "            file,\n",
    "            *args,\n",
    "            dependency_results=None,\n",
    "            **kwargs):\n",
    "        assert len(dependency_results[\"SimpleBear\"]) == 2\n",
    "\n",
    "    @staticmethod\n",
    "    def get_dependencies():\n",
    "        return [SimpleBear]\n",
    "\n",
    "\n",
    "class SimpleGlobalBear(GlobalBear):\n",
    "\n",
    "    def run(self,\n",
    "            *args,\n",
    "            dependency_results=None,\n",
    "            **kwargs):\n",
    "        return [Result(\"SimpleGlobalBear\", \"something went wrong\"),\n",
    "                # This result should not be passed to DependentBear\n",
    "                Result(\"FakeBear\", \"something went wrong\"),\n",
    "                Result(\"SimpleGlobalBear\", \"another thing went wrong\")]\n",
    "\n",
    "\n",
    "class DependentGlobalBear(GlobalBear):\n",
    "\n",
    "    def run(self,\n",
    "            *args,\n",
    "            dependency_results=None,\n",
    "            **kwargs):\n",
    "        assert len(dependency_results[\"SimpleGlobalBear\"]) == 3\n",
    "\n",
    "    @staticmethod\n",
    "    def get_dependencies():\n",
    "        return [SimpleGlobalBear]\n",
    "\n",
    "\n",
    "class GlobalTestBear(GlobalBear):\n",
    "\n",
    "    def run(self):\n",
    "        result = []\n",
    "        for file, contents in self.file_dict.items():\n",
    "            result.append(Result.from_values(\"GlobalTestBear\",\n",
    "                                             \"Files are bad in general!\",\n",
    "                                             file,\n",
    "                                             severity=RESULT_SEVERITY.INFO))\n",
    "        return result\n",
    "\n",
    "\n",
    "class EvilBear(LocalBear):\n",
    "\n",
    "    def execute(self, *args, **kwargs):\n",
    "        raise NotImplementedError\n",
    "\n",
    "\n",
    "class UnexpectedBear1(LocalBear):\n",
    "\n",
    "    def run(self, filename, file):\n",
    "        return [1,\n",
    "                Result(\"UnexpectedBear1\", \"test result\")]\n",
    "\n",
    "\n",
    "class UnexpectedBear2(LocalBear):\n",
    "\n",
    "    def run(self, filename, file):\n",
    "        return 1\n",
    "\n",
    "\n",
    "class BearRunningUnitTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.settings = Section(\"name\")\n",
    "\n",
    "        self.file_name_queue = queue.Queue()\n",
    "        self.local_bear_list = []\n",
    "        self.global_bear_list = []\n",
    "        self.global_bear_queue = queue.Queue()\n",
    "        self.file_dict = {}\n",
    "        manager = multiprocessing.Manager()\n",
    "        self.local_result_dict = manager.dict()\n",
    "        self.global_result_dict = manager.dict()\n",
    "        self.message_queue = queue.Queue()\n",
    "        self.control_queue = queue.Queue()\n",
    "\n",
    "    def test_queue_done_marking(self):\n",
    "        self.message_queue.put(\"test\")\n",
    "        task_done(self.message_queue)  # Should make the queue joinable\n",
    "        self.message_queue.join()\n",
    "\n",
    "        task_done(\"test\")  # Should pass silently\n",
    "\n",
    "    def test_messaging(self):\n",
    "        send_msg(self.message_queue,\n",
    "                 0,\n",
    "                 LOG_LEVEL.DEBUG,\n",
    "                 \"test\",\n",
    "                 \"messag\",\n",
    "                 delimiter=\"-\",\n",
    "                 end=\"e\")\n",
    "\n",
    "        self.assertEqual(self.message_queue.get(),\n",
    "                         LogMessage(LOG_LEVEL.DEBUG, \"test-message\"))\n",
    "\n",
    "    def test_dependencies(self):\n",
    "        self.local_bear_list.append(SimpleBear(self.settings,\n",
    "                                               self.message_queue))\n",
    "        self.local_bear_list.append(DependentBear(self.settings,\n",
    "                                                  self.message_queue))\n",
    "        self.global_bear_list.append(SimpleGlobalBear({},\n",
    "                                                      self.settings,\n",
    "                                                      self.message_queue))\n",
    "        self.global_bear_list.append(DependentGlobalBear({},\n",
    "                                                         self.settings,\n",
    "                                                         self.message_queue))\n",
    "        self.global_bear_queue.put(1)\n",
    "        self.global_bear_queue.put(0)\n",
    "        self.file_name_queue.put(\"t\")\n",
    "        self.file_dict[\"t\"] = []\n",
    "\n",
    "        run(self.file_name_queue,\n",
    "            self.local_bear_list,\n",
    "            self.global_bear_list,\n",
    "            self.global_bear_queue,\n",
    "            self.file_dict,\n",
    "            self.local_result_dict,\n",
    "            self.global_result_dict,\n",
    "            self.message_queue,\n",
    "            self.control_queue)\n",
    "\n",
    "        try:\n",
    "            while True:\n",
    "                msg = self.message_queue.get(timeout=0)\n",
    "                self.assertEqual(msg.log_level, LOG_LEVEL.DEBUG)\n",
    "        except queue.Empty:\n",
    "            pass\n",
    "\n",
    "    def test_evil_bear(self):\n",
    "        self.local_bear_list.append(EvilBear(self.settings,\n",
    "                                             self.message_queue))\n",
    "        self.file_name_queue.put(\"t\")\n",
    "        self.file_dict[\"t\"] = []\n",
    "\n",
    "        run(self.file_name_queue,\n",
    "            self.local_bear_list,\n",
    "            self.global_bear_list,\n",
    "            self.global_bear_queue,\n",
    "            self.file_dict,\n",
    "            self.local_result_dict,\n",
    "            self.global_result_dict,\n",
    "            self.message_queue,\n",
    "            self.control_queue)\n",
    "\n",
    "    def test_strange_bear(self):\n",
    "        self.local_bear_list.append(UnexpectedBear1(self.settings,\n",
    "                                                    self.message_queue))\n",
    "        self.local_bear_list.append(UnexpectedBear2(self.settings,\n",
    "                                                    self.message_queue))\n",
    "        self.file_name_queue.put(\"t\")\n",
    "        self.file_dict[\"t\"] = []\n",
    "\n",
    "        run(self.file_name_queue,\n",
    "            self.local_bear_list,\n",
    "            self.global_bear_list,\n",
    "            self.global_bear_queue,\n",
    "            self.file_dict,\n",
    "            self.local_result_dict,\n",
    "            self.global_result_dict,\n",
    "            self.message_queue,\n",
    "            self.control_queue)\n",
    "\n",
    "        expected_messages = [LOG_LEVEL.DEBUG,\n",
    "                             LOG_LEVEL.ERROR,\n",
    "                             LOG_LEVEL.DEBUG,\n",
    "                             LOG_LEVEL.DEBUG,\n",
    "                             LOG_LEVEL.WARNING]\n",
    "\n",
    "        for msg in expected_messages:\n",
    "            self.assertEqual(msg, self.message_queue.get(timeout=0).log_level)\n",
    "\n",
    "\n",
    "class BearRunningIntegrationTest(unittest.TestCase):\n",
    "    example_file = \"\"\"a\n",
    "b\n",
    "c\n",
    "d\n",
    "\"\"\"\n",
    "\n",
    "    def setUp(self):\n",
    "        self.settings = Section(\"name\")\n",
    "\n",
    "        self.file_name_queue = queue.Queue()\n",
    "        self.local_bear_list = []\n",
    "        self.global_bear_list = []\n",
    "        self.global_bear_queue = queue.Queue()\n",
    "        self.file_dict = {}\n",
    "        manager = multiprocessing.Manager()\n",
    "        self.local_result_dict = manager.dict()\n",
    "        self.global_result_dict = manager.dict()\n",
    "        self.message_queue = queue.Queue()\n",
    "        self.control_queue = queue.Queue()\n",
    "\n",
    "        self.file1 = \"file1\"\n",
    "        self.file2 = \"arbitrary\"\n",
    "\n",
    "        self.file_name_queue.put(self.file1)\n",
    "        self.file_name_queue.put(self.file2)\n",
    "        self.file_name_queue.put(\"invalid file\")\n",
    "        self.local_bear_list.append(LocalTestBear(self.settings,\n",
    "                                                  self.message_queue))\n",
    "        self.local_bear_list.append(\"not a valid bear\")\n",
    "        self.file_dict[self.file1] = self.example_file\n",
    "        self.file_dict[self.file2] = self.example_file\n",
    "        self.global_bear_list.append(GlobalTestBear(self.file_dict,\n",
    "                                                    self.settings,\n",
    "                                                    self.message_queue))\n",
    "        self.global_bear_list.append(\"not a valid bear\")\n",
    "        self.global_bear_queue.put(0)\n",
    "        self.global_bear_queue.put(1)\n",
    "\n",
    "    def test_run(self):\n",
    "        run(self.file_name_queue,\n",
    "            self.local_bear_list,\n",
    "            self.global_bear_list,\n",
    "            self.global_bear_queue,\n",
    "            self.file_dict,\n",
    "            self.local_result_dict,\n",
    "            self.global_result_dict,\n",
    "            self.message_queue,\n",
    "            self.control_queue)\n",
    "\n",
    "        expected_messages = [LOG_LEVEL.DEBUG,\n",
    "                             LOG_LEVEL.WARNING,\n",
    "                             LOG_LEVEL.DEBUG,\n",
    "                             LOG_LEVEL.WARNING,\n",
    "                             LOG_LEVEL.DEBUG,\n",
    "                             LOG_LEVEL.WARNING,\n",
    "                             LOG_LEVEL.ERROR,\n",
    "                             LOG_LEVEL.DEBUG,\n",
    "                             LOG_LEVEL.DEBUG,\n",
    "                             LOG_LEVEL.WARNING]\n",
    "        for msg in expected_messages:\n",
    "            self.assertEqual(msg, self.message_queue.get(timeout=0).log_level)\n",
    "\n",
    "        local_result_expected = [[],\n",
    "                                 [Result.from_values(\"LocalTestBear\",\n",
    "                                                     \"something went wrong\",\n",
    "                                                     'arbitrary')]\n",
    "                                 ]\n",
    "        for expected in local_result_expected:\n",
    "            control_elem, index = self.control_queue.get()\n",
    "            self.assertEqual(control_elem, CONTROL_ELEMENT.LOCAL)\n",
    "            real = self.local_result_dict[index]\n",
    "            self.assertEqual(real, expected)\n",
    "\n",
    "        global_results_expected = [Result.from_values(\n",
    "                                       \"GlobalTestBear\",\n",
    "                                       \"Files are bad in general!\",\n",
    "                                       \"file1\",\n",
    "                                       severity=RESULT_SEVERITY.INFO),\n",
    "                                   Result.from_values(\n",
    "                                       \"GlobalTestBear\",\n",
    "                                       \"Files are bad in general!\",\n",
    "                                       \"arbitrary\",\n",
    "                                       severity=RESULT_SEVERITY.INFO)]\n",
    "\n",
    "        control_elem, index = self.control_queue.get()\n",
    "        self.assertEqual(control_elem, CONTROL_ELEMENT.LOCAL_FINISHED)\n",
    "        control_elem, index = self.control_queue.get()\n",
    "        self.assertEqual(control_elem, CONTROL_ELEMENT.GLOBAL)\n",
    "        real = self.global_result_dict[index]\n",
    "        self.assertEqual(sorted(global_results_expected), sorted(real))\n",
    "\n",
    "        control_elem, none = self.control_queue.get(timeout=0)\n",
    "        self.assertEqual(control_elem, CONTROL_ELEMENT.GLOBAL_FINISHED)\n",
    "        self.assertEqual(none, None)\n",
    "\n",
    "        # The invalid bear gets a None in that dict for dependency resolution\n",
    "        self.assertEqual(len(self.global_result_dict), 2)\n",
    "        self.assertEqual(len(self.local_result_dict),\n",
    "                         len(local_result_expected))\n",
    "        self.assertRaises(queue.Empty, self.message_queue.get, timeout=0)\n",
    "        self.assertRaises(queue.Empty, self.control_queue.get, timeout=0)\n"
  ],
  "/home/tushar/coala/tests/processes/LogPrinterThreadTest.py": [
    "import queue\n",
    "import unittest\n",
    "\n",
    "from coalib.misc.ContextManagers import retrieve_stdout\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "from coalib.processes.LogPrinterThread import LogPrinterThread\n",
    "\n",
    "\n",
    "class TestPrinter(LogPrinter):\n",
    "\n",
    "    def __init__(self):\n",
    "        LogPrinter.__init__(self, self)\n",
    "\n",
    "    def log_message(self, log_message, timestamp=None, **kwargs):\n",
    "        print(log_message)\n",
    "\n",
    "\n",
    "class LogPrinterThreadTest(unittest.TestCase):\n",
    "\n",
    "    def test_run(self):\n",
    "        log_printer = TestPrinter()\n",
    "        log_queue = queue.Queue()\n",
    "        self.uut = LogPrinterThread(log_queue, log_printer)\n",
    "        log_queue.put(item=\"Sample message 1\")\n",
    "        log_queue.put(item=\"Sample message 2\")\n",
    "        log_queue.put(item=\"Sample message 3\")\n",
    "        self.assertEqual(self.uut.message_queue.qsize(), 3)\n",
    "        with retrieve_stdout() as stdout:\n",
    "            self.uut.start()\n",
    "            while self.uut.message_queue.qsize() > 0:\n",
    "                continue\n",
    "            self.uut.running = False\n",
    "            self.uut.join()\n",
    "            self.assertEqual(stdout.getvalue(),\n",
    "                             \"Sample message 1\\nSample message 2\\nSample \"\n",
    "                             \"message 3\\n\")\n"
  ],
  "/home/tushar/coala/tests/processes/ProcessingTest.py": [
    "import multiprocessing\n",
    "import os\n",
    "import platform\n",
    "import queue\n",
    "import re\n",
    "import subprocess\n",
    "import sys\n",
    "import unittest\n",
    "\n",
    "from pyprint.ConsolePrinter import ConsolePrinter\n",
    "\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "from coalib.processes.CONTROL_ELEMENT import CONTROL_ELEMENT\n",
    "from coalib.processes.Processing import (\n",
    "    ACTIONS, autoapply_actions, check_result_ignore, create_process_group,\n",
    "    execute_section, filter_raising_callables, get_default_actions,\n",
    "    get_file_dict, print_result, process_queues, simplify_section_result,\n",
    "    yield_ignore_ranges)\n",
    "from coalib.results.HiddenResult import HiddenResult\n",
    "from coalib.results.Result import RESULT_SEVERITY, Result\n",
    "from coalib.results.result_actions.ApplyPatchAction import ApplyPatchAction\n",
    "from coalib.results.result_actions.PrintDebugMessageAction import (\n",
    "    PrintDebugMessageAction)\n",
    "from coalib.results.result_actions.ResultAction import ResultAction\n",
    "from coalib.results.SourceRange import SourceRange\n",
    "from coalib.settings.ConfigurationGathering import gather_configuration\n",
    "from coalib.settings.Section import Section\n",
    "from coalib.settings.Setting import Setting\n",
    "\n",
    "\n",
    "process_group_test_code = \"\"\"\n",
    "import time, subprocess, os, platform, sys;\n",
    "p=subprocess.Popen([sys.executable,\n",
    "                  \"-c\",\n",
    "                  \"import time; time.sleep(0.1)\"]);\n",
    "pgid = p.pid if platform.system() == \"Windows\" else os.getpgid(p.pid);\n",
    "print(p.pid, pgid)\n",
    "p.terminate()\n",
    "\"\"\"\n",
    "\n",
    "\n",
    "class DummyProcess(multiprocessing.Process):\n",
    "\n",
    "    def __init__(self, control_queue, starts_dead=False):\n",
    "        multiprocessing.Process.__init__(self)\n",
    "        self.control_queue = control_queue\n",
    "        self.starts_dead = starts_dead\n",
    "\n",
    "    def is_alive(self):\n",
    "        return not self.control_queue.empty() and not self.starts_dead\n",
    "\n",
    "\n",
    "class ProcessingTestLogPrinter(LogPrinter):\n",
    "\n",
    "    def __init__(self, log_queue):\n",
    "        LogPrinter.__init__(self, self)\n",
    "        self.log_queue = log_queue\n",
    "        self.set_up = False\n",
    "\n",
    "    def log_message(self, log_message, timestamp=None, **kwargs):\n",
    "        self.log_queue.put(log_message)\n",
    "\n",
    "\n",
    "class ProcessingTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        config_path = os.path.abspath(os.path.join(\n",
    "            os.path.dirname(__file__),\n",
    "            \"section_executor_test_files\",\n",
    "            \".coafile\"))\n",
    "        self.testcode_c_path = os.path.join(os.path.dirname(config_path),\n",
    "                                            \"testcode.c\")\n",
    "\n",
    "        self.result_queue = queue.Queue()\n",
    "        self.queue = queue.Queue()\n",
    "        self.log_queue = queue.Queue()\n",
    "        log_printer = LogPrinter(ConsolePrinter())\n",
    "        self.log_printer = ProcessingTestLogPrinter(self.log_queue)\n",
    "\n",
    "        (self.sections,\n",
    "         self.local_bears,\n",
    "         self.global_bears,\n",
    "         targets) = gather_configuration(lambda *args: True,\n",
    "                                         log_printer,\n",
    "                                         arg_list=[\"--config\",\n",
    "                                                   re.escape(config_path)])\n",
    "        self.assertEqual(len(self.local_bears[\"default\"]), 1)\n",
    "        self.assertEqual(len(self.global_bears[\"default\"]), 1)\n",
    "        self.assertEqual(targets, [])\n",
    "\n",
    "    def test_run(self):\n",
    "        self.sections['default'].append(Setting('jobs', \"1\"))\n",
    "        results = execute_section(self.sections[\"default\"],\n",
    "                                  self.global_bears[\"default\"],\n",
    "                                  self.local_bears[\"default\"],\n",
    "                                  lambda *args: self.result_queue.put(args[2]),\n",
    "                                  self.log_printer)\n",
    "        self.assertTrue(results[0])\n",
    "\n",
    "        local_results = self.result_queue.get(timeout=0)\n",
    "        global_results = self.result_queue.get(timeout=0)\n",
    "        self.assertTrue(self.result_queue.empty())\n",
    "\n",
    "        self.assertEqual(len(local_results), 1)\n",
    "        self.assertEqual(len(global_results), 1)\n",
    "        # Result dict also returned\n",
    "        # One file\n",
    "        self.assertEqual(len(results[1]), 1)\n",
    "        # One global bear\n",
    "        self.assertEqual(len(results[2]), 1)\n",
    "\n",
    "        local_result = local_results[0]\n",
    "        global_result = global_results[0]\n",
    "\n",
    "        self.assertRegex(repr(local_result),\n",
    "                         \"<Result object\\\\(id={}, origin='LocalTestBear', \"\n",
    "                         \"affected_code=\\\\(\\\\), severity=NORMAL, message='test\"\n",
    "                         \" msg'\\\\) at 0x[0-9a-fA-F]+>\".format(\n",
    "                             hex(local_result.id)))\n",
    "        self.assertRegex(repr(global_result),\n",
    "                         \"<Result object\\\\(id={}, origin='GlobalTestBear', \"\n",
    "                         \"affected_code=\\\\(.*start=.*file=.*section_executor_\"\n",
    "                         \"test_files.*line=None.*end=.*\\\\), severity=NORMAL, \"\n",
    "                         \"message='test message'\\\\) at \"\n",
    "                         \"0x[0-9a-fA-F]+>\".format(hex(global_result.id)))\n",
    "\n",
    "    def test_empty_run(self):\n",
    "        self.sections['default'].append(Setting('jobs', \"bogus!\"))\n",
    "        results = execute_section(self.sections[\"default\"],\n",
    "                                  [],\n",
    "                                  [],\n",
    "                                  lambda *args: self.result_queue.put(args[2]),\n",
    "                                  self.log_printer)\n",
    "        # No results\n",
    "        self.assertFalse(results[0])\n",
    "        # One file\n",
    "        self.assertEqual(len(results[1]), 1)\n",
    "        # No global bear\n",
    "        self.assertEqual(len(results[2]), 0)\n",
    "\n",
    "    def test_process_queues(self):\n",
    "        ctrlq = queue.Queue()\n",
    "\n",
    "        # Append custom controlling sequences.\n",
    "\n",
    "        # Simulated process 1\n",
    "        ctrlq.put((CONTROL_ELEMENT.LOCAL, 1))\n",
    "        ctrlq.put((CONTROL_ELEMENT.LOCAL_FINISHED, None))\n",
    "        ctrlq.put((CONTROL_ELEMENT.GLOBAL, 1))\n",
    "\n",
    "        # Simulated process 2\n",
    "        ctrlq.put((CONTROL_ELEMENT.LOCAL, 2))\n",
    "\n",
    "        # Simulated process 1\n",
    "        ctrlq.put((CONTROL_ELEMENT.GLOBAL_FINISHED, None))\n",
    "\n",
    "        # Simulated process 2\n",
    "        ctrlq.put((CONTROL_ELEMENT.LOCAL_FINISHED, None))\n",
    "        ctrlq.put((CONTROL_ELEMENT.GLOBAL, 1))\n",
    "        ctrlq.put((CONTROL_ELEMENT.GLOBAL_FINISHED, None))\n",
    "\n",
    "        first_local = Result.from_values(\"o\", \"The first result.\", file=\"f\")\n",
    "        second_local = Result.from_values(\"ABear\",\n",
    "                                          \"The second result.\",\n",
    "                                          file=\"f\",\n",
    "                                          line=1)\n",
    "        third_local = Result.from_values(\"ABear\",\n",
    "                                         \"The second result.\",\n",
    "                                         file=\"f\",\n",
    "                                         line=4)\n",
    "        fourth_local = Result.from_values(\"ABear\",\n",
    "                                          \"Another result.\",\n",
    "                                          file=\"f\",\n",
    "                                          line=7)\n",
    "        first_global = Result(\"o\", \"The one and only global result.\")\n",
    "        section = Section(\"\")\n",
    "        section.append(Setting('min_severity', \"normal\"))\n",
    "        process_queues(\n",
    "            [DummyProcess(control_queue=ctrlq) for i in range(3)],\n",
    "            ctrlq,\n",
    "            {1: [first_local,\n",
    "                 second_local,\n",
    "                 third_local,\n",
    "                 # The following are to be ignored\n",
    "                 Result('o', 'm', severity=RESULT_SEVERITY.INFO),\n",
    "                 Result.from_values(\"ABear\", \"u\", \"f\", 2, 1),\n",
    "                 Result.from_values(\"ABear\", \"u\", \"f\", 3, 1)],\n",
    "             2: [fourth_local,\n",
    "                 # The following are to be ignored\n",
    "                 HiddenResult(\"t\", \"c\"),\n",
    "                 Result.from_values(\"ABear\", \"u\", \"f\", 5, 1),\n",
    "                 Result.from_values(\"ABear\", \"u\", \"f\", 6, 1)]},\n",
    "            {1: [first_global]},\n",
    "            {\"f\": [\"first line  # stop ignoring, invalid ignore range\\n\",\n",
    "                   \"second line  # ignore all\\n\",\n",
    "                   \"third line\\n\",\n",
    "                   \"fourth line\\n\",\n",
    "                   \"# Start ignoring ABear, BBear and CBear\\n\",\n",
    "                   \"# Stop ignoring\\n\",\n",
    "                   \"seventh\"]},\n",
    "            lambda *args: self.queue.put(args[2]),\n",
    "            section,\n",
    "            self.log_printer)\n",
    "\n",
    "        self.assertEqual(self.queue.get(timeout=0), ([first_local,\n",
    "                                                      second_local,\n",
    "                                                      third_local]))\n",
    "        self.assertEqual(self.queue.get(timeout=0), ([fourth_local]))\n",
    "        self.assertEqual(self.queue.get(timeout=0), ([first_global]))\n",
    "        self.assertEqual(self.queue.get(timeout=0), ([first_global]))\n",
    "\n",
    "    def test_dead_processes(self):\n",
    "        ctrlq = queue.Queue()\n",
    "        # Not enough FINISH elements in the queue, processes start already dead\n",
    "        # Also queue elements are reversed\n",
    "        ctrlq.put((CONTROL_ELEMENT.GLOBAL_FINISHED, None))\n",
    "        ctrlq.put((CONTROL_ELEMENT.LOCAL_FINISHED, None))\n",
    "\n",
    "        process_queues(\n",
    "            [DummyProcess(ctrlq, starts_dead=True) for i in range(3)],\n",
    "            ctrlq, {}, {}, {},\n",
    "            lambda *args: self.queue.put(args[2]),\n",
    "            Section(\"\"),\n",
    "            self.log_printer)\n",
    "        with self.assertRaises(queue.Empty):\n",
    "            self.queue.get(timeout=0)\n",
    "\n",
    "        # Not enough FINISH elements in the queue, processes start already dead\n",
    "        ctrlq.put((CONTROL_ELEMENT.LOCAL_FINISHED, None))\n",
    "        ctrlq.put((CONTROL_ELEMENT.GLOBAL_FINISHED, None))\n",
    "\n",
    "        process_queues(\n",
    "            [DummyProcess(ctrlq, starts_dead=True) for i in range(3)],\n",
    "            ctrlq, {}, {}, {},\n",
    "            lambda *args: self.queue.put(args[2]),\n",
    "            Section(\"\"),\n",
    "            self.log_printer)\n",
    "        with self.assertRaises(queue.Empty):\n",
    "            self.queue.get(timeout=0)\n",
    "\n",
    "    def test_create_process_group(self):\n",
    "        p = create_process_group([sys.executable,\n",
    "                                  \"-c\",\n",
    "                                  process_group_test_code],\n",
    "                                 stdout=subprocess.PIPE,\n",
    "                                 stderr=subprocess.PIPE)\n",
    "        retval = p.wait()\n",
    "        if retval != 0:\n",
    "            for line in p.stderr:\n",
    "                print(line, end='')\n",
    "            raise Exception(\"Subprocess did not exit correctly\")\n",
    "        output = [i for i in p.stdout]\n",
    "        p.stderr.close()\n",
    "        p.stdout.close()\n",
    "        pid, pgid = [int(i.strip()) for i_out in output for i in i_out.split()]\n",
    "        if platform.system() != \"Windows\":\n",
    "            # There is no way of testing this on windows with the current\n",
    "            # python modules subprocess and os\n",
    "            self.assertEqual(p.pid, pgid)\n",
    "\n",
    "    def test_filter_raising_callables(self):\n",
    "        class A(Exception):\n",
    "            pass\n",
    "\n",
    "        class B(Exception):\n",
    "            pass\n",
    "\n",
    "        class C(Exception):\n",
    "            pass\n",
    "\n",
    "        def create_exception_raiser(exception):\n",
    "            def raiser(exc):\n",
    "                if exception in exc:\n",
    "                    raise exception\n",
    "                return exception\n",
    "            return raiser\n",
    "\n",
    "        raiseA, raiseB, raiseC = (create_exception_raiser(exc)\n",
    "                                  for exc in [A, B, C])\n",
    "\n",
    "        test_list = [raiseA, raiseC, raiseB, raiseC]\n",
    "        self.assertEqual(list(filter_raising_callables(test_list, A, (A,))),\n",
    "                         [C, B, C])\n",
    "\n",
    "        self.assertEqual(list(filter_raising_callables(test_list,\n",
    "                                                       (B, C),\n",
    "                                                       exc=(B, C))),\n",
    "                         [A])\n",
    "\n",
    "        # Test whether non filtered exceptions bubble up.\n",
    "        with self.assertRaises(B):\n",
    "            list(filter_raising_callables(test_list, C, exc=(B, C)))\n",
    "\n",
    "    def test_get_file_dict(self):\n",
    "        file_dict = get_file_dict([self.testcode_c_path], self.log_printer)\n",
    "        self.assertEqual(len(file_dict), 1)\n",
    "        self.assertEqual(type(file_dict[self.testcode_c_path]),\n",
    "                         tuple,\n",
    "                         msg=\"files in file_dict should not be editable\")\n",
    "        self.assertEqual(\"Files that will be checked:\\n\" + self.testcode_c_path,\n",
    "                         self.log_printer.log_queue.get().message)\n",
    "\n",
    "    def test_get_file_dict_non_existent_file(self):\n",
    "        file_dict = get_file_dict([\"non_existent_file\"], self.log_printer)\n",
    "        self.assertEqual(file_dict, {})\n",
    "        self.assertIn((\"Failed to read file 'non_existent_file' because of \"\n",
    "                       \"an unknown error.\"),\n",
    "                      self.log_printer.log_queue.get().message)\n",
    "\n",
    "    def test_simplify_section_result(self):\n",
    "        results = (True,\n",
    "                   {\"file1\": [Result(\"a\", \"b\")], \"file2\": None},\n",
    "                   {\"file3\": [Result(\"a\", \"c\")]},\n",
    "                   None)\n",
    "        yielded, yielded_unfixed, all_results = simplify_section_result(results)\n",
    "        self.assertEqual(yielded, True)\n",
    "        self.assertEqual(yielded_unfixed, True)\n",
    "        self.assertEqual(len(all_results), 2)\n",
    "\n",
    "    def test_ignore_results(self):\n",
    "        ranges = [([], SourceRange.from_values(\"f\", 1, 1, 2, 2))]\n",
    "        result = Result.from_values(\"origin\",\n",
    "                                    \"message\",\n",
    "                                    file=\"e\",\n",
    "                                    line=1,\n",
    "                                    column=1,\n",
    "                                    end_line=2,\n",
    "                                    end_column=2)\n",
    "\n",
    "        self.assertFalse(check_result_ignore(result, ranges))\n",
    "\n",
    "        ranges.append(([], SourceRange.from_values(\"e\", 2, 3, 3, 3)))\n",
    "        self.assertFalse(check_result_ignore(result, ranges))\n",
    "\n",
    "        ranges.append(([], SourceRange.from_values(\"e\", 1, 1, 2, 2)))\n",
    "        self.assertTrue(check_result_ignore(result, ranges))\n",
    "\n",
    "        result1 = Result.from_values(\"origin\", \"message\", file=\"e\")\n",
    "        self.assertFalse(check_result_ignore(result1, ranges))\n",
    "\n",
    "        ranges = [(['something', 'else', 'not origin'],\n",
    "                   SourceRange.from_values(\"e\", 1, 1, 2, 2))]\n",
    "        self.assertFalse(check_result_ignore(result, ranges))\n",
    "\n",
    "        ranges = [(['something', 'else', 'origin'],\n",
    "                   SourceRange.from_values(\"e\", 1, 1, 2, 2))]\n",
    "        self.assertTrue(check_result_ignore(result, ranges))\n",
    "\n",
    "    def test_ignore_glob(self):\n",
    "        result = Result.from_values(\"LineLengthBear\",\n",
    "                                    \"message\",\n",
    "                                    file=\"d\",\n",
    "                                    line=1,\n",
    "                                    column=1,\n",
    "                                    end_line=2,\n",
    "                                    end_column=2)\n",
    "        ranges = [([\"(line*|space*)\", \"py*\"],\n",
    "                   SourceRange.from_values(\"d\", 1, 1, 2, 2))]\n",
    "        self.assertTrue(check_result_ignore(result, ranges))\n",
    "\n",
    "        result = Result.from_values(\"SpaceConsistencyBear\",\n",
    "                                    \"message\",\n",
    "                                    file=\"d\",\n",
    "                                    line=1,\n",
    "                                    column=1,\n",
    "                                    end_line=2,\n",
    "                                    end_column=2)\n",
    "        ranges = [([\"(line*|space*)\", \"py*\"],\n",
    "                   SourceRange.from_values(\"d\", 1, 1, 2, 2))]\n",
    "        self.assertTrue(check_result_ignore(result, ranges))\n",
    "\n",
    "        result = Result.from_values(\"XMLBear\",\n",
    "                                    \"message\",\n",
    "                                    file=\"d\",\n",
    "                                    line=1,\n",
    "                                    column=1,\n",
    "                                    end_line=2,\n",
    "                                    end_column=2)\n",
    "        ranges = [([\"(line*|space*)\", \"py*\"],\n",
    "                   SourceRange.from_values(\"d\", 1, 1, 2, 2))]\n",
    "        self.assertFalse(check_result_ignore(result, ranges))\n",
    "\n",
    "    def test_yield_ignore_ranges(self):\n",
    "        test_file_dict_a = {'f':\n",
    "                            ('# Ignore aBear\\n',\n",
    "                             'a_string = \"This string should be ignored\"\\n')}\n",
    "        test_ignore_range_a = list(yield_ignore_ranges(test_file_dict_a))\n",
    "        for test_bears, test_source_range in test_ignore_range_a:\n",
    "            self.assertEqual(test_bears, ['abear'])\n",
    "            self.assertEqual(test_source_range.start.line, 1)\n",
    "            self.assertEqual(test_source_range.start.column, 1)\n",
    "            self.assertEqual(test_source_range.end.line, 2)\n",
    "            self.assertEqual(test_source_range.end.column, 43)\n",
    "\n",
    "        test_file_dict_b = {'f':\n",
    "                            ('# start Ignoring bBear\\n',\n",
    "                             'b_string = \"This string should be ignored\"\\n',\n",
    "                             '# stop ignoring\\n')}\n",
    "        test_ignore_range_b = list(yield_ignore_ranges(test_file_dict_b))\n",
    "        for test_bears, test_source_range in test_ignore_range_b:\n",
    "            self.assertEqual(test_bears, ['bbear'])\n",
    "            self.assertEqual(test_source_range.start.line, 1)\n",
    "            self.assertEqual(test_source_range.start.column, 1)\n",
    "            self.assertEqual(test_source_range.end.line, 3)\n",
    "            self.assertEqual(test_source_range.end.column, 16)\n",
    "\n",
    "        test_file_dict_c = {'f':\n",
    "                            ('# Start ignoring cBear\\n',\n",
    "                             '# Stop ignoring cBear This & prev ignored\\n')}\n",
    "        test_ignore_range_c = list(yield_ignore_ranges(test_file_dict_c))\n",
    "        for test_bears, test_source_range in test_ignore_range_c:\n",
    "            self.assertEqual(test_bears, ['cbear'])\n",
    "            self.assertEqual(test_source_range.start.line, 1)\n",
    "            self.assertEqual(test_source_range.start.column, 1)\n",
    "            self.assertEqual(test_source_range.end.line, 2)\n",
    "            self.assertEqual(test_source_range.end.column, 42)\n",
    "\n",
    "        test_file_dict_d = {'f':\n",
    "                            ('# Start ignoring cBear\\n',\n",
    "                             'All of this ignored\\n')}\n",
    "        test_ignore_range_d = list(yield_ignore_ranges(test_file_dict_d))\n",
    "        for test_bears, test_source_range in test_ignore_range_d:\n",
    "            self.assertEqual(test_bears, ['cbear'])\n",
    "            self.assertEqual(test_source_range.start.line, 1)\n",
    "            self.assertEqual(test_source_range.start.column, 1)\n",
    "            self.assertEqual(test_source_range.end.line, 2)\n",
    "            self.assertEqual(test_source_range.end.column, 20)\n",
    "\n",
    "\n",
    "class ProcessingTest_GetDefaultActions(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.section = Section(\"X\")\n",
    "\n",
    "    def test_no_key(self):\n",
    "        self.assertEqual(get_default_actions(self.section), ({}, {}))\n",
    "\n",
    "    def test_no_value(self):\n",
    "        self.section.append(Setting(\"default_actions\", \"\"))\n",
    "        self.assertEqual(get_default_actions(self.section), ({}, {}))\n",
    "\n",
    "    def test_only_valid_actions(self):\n",
    "        self.section.append(Setting(\n",
    "            \"default_actions\",\n",
    "            \"MyBear: PrintDebugMessageAction, ValidBear: ApplyPatchAction\"))\n",
    "        self.assertEqual(\n",
    "            get_default_actions(self.section),\n",
    "            ({\"MyBear\": PrintDebugMessageAction,\n",
    "              \"ValidBear\": ApplyPatchAction},\n",
    "             {}))\n",
    "\n",
    "    def test_valid_and_invalid_actions(self):\n",
    "        self.section.append(Setting(\n",
    "            \"default_actions\",\n",
    "            \"MyBear: INVALID_action, ValidBear: ApplyPatchAction, XBear: ABC\"))\n",
    "        self.assertEqual(get_default_actions(self.section),\n",
    "                         ({\"ValidBear\": ApplyPatchAction},\n",
    "                          {\"MyBear\": \"INVALID_action\", \"XBear\": \"ABC\"}))\n",
    "\n",
    "\n",
    "class ProcessingTest_AutoapplyActions(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.log_queue = queue.Queue()\n",
    "        self.log_printer = ProcessingTestLogPrinter(self.log_queue)\n",
    "\n",
    "        self.resultY = Result(\"YBear\", \"msg1\")\n",
    "        self.resultZ = Result(\"ZBear\", \"msg2\")\n",
    "        self.results = [self.resultY, self.resultZ]\n",
    "        self.section = Section(\"A\")\n",
    "\n",
    "    def test_no_default_actions(self):\n",
    "        ret = autoapply_actions(self.results,\n",
    "                                {},\n",
    "                                {},\n",
    "                                self.section,\n",
    "                                self.log_printer)\n",
    "        self.assertEqual(ret, self.results)\n",
    "        self.assertTrue(self.log_queue.empty())\n",
    "\n",
    "    def test_with_invalid_action(self):\n",
    "        self.section.append(Setting(\"default_actions\",\n",
    "                                    \"XBear: nonSENSE_action\"))\n",
    "        ret = autoapply_actions(self.results,\n",
    "                                {},\n",
    "                                {},\n",
    "                                self.section,\n",
    "                                self.log_printer)\n",
    "        self.assertEqual(ret, self.results)\n",
    "        self.assertEqual(self.log_queue.get().message,\n",
    "                         \"Selected default action 'nonSENSE_action' for bear \"\n",
    "                         \"'XBear' does not exist. Ignoring action.\")\n",
    "        self.assertTrue(self.log_queue.empty())\n",
    "\n",
    "    def test_without_default_action_and_unapplicable(self):\n",
    "        # Use a result where no default action is supplied for and another one\n",
    "        # where the action is not applicable.\n",
    "        old_is_applicable = ApplyPatchAction.is_applicable\n",
    "        ApplyPatchAction.is_applicable = lambda *args: False\n",
    "\n",
    "        self.section.append(Setting(\n",
    "            \"default_actions\",\n",
    "            \"NoBear: ApplyPatchAction, YBear: ApplyPatchAction\"))\n",
    "        ret = autoapply_actions(self.results,\n",
    "                                {},\n",
    "                                {},\n",
    "                                self.section,\n",
    "                                self.log_printer)\n",
    "        self.assertEqual(ret, self.results)\n",
    "        self.assertEqual(self.log_queue.get().message,\n",
    "                         \"Selected default action 'ApplyPatchAction' for bear \"\n",
    "                         \"'YBear' is not applicable. Action not applied.\")\n",
    "        self.assertTrue(self.log_queue.empty())\n",
    "\n",
    "        ApplyPatchAction.is_applicable = old_is_applicable\n",
    "\n",
    "    def test_applicable_action(self):\n",
    "        # Use a result whose action can be successfully applied.\n",
    "        log_printer = self.log_printer\n",
    "\n",
    "        class TestAction(ResultAction):\n",
    "\n",
    "            def apply(self, *args, **kwargs):\n",
    "                log_printer.debug(\"ACTION APPLIED SUCCESSFULLY.\")\n",
    "\n",
    "        ACTIONS.append(TestAction)\n",
    "\n",
    "        self.section.append(Setting(\"default_actions\", \"ZBear: TestAction\"))\n",
    "        ret = autoapply_actions(self.results,\n",
    "                                {},\n",
    "                                {},\n",
    "                                self.section,\n",
    "                                log_printer)\n",
    "        self.assertEqual(ret, [self.resultY])\n",
    "        self.assertEqual(self.log_queue.get().message,\n",
    "                         \"ACTION APPLIED SUCCESSFULLY.\")\n",
    "        self.assertEqual(self.log_queue.get().message,\n",
    "                         \"Applied 'TestAction' \"\n",
    "                         \"on the whole project from 'ZBear'.\")\n",
    "        self.assertTrue(self.log_queue.empty())\n",
    "\n",
    "        ACTIONS.pop()\n",
    "\n",
    "    def test_failing_action(self):\n",
    "        class FailingTestAction(ResultAction):\n",
    "\n",
    "            def apply(self, *args, **kwargs):\n",
    "                raise RuntimeError(\"YEAH THAT'S A FAILING BEAR\")\n",
    "\n",
    "        ACTIONS.append(FailingTestAction)\n",
    "\n",
    "        self.section.append(Setting(\"default_actions\",\n",
    "                                    \"YBear: FailingTestAction\"))\n",
    "        ret = autoapply_actions(self.results,\n",
    "                                {},\n",
    "                                {},\n",
    "                                self.section,\n",
    "                                self.log_printer)\n",
    "        self.assertEqual(ret, self.results)\n",
    "        self.assertEqual(self.log_queue.get().message,\n",
    "                         \"Failed to execute action 'FailingTestAction'\"\n",
    "                         \" with error: YEAH THAT'S A FAILING BEAR.\")\n",
    "        self.assertIn(\"YEAH THAT'S A FAILING BEAR\",\n",
    "                      self.log_queue.get().message)\n",
    "        self.assertEqual(self.log_queue.get().message,\n",
    "                         \"-> for result \" + repr(self.resultY) + \".\")\n",
    "        self.assertTrue(self.log_queue.empty())\n",
    "\n",
    "        ACTIONS.pop()\n",
    "\n",
    "\n",
    "class ProcessingTest_PrintResult(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.section = Section('name')\n",
    "        self.log_printer = LogPrinter(ConsolePrinter(), log_level=0)\n",
    "\n",
    "    def test_autoapply_override(self):\n",
    "        \"\"\"\n",
    "        Tests that the default_actions aren't automatically applied when the\n",
    "        autoapply setting overrides that.\n",
    "        \"\"\"\n",
    "        self.section.append(Setting('default_actions',\n",
    "                                    'somebear: PrintDebugMessageAction'))\n",
    "\n",
    "        # Verify that it would apply the action, i.e. remove the result\n",
    "        results = [5, HiddenResult('origin', []),\n",
    "                   Result('somebear', 'message', debug_msg='debug')]\n",
    "        retval, newres = print_result(results, {}, 0, lambda *args: None,\n",
    "                                      self.section, self.log_printer, {}, [])\n",
    "        self.assertEqual(newres, [])\n",
    "\n",
    "        # Override and verify that result is unprocessed, i.e. not gone\n",
    "        self.section.append(Setting('autoapply', 'false'))\n",
    "        retval, newres = print_result(results, {}, 0, lambda *args: None,\n",
    "                                      self.section, self.log_printer, {}, [])\n",
    "        self.assertNotEqual(newres, [])\n"
  ],
  "/home/tushar/coala/tests/processes/__init__.py": [],
  "/home/tushar/coala/tests/processes/communication/LogMessageTest.py": [
    "import unittest\n",
    "from datetime import datetime\n",
    "\n",
    "from coalib.misc import Constants\n",
    "from coalib.output.printers.LOG_LEVEL import LOG_LEVEL\n",
    "from coalib.processes.communication.LogMessage import LogMessage\n",
    "\n",
    "\n",
    "class LogMessageTest(unittest.TestCase):\n",
    "    timestamp = datetime.today()\n",
    "\n",
    "    def setUp(self):\n",
    "        self.uut = LogMessage(LOG_LEVEL.DEBUG,\n",
    "                              \"test\",\n",
    "                              \"message\",\n",
    "                              timestamp=self.timestamp)\n",
    "\n",
    "    def test_construction(self):\n",
    "        # take a look if defaults are good\n",
    "        self.assertEqual(self.uut.log_level, LOG_LEVEL.DEBUG)\n",
    "        self.assertEqual(self.uut.message, \"test message\")\n",
    "        self.assertEqual(self.uut.timestamp, self.timestamp)\n",
    "\n",
    "        # see that arguments are processed right\n",
    "        self.uut = LogMessage(LOG_LEVEL.WARNING,\n",
    "                              \"   a msg  \",\n",
    "                              5,\n",
    "                              \"  \",\n",
    "                              timestamp=self.timestamp)\n",
    "        self.assertEqual(self.uut.log_level, LOG_LEVEL.WARNING)\n",
    "        self.assertEqual(self.uut.message, \"   a msg   5\")\n",
    "        self.assertEqual(self.uut.timestamp, self.timestamp)\n",
    "\n",
    "        self.assertRaises(ValueError, LogMessage, LOG_LEVEL.DEBUG, \"\")\n",
    "        self.assertRaises(ValueError, LogMessage, 5, \"test\")\n",
    "\n",
    "    def test_to_str(self):\n",
    "        self.uut.message = Constants.COMPLEX_TEST_STRING\n",
    "        self.uut.log_level = LOG_LEVEL.ERROR\n",
    "        self.assertEqual(str(self.uut),\n",
    "                         \"[{}] {}\".format(\"ERROR\",\n",
    "                                          Constants.COMPLEX_TEST_STRING))\n",
    "        self.uut.log_level = LOG_LEVEL.WARNING\n",
    "        self.assertEqual(str(self.uut),\n",
    "                         \"[{}] {}\".format(\"WARNING\",\n",
    "                                          Constants.COMPLEX_TEST_STRING))\n",
    "        self.uut.log_level = LOG_LEVEL.DEBUG\n",
    "        self.assertEqual(str(self.uut),\n",
    "                         \"[{}] {}\".format(\"DEBUG\",\n",
    "                                          Constants.COMPLEX_TEST_STRING))\n",
    "        self.uut.log_level = 5\n",
    "        self.assertEqual(str(self.uut),\n",
    "                         \"[{}] {}\".format(\"ERROR\",\n",
    "                                          Constants.COMPLEX_TEST_STRING))\n",
    "\n",
    "    def test_equals(self):\n",
    "        self.assertEqual(LogMessage(LOG_LEVEL.DEBUG, \"test message\"),\n",
    "                         LogMessage(LOG_LEVEL.DEBUG, \"test message\"))\n",
    "        self.assertNotEqual(LogMessage(LOG_LEVEL.DEBUG, \"test message\"),\n",
    "                            LogMessage(LOG_LEVEL.WARNING, \"test message\"))\n",
    "        self.assertNotEqual(LogMessage(LOG_LEVEL.DEBUG, \"test message\"),\n",
    "                            LogMessage(LOG_LEVEL.DEBUG, \"test\"))\n",
    "        self.assertNotEqual(LogMessage(LOG_LEVEL.DEBUG, \"test message\"), 5)\n",
    "\n",
    "    def test_string_dict(self):\n",
    "        self.uut.log_level = LOG_LEVEL.DEBUG\n",
    "        self.uut.message = \"test\"\n",
    "        self.assertEqual(\n",
    "            self.uut.to_string_dict(),\n",
    "            {\"log_level\": \"DEBUG\",\n",
    "             \"message\": \"test\",\n",
    "             \"timestamp\": self.timestamp.isoformat()})\n",
    "\n",
    "        self.uut.timestamp = None\n",
    "        self.uut.log_level = -9999  # invalid level\n",
    "        self.assertEqual(\n",
    "            self.uut.to_string_dict(),\n",
    "            {\"log_level\": \"\", \"message\": \"test\", \"timestamp\": \"\"})\n"
  ],
  "/home/tushar/coala/tests/processes/communication/__init__.py": [],
  "/home/tushar/coala/tests/processes/section_executor_test_files/ProcessingGlobalTestBear.py": [
    "from coalib.bears.GlobalBear import GlobalBear\n",
    "from coalib.results.Result import Result\n",
    "\n",
    "\n",
    "class ProcessingGlobalTestBear(GlobalBear):  # pragma: no cover\n",
    "\n",
    "    def run(self):\n",
    "        for filename in self.file_dict:\n",
    "            return [Result.from_values(\"GlobalTestBear\",\n",
    "                                       \"test message\",\n",
    "                                       filename)]\n"
  ],
  "/home/tushar/coala/tests/processes/section_executor_test_files/ProcessingLocalTestBear.py": [
    "import time\n",
    "\n",
    "from coalib.bears.LocalBear import LocalBear\n",
    "from coalib.results.Result import Result\n",
    "\n",
    "\n",
    "class ProcessingLocalTestBear(LocalBear):  # pragma: no cover\n",
    "\n",
    "    def run(self, filename, file):\n",
    "        # we need to test that the SectionExecutor holds back the global\n",
    "        # results until processing of all local ones is finished\n",
    "        time.sleep(0.05)\n",
    "        return [Result(\"LocalTestBear\", \"test msg\")]\n"
  ],
  "/home/tushar/coala/tests/results/AbsolutePositionTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.results.AbsolutePosition import AbsolutePosition, calc_line_col\n",
    "from coalib.misc.Constants import COMPLEX_TEST_STRING\n",
    "\n",
    "\n",
    "class AbsolutePositionTest(unittest.TestCase):\n",
    "\n",
    "    def test_calc_line_col_newlines(self):\n",
    "        # no newlines\n",
    "        text = (\"find position of 'z'\",)\n",
    "        z_pos = text[0].find('z')\n",
    "        self.assertEqual(\n",
    "                calc_line_col(text, z_pos), (1, z_pos + 1))\n",
    "\n",
    "        # newline\n",
    "        text = (\"find position of\\n\", \"'z'\",)\n",
    "        string_text = ''.join(text)\n",
    "        z_pos = string_text.find('z')\n",
    "        self.assertEqual(calc_line_col(text, z_pos), (2, 2))\n",
    "\n",
    "    def test_calc_line_col_unicode(self):\n",
    "        uni_pos = COMPLEX_TEST_STRING.find(\"\u2191\")\n",
    "        self.assertEqual(\n",
    "                calc_line_col((COMPLEX_TEST_STRING,), uni_pos),\n",
    "                (1, uni_pos + 1))\n",
    "\n",
    "    def test_calc_line_col_rawstrings(self):\n",
    "        for raw in [(r'a\\b',), (r'a\\n',), ('a\\\\n',)]:\n",
    "            pos = raw[0].find(raw[0][-1])\n",
    "            self.assertEqual(calc_line_col(raw, pos), (1, 3))\n",
    "\n",
    "    def test_calc_line_col_extremes(self):\n",
    "        # End of Line\n",
    "        text = (\"Fitst Line\\n\", \"End of sencond line z\")\n",
    "        string_text = ''.join(text)\n",
    "        z_pos = string_text.find('z')\n",
    "        self.assertEqual(calc_line_col(text, z_pos),\n",
    "                         (2, len(text[1])))\n",
    "\n",
    "        # Out of text\n",
    "        with self.assertRaises(ValueError):\n",
    "            text = (\"Some line\")\n",
    "            calc_line_col(text, 50)\n",
    "\n",
    "        # start of line\n",
    "        text = (\"First Line\\n\", \"zEnd of sencond line\")\n",
    "        string_text = ''.join(text)\n",
    "        z_pos = string_text.find('z')\n",
    "        self.assertEqual(calc_line_col(text, z_pos), (2, 1))\n",
    "\n",
    "    def test_property(self):\n",
    "        uut = AbsolutePosition((\"1\", \"2\"), 1)\n",
    "        self.assertEqual(uut.position, 1)\n",
    "        self.assertEqual(uut.line, 2)\n",
    "        self.assertEqual(uut.column, 1)\n",
    "\n",
    "        uut = AbsolutePosition()\n",
    "        self.assertEqual(uut.position, None)\n",
    "        self.assertEqual(uut.line, None)\n",
    "        self.assertEqual(uut.column, None)\n",
    "\n",
    "        uut = AbsolutePosition((\"a\\n\", \"b\\n\"), 0)\n",
    "        self.assertEqual(uut.position, 0)\n",
    "        self.assertEqual(uut.line, 1)\n",
    "        self.assertEqual(uut.column, 1)\n",
    "\n",
    "    def test_instantiation(self):\n",
    "        with self.assertRaises(ValueError):\n",
    "            uut = AbsolutePosition((), 0)\n",
    "\n",
    "        uut = AbsolutePosition(position=5)\n",
    "        self.assertEqual(uut.position, 5)\n",
    "        self.assertEqual(uut.line, None)\n",
    "        self.assertEqual(uut.column, None)\n"
  ],
  "/home/tushar/coala/tests/results/DiffTest.py": [
    "import json\n",
    "import unittest\n",
    "from unittest.case import SkipTest\n",
    "\n",
    "from coalib.output.JSONEncoder import create_json_encoder\n",
    "from coalib.results.Diff import ConflictError, Diff, SourceRange\n",
    "\n",
    "\n",
    "class DiffTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.file = [\"1\", \"2\", \"3\", \"4\"]\n",
    "        self.uut = Diff(self.file)\n",
    "\n",
    "    def test_add_lines(self):\n",
    "        self.uut.add_lines(0, [])\n",
    "        self.uut.add_lines(0, [\"t\"])\n",
    "        self.uut.add_lines(0, [])\n",
    "\n",
    "        # No double addition allowed\n",
    "        self.assertRaises(ConflictError, self.uut.add_lines, 0, [\"t\"])\n",
    "        self.assertRaises(ValueError, self.uut.add_lines, -1, [\"t\"])\n",
    "        self.assertRaises(TypeError, self.uut.add_lines, \"str\", [\"t\"])\n",
    "\n",
    "    def test_delete_line(self):\n",
    "        self.uut.delete_line(1)\n",
    "        self.uut.delete_line(1)  # Double deletion possible without conflict\n",
    "        self.assertRaises(ValueError, self.uut.delete_line, 0)\n",
    "\n",
    "    def test_change_line(self):\n",
    "        self.assertEqual(len(self.uut), 0)\n",
    "        self.uut.change_line(2, \"1\", \"2\")\n",
    "        self.assertEqual(len(self.uut), 2)\n",
    "        self.assertRaises(ConflictError, self.uut.change_line, 2, \"1\", \"3\")\n",
    "        self.assertRaises(ValueError, self.uut.change_line, 0, \"1\", \"2\")\n",
    "\n",
    "        self.uut.delete_line(1)\n",
    "        # Line was deleted, unchangeable\n",
    "        self.assertRaises(ConflictError, self.uut.change_line, 1, \"1\", \"2\")\n",
    "\n",
    "    def test_affected_code(self):\n",
    "        self.assertEqual(self.uut.affected_code(\"file\"), [])\n",
    "\n",
    "        self.uut.add_lines(0, [\"test\"])\n",
    "        affected_code = [\n",
    "            SourceRange.from_values(\"file\", start_line=1)]\n",
    "        self.assertEqual(self.uut.affected_code(\"file\"), affected_code)\n",
    "\n",
    "        self.uut.delete_line(2)\n",
    "        affected_code = [\n",
    "            SourceRange.from_values(\"file\", start_line=1),\n",
    "            SourceRange.from_values(\"file\", start_line=2)]\n",
    "        self.assertEqual(self.uut.affected_code(\"file\"), affected_code)\n",
    "\n",
    "        self.uut.delete_line(3)\n",
    "        affected_code = [\n",
    "            SourceRange.from_values(\"file\", start_line=1),\n",
    "            SourceRange.from_values(\"file\", start_line=2, end_line=3)]\n",
    "        self.assertEqual(self.uut.affected_code(\"file\"), affected_code)\n",
    "\n",
    "        self.uut.delete_line(6)\n",
    "        affected_code = [\n",
    "            SourceRange.from_values(\"file\", start_line=1),\n",
    "            SourceRange.from_values(\"file\", start_line=2, end_line=3),\n",
    "            SourceRange.from_values('file', start_line=6)]\n",
    "        self.assertEqual(self.uut.affected_code(\"file\"), affected_code)\n",
    "\n",
    "    def test_len(self):\n",
    "        self.uut.delete_line(2)\n",
    "        self.assertEqual(len(self.uut), 1)\n",
    "        self.uut.add_lines(2, [\"2.3\", \"2.5\", \"2.6\"])\n",
    "        self.assertEqual(len(self.uut), 4)\n",
    "        self.uut.change_line(1, \"1\", \"1.1\")\n",
    "        self.assertEqual(len(self.uut), 6)\n",
    "\n",
    "    def test_stats(self):\n",
    "        self.uut.delete_line(2)\n",
    "        self.assertEqual(self.uut.stats(), (0, 1))\n",
    "        self.uut.add_lines(2, [\"2.3\", \"2.5\", \"2.6\"])\n",
    "        self.assertEqual(self.uut.stats(), (3, 1))\n",
    "        self.uut.change_line(1, \"1\", \"1.1\")\n",
    "        self.assertEqual(self.uut.stats(), (4, 2))\n",
    "\n",
    "    def test_modified(self):\n",
    "        result_file = [\"0.1\",\n",
    "                       \"0.2\",\n",
    "                       \"1\",\n",
    "                       \"1.1\",\n",
    "                       \"3.changed\",\n",
    "                       \"4\"]\n",
    "\n",
    "        self.uut.delete_line(2)\n",
    "        self.uut.add_lines(0, [\"0.1\", \"0.2\"])\n",
    "        self.uut.add_lines(1, [\"1.1\"])\n",
    "        self.uut.change_line(3, \"3\", \"3.changed\")\n",
    "\n",
    "        self.assertEqual(self.uut.modified, result_file)\n",
    "        self.assertEqual(self.uut.original, self.file)\n",
    "\n",
    "        self.uut.delete_line(len(self.file))\n",
    "        del result_file[len(result_file) - 1]\n",
    "        self.assertEqual(self.uut.modified, result_file)\n",
    "\n",
    "        self.uut.delete_line(1)\n",
    "        del result_file[2]\n",
    "        self.assertEqual(self.uut.modified, result_file)\n",
    "\n",
    "    def test_addition(self):\n",
    "        self.assertRaises(TypeError, self.uut.__add__, 5)\n",
    "\n",
    "        result_file = [\"1\",\n",
    "                       \"2\",\n",
    "                       \"2\"]\n",
    "\n",
    "        other = Diff(self.file)\n",
    "        other.delete_line(1)\n",
    "        other.change_line(2, \"1\", \"2\")\n",
    "        other.add_lines(0, [\"1\"])\n",
    "\n",
    "        self.uut.delete_line(1)\n",
    "        self.uut.delete_line(3)\n",
    "        self.uut.change_line(4, \"4\", \"2\")\n",
    "        result = self.uut + other\n",
    "\n",
    "        self.assertEqual(result.modified, result_file)\n",
    "        # Make sure it didn't happen in place!\n",
    "        self.assertNotEqual(self.uut.modified, result_file)\n",
    "\n",
    "    def test_addition_rename(self):\n",
    "        uut = Diff(self.file, rename=False)\n",
    "        other = Diff(self.file, rename=False)\n",
    "        self.assertEqual((other + uut).rename, False)\n",
    "\n",
    "        other.rename = \"some.py\"\n",
    "        self.assertEqual((other + uut).rename, \"some.py\")\n",
    "\n",
    "        uut.rename = \"some.py\"\n",
    "        self.assertEqual((other + uut).rename, \"some.py\")\n",
    "\n",
    "        uut.rename = \"other.py\"\n",
    "        self.assertRaises(ConflictError, other.__add__, uut)\n",
    "\n",
    "    def test_from_string_arrays(self):\n",
    "        a = [\"q\", \"a\", \"b\", \"x\", \"c\", \"d\"]\n",
    "        b = [\"a\", \"b\", \"y\", \"c\", \"d\", \"f\"]\n",
    "        self.uut = Diff.from_string_arrays(a, b)\n",
    "        self.assertEqual(self.uut.modified, b)\n",
    "\n",
    "        a = [\"first\", \"fourth\"]\n",
    "        b = [\"first\", \"second\", \"third\", \"fourth\"]\n",
    "        self.uut = Diff.from_string_arrays(a, b)\n",
    "        self.assertEqual(self.uut.modified, b)\n",
    "\n",
    "        a = [\"first\", \"fourth\"]\n",
    "        b = [\"first_changed\", \"second\", \"third\", \"fourth\"]\n",
    "        self.uut = Diff.from_string_arrays(a, b)\n",
    "        self.assertEqual(self.uut.modified, b)\n",
    "\n",
    "        a = [\"first\", \"second\", \"third\", \"fourth\"]\n",
    "        b = [\"first\", \"fourth\"]\n",
    "        self.uut = Diff.from_string_arrays(a, b)\n",
    "        self.assertEqual(self.uut.modified, b)\n",
    "\n",
    "        a = [\"first\", \"second\", \"third\", \"fourth\"]\n",
    "        b = [\"first_changed\", \"second_changed\", \"fourth\"]\n",
    "        self.uut = Diff.from_string_arrays(a, b)\n",
    "        self.assertEqual(self.uut.modified, b)\n",
    "\n",
    "    def test_from_clang_fixit(self):\n",
    "        try:\n",
    "            from clang.cindex import Index, LibclangError\n",
    "        except ImportError as err:\n",
    "            raise SkipTest(str(err))\n",
    "\n",
    "        joined_file = 'struct { int f0; }\\nx = { f0 :1 };\\n'\n",
    "        file = joined_file.splitlines(True)\n",
    "        fixed_file = ['struct { int f0; }\\n', 'x = { .f0 = 1 };\\n']\n",
    "        try:\n",
    "            tu = Index.create().parse('t.c', unsaved_files=[\n",
    "                ('t.c', joined_file)])\n",
    "        except LibclangError as err:\n",
    "            raise SkipTest(str(err))\n",
    "\n",
    "        fixit = tu.diagnostics[0].fixits[0]\n",
    "        clang_fixed_file = Diff.from_clang_fixit(fixit, file).modified\n",
    "        self.assertEqual(fixed_file, clang_fixed_file)\n",
    "\n",
    "    def test_equality(self):\n",
    "        a = [\"first\", \"second\", \"third\"]\n",
    "        b = [\"first\", \"third\"]\n",
    "        diff_1 = Diff.from_string_arrays(a, b)\n",
    "\n",
    "        a[1] = \"else\"\n",
    "        diff_2 = Diff.from_string_arrays(a, b)\n",
    "        self.assertEqual(diff_1, diff_2)\n",
    "\n",
    "        diff_1.rename = \"abcd\"\n",
    "        self.assertNotEqual(diff_1, diff_2)\n",
    "        diff_1.rename = False\n",
    "\n",
    "        diff_1.delete = True\n",
    "        self.assertNotEqual(diff_1, diff_2)\n",
    "        diff_1.delete = False\n",
    "\n",
    "        diff_1.add_lines(1, [\"1\"])\n",
    "        self.assertNotEqual(diff_1, diff_2)\n",
    "\n",
    "    def test_json_export(self):\n",
    "        JSONEncoder = create_json_encoder()\n",
    "        a = [\"first\\n\", \"second\\n\", \"third\\n\"]\n",
    "        b = [\"first\\n\", \"third\\n\"]\n",
    "        diff = Diff.from_string_arrays(a, b)\n",
    "        self.assertEqual(\n",
    "            json.dumps(diff, cls=JSONEncoder, sort_keys=True),\n",
    "            '\"--- \\\\n'\n",
    "            '+++ \\\\n'\n",
    "            '@@ -1,3 +1,2 @@\\\\n'\n",
    "            ' first\\\\n'\n",
    "            '-second\\\\n'\n",
    "            ' third\\\\n\"')\n",
    "\n",
    "    def test_rename(self):\n",
    "        self.uut.rename = False\n",
    "        self.uut.rename = \"1234\"\n",
    "        with self.assertRaises(TypeError):\n",
    "            self.uut.rename = True\n",
    "        with self.assertRaises(TypeError):\n",
    "            self.uut.rename = 1234\n",
    "\n",
    "    def test_delete(self):\n",
    "        self.uut.delete = True\n",
    "        self.uut.delete = False\n",
    "        # Double deletion is allowed\n",
    "        self.uut.delete = False\n",
    "        with self.assertRaises(TypeError):\n",
    "            self.uut.delete = \"abcd\"\n",
    "\n",
    "        # If delete is True then modified returns an empty list\n",
    "        self.uut.delete = True\n",
    "        self.assertEqual(self.uut.modified, [])\n",
    "        self.uut.delete = False\n"
  ],
  "/home/tushar/coala/tests/results/EnsureFilesPresentTest.py": [
    "import unittest\n",
    "from os.path import abspath\n",
    "\n",
    "from coalib.results.ResultFilter import ensure_files_present\n",
    "\n",
    "\n",
    "class EnsureFilesPresentTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.maxDiff = None\n",
    "\n",
    "    def test_removed_file(self):\n",
    "        test_file = [\"abc\"]\n",
    "        test_file_dict = {\"test_file\": test_file}\n",
    "        test_mod_file_dict = {}\n",
    "\n",
    "        ensure_files_present(test_file_dict, test_mod_file_dict)\n",
    "\n",
    "        self.assertEqual(\n",
    "            test_mod_file_dict,\n",
    "            {\"test_file\": []})\n",
    "\n",
    "    def test_added_file(self):\n",
    "        test_file = [\"abc\"]\n",
    "        test_file_dict = {}\n",
    "        test_mod_file_dict = {\"test_file\": test_file}\n",
    "\n",
    "        ensure_files_present(test_file_dict, test_mod_file_dict)\n",
    "\n",
    "        self.assertEqual(\n",
    "            test_file_dict,\n",
    "            {\"test_file\": []})\n",
    "\n",
    "    def test_file_renaming(self):\n",
    "        testfile_1 = ['1\\n', '2\\n']\n",
    "        testfile_2 = ['3\\n', '4\\n', '5\\n']\n",
    "\n",
    "        tf1 = abspath('tf1')\n",
    "        tf2 = abspath('tf2')\n",
    "        tf1_new = abspath('tf1_new')\n",
    "\n",
    "        original_file_dict = {tf1: testfile_1, tf2: testfile_2}\n",
    "        modified_file_dict = {tf1_new: testfile_1}\n",
    "\n",
    "        renamed_files = ensure_files_present(original_file_dict,\n",
    "                                             modified_file_dict)\n",
    "\n",
    "        self.assertEqual({tf1: tf1_new}, renamed_files)\n",
    "\n",
    "    def test_file_deletion(self):\n",
    "        testfile_1 = ['1\\n', '2\\n']\n",
    "        testfile_2 = ['3\\n', '4\\n', '5\\n']\n",
    "\n",
    "        tf1 = abspath('tf1')\n",
    "        tf2 = abspath('tf2')\n",
    "\n",
    "        original_file_dict = {tf1: testfile_1, tf2: testfile_2}\n",
    "        modified_file_dict = {tf1: testfile_1}\n",
    "\n",
    "        renamed_files = ensure_files_present(original_file_dict,\n",
    "                                             modified_file_dict)\n",
    "\n",
    "        self.assertEqual({}, renamed_files)\n",
    "\n",
    "    def test_file_renaming_changed_file(self):\n",
    "        testfile_1 = ['1\\n', '2\\n']\n",
    "        testfile_2 = ['3\\n', '4\\n', '5\\n']\n",
    "\n",
    "        tf1 = abspath('tf1')\n",
    "        tf2 = abspath('tf2')\n",
    "\n",
    "        testfile_2_new = ['6\\n', '4\\n', '5\\n']\n",
    "        tf2_new = abspath('tf2_new')\n",
    "\n",
    "        original_file_dict = {tf1: testfile_1, tf2: testfile_2}\n",
    "        modified_file_dict = {tf2_new: testfile_2_new}\n",
    "\n",
    "        renamed_files = ensure_files_present(original_file_dict,\n",
    "                                             modified_file_dict)\n",
    "\n",
    "        self.assertEqual({tf2: tf2_new}, renamed_files)\n",
    "\n",
    "    def test_file_addition_deletion_similar_files(self):\n",
    "        testfile_1 = ['1\\n', '2\\n']\n",
    "        testfile_2 = ['3\\n', '4\\n', '5\\n']\n",
    "\n",
    "        tf1 = abspath('tf1')\n",
    "        tf2 = abspath('tf2')\n",
    "\n",
    "        testfile_2_new = ['3\\n']\n",
    "        tf2_new = abspath('tf2_new')\n",
    "\n",
    "        original_file_dict = {tf1: testfile_1, tf2: testfile_2}\n",
    "        modified_file_dict = {tf2_new: testfile_2_new}\n",
    "\n",
    "        renamed_files = ensure_files_present(original_file_dict,\n",
    "                                             modified_file_dict)\n",
    "\n",
    "        self.assertEqual({}, renamed_files)\n",
    "\n",
    "        testfile_1 = ['1\\n', '2\\n']\n",
    "        testfile_2 = ['3\\n', '4\\n', '5\\n']\n",
    "\n",
    "        tf1 = abspath('tf1')\n",
    "        tf2 = abspath('tf2')\n",
    "\n",
    "        testfile_2_new = ['1\\n', '2\\n', '0\\n', '1\\n', '2\\n', '1\\n', '2\\n']\n",
    "        tf2_new = abspath('tf2_new')\n",
    "\n",
    "        original_file_dict = {tf1: testfile_1, tf2: testfile_2}\n",
    "        modified_file_dict = {tf2_new: testfile_2_new}\n",
    "\n",
    "        renamed_files = ensure_files_present(original_file_dict,\n",
    "                                             modified_file_dict)\n",
    "\n",
    "        self.assertEqual({}, renamed_files)\n"
  ],
  "/home/tushar/coala/tests/results/HiddenResultTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.results.HiddenResult import HiddenResult\n",
    "\n",
    "\n",
    "class HiddenResultTest(unittest.TestCase):\n",
    "\n",
    "    def test_hidden_result(self):\n",
    "        uut = HiddenResult(\"any\", \"anything\")\n",
    "        self.assertEqual(uut.contents, \"anything\")\n"
  ],
  "/home/tushar/coala/tests/results/LineDiffTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.results.LineDiff import LineDiff, ConflictError\n",
    "\n",
    "\n",
    "class LineDiffTest(unittest.TestCase):\n",
    "\n",
    "    def test_everything(self):\n",
    "        self.assertRaises(TypeError, LineDiff, delete=5)\n",
    "        self.assertRaises(TypeError, LineDiff, change=5)\n",
    "        self.assertRaises(TypeError, LineDiff, add_after=5)\n",
    "        self.assertRaises(TypeError, LineDiff, change=True)\n",
    "        self.assertRaises(TypeError, LineDiff, add_after=True)\n",
    "        self.assertRaises(ConflictError,\n",
    "                          LineDiff,\n",
    "                          change=(\"1\", \"2\"),\n",
    "                          delete=True)\n",
    "\n",
    "        self.assertEqual(LineDiff(change=(\"1\", \"2\")).change, (\"1\", \"2\"))\n",
    "        self.assertEqual(LineDiff(delete=True).delete, True)\n",
    "        self.assertEqual(LineDiff(add_after=[]).add_after, False)\n",
    "        self.assertEqual(LineDiff(add_after=[\"t\"]).add_after, [\"t\"])\n",
    "        self.assertEqual(LineDiff(add_after=(\"t\",)).add_after, [\"t\"])\n",
    "\n",
    "        uut = LineDiff()\n",
    "        uut.delete = True\n",
    "        self.assertRaises(ConflictError, setattr, uut, \"change\", (\"1\", \"2\"))\n",
    "        uut.delete = False\n",
    "        uut.change = (\"1\", \"2\")\n",
    "        self.assertRaises(ConflictError, setattr, uut, \"delete\", True)\n",
    "\n",
    "    def test_equality(self):\n",
    "        self.assertEqual(LineDiff(), LineDiff())\n",
    "        self.assertNotEqual(LineDiff(), LineDiff(delete=True))\n",
    "        self.assertNotEqual(LineDiff(add_after=['']), LineDiff())\n",
    "        self.assertNotEqual(LineDiff(add_after=['']), LineDiff(delete=True))\n",
    "        self.assertNotEqual(LineDiff(change=('', 'a')), LineDiff())\n"
  ],
  "/home/tushar/coala/tests/results/RESULT_SEVERITYTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.results.RESULT_SEVERITY import RESULT_SEVERITY\n",
    "\n",
    "\n",
    "class RESULT_SEVERITYTest(unittest.TestCase):\n",
    "\n",
    "    def test_str_conversion(self):\n",
    "        self.assertEqual(\"INFO\",\n",
    "                         RESULT_SEVERITY.__str__(RESULT_SEVERITY.INFO))\n",
    "        self.assertEqual(\"NORMAL\",\n",
    "                         RESULT_SEVERITY.__str__(RESULT_SEVERITY.NORMAL))\n",
    "        self.assertEqual(\"MAJOR\",\n",
    "                         RESULT_SEVERITY.__str__(RESULT_SEVERITY.MAJOR))\n"
  ],
  "/home/tushar/coala/tests/results/ResultFilterTest.py": [
    "import os\n",
    "import unittest\n",
    "from os.path import abspath\n",
    "\n",
    "from coalib.results.Diff import Diff\n",
    "from coalib.results.Result import RESULT_SEVERITY, Result\n",
    "from coalib.results.ResultFilter import (\n",
    "    filter_results,\n",
    "    remove_range,\n",
    "    remove_result_ranges_diffs)\n",
    "from coalib.results.SourceRange import SourceRange\n",
    "\n",
    "\n",
    "class ResultFilterTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.maxDiff = None\n",
    "        result_filter_test_dir = os.path.join(os.path.split(__file__)[0],\n",
    "                                              'ResultFilterTestFiles')\n",
    "        self.original_file_name = os.path.join(result_filter_test_dir,\n",
    "                                               'original_file.txt')\n",
    "        self.modified_file_name = os.path.join(result_filter_test_dir,\n",
    "                                               'modified_file.txt')\n",
    "\n",
    "    def test_simple_cases(self):\n",
    "        class Origin:\n",
    "            pass\n",
    "\n",
    "        origin_instance = Origin()\n",
    "\n",
    "        original_result = Result.from_values(origin=origin_instance,\n",
    "                                             message=\"original\",\n",
    "                                             file=\"original\",\n",
    "                                             severity=RESULT_SEVERITY.NORMAL,\n",
    "                                             debug_msg=\"original\")\n",
    "\n",
    "        clone_result = Result.from_values(origin=\"Origin\",\n",
    "                                          message=\"original\",\n",
    "                                          file=\"original\",\n",
    "                                          severity=RESULT_SEVERITY.NORMAL,\n",
    "                                          debug_msg=\"original\")\n",
    "\n",
    "        wrong_origin_result = Result.from_values(\n",
    "            origin=\"AnotherOrigin\",\n",
    "            message=\"original\",\n",
    "            file=\"original\",\n",
    "            severity=RESULT_SEVERITY.NORMAL,\n",
    "            debug_msg=\"original\")\n",
    "\n",
    "        wrong_message_result = Result.from_values(\n",
    "            origin=\"Origin\",\n",
    "            message=\"another message\",\n",
    "            file=\"original\",\n",
    "            severity=RESULT_SEVERITY.NORMAL,\n",
    "            debug_msg=\"original\")\n",
    "\n",
    "        wrong_severity_result = Result.from_values(\n",
    "            origin=\"Origin\",\n",
    "            message=\"original\",\n",
    "            file=\"original\",\n",
    "            severity=RESULT_SEVERITY.INFO,\n",
    "            debug_msg=\"original\")\n",
    "\n",
    "        wrong_debug_msg_result = Result.from_values(\n",
    "            origin=\"Origin\",\n",
    "            message=\"original\",\n",
    "            file=\"original\",\n",
    "            severity=RESULT_SEVERITY.NORMAL,\n",
    "            debug_msg=\"another debug message\")\n",
    "\n",
    "        file_dict = {abspath(\"original\"): []}\n",
    "\n",
    "        self.assertEqual(sorted(filter_results(original_file_dict=file_dict,\n",
    "                                               modified_file_dict=file_dict,\n",
    "                                               original_results=[\n",
    "                                                   original_result],\n",
    "                                               modified_results=[\n",
    "                                                   clone_result,\n",
    "                                                   wrong_origin_result,\n",
    "                                                   wrong_message_result,\n",
    "                                                   wrong_severity_result,\n",
    "                                                   wrong_debug_msg_result])),\n",
    "                         sorted([wrong_origin_result,\n",
    "                                 wrong_message_result,\n",
    "                                 wrong_severity_result,\n",
    "                                 wrong_debug_msg_result]))\n",
    "\n",
    "    def test_affected_code(self):\n",
    "\n",
    "        # ORIGINAL SOURCE RANGES:\n",
    "        sr0_pre_change = SourceRange.from_values(\"file_name\",\n",
    "                                                 start_line=4,\n",
    "                                                 start_column=1,\n",
    "                                                 end_line=4,\n",
    "                                                 end_column=6)\n",
    "        sr0_change = SourceRange.from_values(\"file_name\",\n",
    "                                             start_line=4,\n",
    "                                             start_column=8,\n",
    "                                             end_line=4,\n",
    "                                             end_column=13)\n",
    "        sr0_post_change = SourceRange.from_values(\"file_name\",\n",
    "                                                  start_line=4,\n",
    "                                                  start_column=15,\n",
    "                                                  end_line=4,\n",
    "                                                  end_column=19)\n",
    "\n",
    "        sr0_pre_remove = SourceRange.from_values(\"file_name\",\n",
    "                                                 start_line=6,\n",
    "                                                 start_column=1,\n",
    "                                                 end_line=6,\n",
    "                                                 end_column=6)\n",
    "        sr0_post_remove = SourceRange.from_values(\"file_name\",\n",
    "                                                  start_line=8,\n",
    "                                                  start_column=1,\n",
    "                                                  end_line=8,\n",
    "                                                  end_column=5)\n",
    "\n",
    "        sr0_pre_addition = SourceRange.from_values(\"file_name\",\n",
    "                                                   start_line=10,\n",
    "                                                   start_column=1,\n",
    "                                                   end_line=10,\n",
    "                                                   end_column=6)\n",
    "        sr0_post_addition = SourceRange.from_values(\"file_name\",\n",
    "                                                    start_line=11,\n",
    "                                                    start_column=1,\n",
    "                                                    end_line=11,\n",
    "                                                    end_column=5)\n",
    "\n",
    "        # ORIGINAL RESULTS:\n",
    "        res0_pre_change = Result(origin=\"origin\",\n",
    "                                 message=\"message\",\n",
    "                                 affected_code=(sr0_pre_change,))\n",
    "        res0_change = Result(origin=\"origin\",\n",
    "                             message=\"message\",\n",
    "                             affected_code=(sr0_change,))\n",
    "        res0_post_change = Result(origin=\"origin\",\n",
    "                                  message=\"message\",\n",
    "                                  affected_code=(sr0_post_change,))\n",
    "        res0_around_change = Result(origin=\"origin\",\n",
    "                                    message=\"message\",\n",
    "                                    affected_code=(sr0_pre_change,\n",
    "                                                   sr0_post_change))\n",
    "        res0_with_change = Result(origin=\"origin\",\n",
    "                                  message=\"message\",\n",
    "                                  affected_code=(sr0_pre_change,\n",
    "                                                 sr0_change,\n",
    "                                                 sr0_post_change))\n",
    "        res0_whole_change = Result.from_values(origin=\"origin\",\n",
    "                                               message=\"message\",\n",
    "                                               file=\"file_name\",\n",
    "                                               line=4,\n",
    "                                               column=1,\n",
    "                                               end_line=4,\n",
    "                                               end_column=19)\n",
    "\n",
    "        res0_pre_remove = Result(origin=\"origin\",\n",
    "                                 message=\"message\",\n",
    "                                 affected_code=(sr0_pre_remove,))\n",
    "        res0_post_remove = Result(origin=\"origin\",\n",
    "                                  message=\"message\",\n",
    "                                  affected_code=(sr0_post_remove,))\n",
    "        res0_around_remove = Result(origin=\"origin\",\n",
    "                                    message=\"message\",\n",
    "                                    affected_code=(sr0_pre_remove,\n",
    "                                                   sr0_post_remove))\n",
    "        res0_whole_remove = Result.from_values(origin=\"origin\",\n",
    "                                               message=\"message\",\n",
    "                                               file=\"file_name\",\n",
    "                                               line=6,\n",
    "                                               column=1,\n",
    "                                               end_line=8,\n",
    "                                               end_column=5)\n",
    "\n",
    "        res0_pre_addition = Result(origin=\"origin\",\n",
    "                                   message=\"message\",\n",
    "                                   affected_code=(sr0_pre_addition,))\n",
    "        res0_post_addition = Result(origin=\"origin\",\n",
    "                                    message=\"message\",\n",
    "                                    affected_code=(sr0_post_addition,))\n",
    "        res0_around_addition = Result(origin=\"origin\",\n",
    "                                      message=\"message\",\n",
    "                                      affected_code=(sr0_pre_addition,\n",
    "                                                     sr0_post_addition))\n",
    "        res0_whole_addition = Result.from_values(origin=\"origin\",\n",
    "                                                 message=\"message\",\n",
    "                                                 file=\"file_name\",\n",
    "                                                 line=10,\n",
    "                                                 column=1,\n",
    "                                                 end_line=11,\n",
    "                                                 end_column=5)\n",
    "\n",
    "        # NEW SOURCE RANGES:\n",
    "        sr1_pre_change = SourceRange.from_values(\"file_name\",\n",
    "                                                 start_line=4,\n",
    "                                                 start_column=1,\n",
    "                                                 end_line=4,\n",
    "                                                 end_column=6)\n",
    "        sr1_change = SourceRange.from_values(\"file_name\",\n",
    "                                             start_line=4,\n",
    "                                             start_column=8,\n",
    "                                             end_line=4,\n",
    "                                             end_column=13)\n",
    "        sr1_post_change = SourceRange.from_values(\"file_name\",\n",
    "                                                  start_line=4,\n",
    "                                                  start_column=15,\n",
    "                                                  end_line=4,\n",
    "                                                  end_column=19)\n",
    "\n",
    "        sr1_pre_remove = SourceRange.from_values(\"file_name\",\n",
    "                                                 start_line=6,\n",
    "                                                 start_column=1,\n",
    "                                                 end_line=6,\n",
    "                                                 end_column=6)\n",
    "        sr1_post_remove = SourceRange.from_values(\"file_name\",\n",
    "                                                  start_line=7,\n",
    "                                                  start_column=1,\n",
    "                                                  end_line=7,\n",
    "                                                  end_column=5)\n",
    "\n",
    "        sr1_pre_addition = SourceRange.from_values(\"file_name\",\n",
    "                                                   start_line=9,\n",
    "                                                   start_column=1,\n",
    "                                                   end_line=9,\n",
    "                                                   end_column=6)\n",
    "        sr1_addition = SourceRange.from_values(\"file_name\",\n",
    "                                               start_line=10,\n",
    "                                               start_column=1,\n",
    "                                               end_line=10,\n",
    "                                               end_column=8)\n",
    "        sr1_post_addition = SourceRange.from_values(\"file_name\",\n",
    "                                                    start_line=11,\n",
    "                                                    start_column=1,\n",
    "                                                    end_line=11,\n",
    "                                                    end_column=5)\n",
    "\n",
    "        # NEW RESULTS:\n",
    "        res1_pre_change = Result(origin=\"origin\",\n",
    "                                 message=\"message\",\n",
    "                                 affected_code=(sr1_pre_change,))\n",
    "        res1_change = Result(origin=\"origin\",\n",
    "                             message=\"message\",\n",
    "                             affected_code=(sr1_change,))\n",
    "        res1_post_change = Result(origin=\"origin\",\n",
    "                                  message=\"message\",\n",
    "                                  affected_code=(sr1_post_change,))\n",
    "        res1_around_change = Result(origin=\"origin\",\n",
    "                                    message=\"message\",\n",
    "                                    affected_code=(sr1_pre_change,\n",
    "                                                   sr1_post_change))\n",
    "        res1_with_change = Result(origin=\"origin\",\n",
    "                                  message=\"message\",\n",
    "                                  affected_code=(sr1_pre_change,\n",
    "                                                 sr1_change,\n",
    "                                                 sr1_post_change))\n",
    "        res1_whole_change = Result.from_values(origin=\"origin\",\n",
    "                                               message=\"message\",\n",
    "                                               file=\"file_name\",\n",
    "                                               line=4,\n",
    "                                               column=1,\n",
    "                                               end_line=4,\n",
    "                                               end_column=19)\n",
    "\n",
    "        res1_pre_remove = Result(origin=\"origin\",\n",
    "                                 message=\"message\",\n",
    "                                 affected_code=(sr1_pre_remove,))\n",
    "        res1_post_remove = Result(origin=\"origin\",\n",
    "                                  message=\"message\",\n",
    "                                  affected_code=(sr1_post_remove,))\n",
    "        res1_around_remove = Result(origin=\"origin\",\n",
    "                                    message=\"message\",\n",
    "                                    affected_code=(sr1_pre_remove,\n",
    "                                                   sr1_post_remove))\n",
    "        res1_whole_remove = Result.from_values(origin=\"origin\",\n",
    "                                               message=\"message\",\n",
    "                                               file=\"file_name\",\n",
    "                                               line=6,\n",
    "                                               column=1,\n",
    "                                               end_line=7,\n",
    "                                               end_column=5)\n",
    "\n",
    "        res1_pre_addition = Result(origin=\"origin\",\n",
    "                                   message=\"message\",\n",
    "                                   affected_code=(sr1_pre_addition,))\n",
    "        res1_addition = Result(origin=\"origin\",\n",
    "                               message=\"message\",\n",
    "                               affected_code=(sr1_addition,))\n",
    "        res1_post_addition = Result(origin=\"origin\",\n",
    "                                    message=\"message\",\n",
    "                                    affected_code=(sr1_post_addition,))\n",
    "        res1_around_addition = Result(origin=\"origin\",\n",
    "                                      message=\"message\",\n",
    "                                      affected_code=(sr1_pre_addition,\n",
    "                                                     sr1_post_addition))\n",
    "        res1_with_addition = Result(origin=\"origin\",\n",
    "                                    message=\"message\",\n",
    "                                    affected_code=(sr1_pre_addition,\n",
    "                                                   sr1_addition,\n",
    "                                                   sr1_post_addition))\n",
    "        res1_whole_addition = Result.from_values(origin=\"origin\",\n",
    "                                                 message=\"message\",\n",
    "                                                 file=\"file_name\",\n",
    "                                                 line=9,\n",
    "                                                 column=1,\n",
    "                                                 end_line=11,\n",
    "                                                 end_column=5)\n",
    "\n",
    "        original_result_list = [res0_pre_change,\n",
    "                                res0_change,\n",
    "                                res0_post_change,\n",
    "                                res0_around_change,\n",
    "                                res0_with_change,\n",
    "                                res0_whole_change,\n",
    "\n",
    "                                res0_pre_remove,\n",
    "                                res0_post_remove,\n",
    "                                res0_around_remove,\n",
    "                                res0_whole_remove,\n",
    "\n",
    "                                res0_pre_addition,\n",
    "                                res0_post_addition,\n",
    "                                res0_around_addition,\n",
    "                                res0_whole_addition]\n",
    "\n",
    "        new_result_list = [res1_pre_change,       # FALSE POSITIVE (in-line)\n",
    "                           res1_change,           # correctly kept\n",
    "                           res1_post_change,      # FALSE POSITIVE (in-line)\n",
    "                           res1_around_change,    # FALSE POSITIVE (in-line)\n",
    "                           res1_with_change,      # correctly kept\n",
    "                           res1_whole_change,     # correctly kept\n",
    "\n",
    "                           res1_pre_remove,       # correctly filtered out\n",
    "                           res1_post_remove,      # FALSE POSITIVE (in-line)\n",
    "                           res1_around_remove,    # correctly filtered out\n",
    "                           res1_whole_remove,     # correctly kept\n",
    "\n",
    "                           res1_pre_addition,     # correctly filtered out\n",
    "                           res1_addition,         # correctly kept\n",
    "                           res1_post_addition,    # correctly filtered out\n",
    "                           res1_around_addition,  # FALSE POSITIVE (close-line)\n",
    "                           res1_with_addition,    # correctly kept\n",
    "                           res1_whole_addition]   # correctly kept\n",
    "\n",
    "        unique_new_result_list = [res1_pre_change,       # WRONG: line-wise diff\n",
    "                                  res1_change,           # correct\n",
    "                                  res1_post_change,      # WRONG: line-wise diff\n",
    "                                  res1_around_change,    # WRONG: line-wise diff\n",
    "                                  res1_with_change,      # correct\n",
    "                                  res1_whole_change,     # correct\n",
    "\n",
    "                                  res1_addition,         # correct\n",
    "                                  res1_around_addition,  # WRONG: line-wise diff\n",
    "                                  res1_with_addition,    # correct\n",
    "                                  res1_whole_addition]   # correct\n",
    "\n",
    "        with open(self.original_file_name, \"r\") as original_file:\n",
    "            original_file_dict = {\n",
    "                abspath(\"file_name\"): original_file.readlines()}\n",
    "\n",
    "            with open(self.modified_file_name, \"r\") as modified_file:\n",
    "                modified_file_dict = {\n",
    "                    abspath(\"file_name\"): modified_file.readlines()}\n",
    "\n",
    "                # 'TIS THE IMPORTANT PART\n",
    "                self.assertEqual(sorted(filter_results(original_file_dict,\n",
    "                                                       modified_file_dict,\n",
    "                                                       original_result_list,\n",
    "                                                       new_result_list)),\n",
    "                                 sorted(unique_new_result_list))\n",
    "\n",
    "    def test_affected_code_rename_files(self):\n",
    "\n",
    "        # ORIGINAL SOURCE RANGES:\n",
    "        sr0_pre_change = SourceRange.from_values(\"file_name\",\n",
    "                                                 start_line=8,\n",
    "                                                 start_column=1,\n",
    "                                                 end_line=8,\n",
    "                                                 end_column=3)\n",
    "\n",
    "        # ORIGINAL RESULTS:\n",
    "        res0_pre_change = Result(origin=\"origin\",\n",
    "                                 message=\"message\",\n",
    "                                 affected_code=(sr0_pre_change,))\n",
    "\n",
    "        # NEW SOURCE RANGES:\n",
    "        sr1_pre_change = SourceRange.from_values(\"file_name_new\",\n",
    "                                                 start_line=7,\n",
    "                                                 start_column=1,\n",
    "                                                 end_line=7,\n",
    "                                                 end_column=3)\n",
    "        sr1_change = SourceRange.from_values(\"file_name_new\",\n",
    "                                             start_line=4,\n",
    "                                             start_column=8,\n",
    "                                             end_line=4,\n",
    "                                             end_column=13)\n",
    "\n",
    "        # NEW RESULTS:\n",
    "        res1_pre_change = Result(origin=\"origin\",\n",
    "                                 message=\"message\",\n",
    "                                 affected_code=(sr1_pre_change,))\n",
    "        res1_change = Result(origin=\"origin\",\n",
    "                             message=\"message\",\n",
    "                             affected_code=(sr1_change,))\n",
    "        res1_whole_remove = Result.from_values(origin=\"origin\",\n",
    "                                               message=\"message\",\n",
    "                                               file=\"file_name_new\",\n",
    "                                               line=6,\n",
    "                                               column=1,\n",
    "                                               end_line=7,\n",
    "                                               end_column=5)\n",
    "\n",
    "        original_result_list = [res0_pre_change]\n",
    "\n",
    "        new_result_list = [res1_pre_change,\n",
    "                           res1_change,\n",
    "                           res1_whole_remove]\n",
    "\n",
    "        unique_new_result_list = [res1_change,\n",
    "                                  res1_whole_remove]\n",
    "\n",
    "        with open(self.original_file_name, \"r\") as original_file:\n",
    "            original_file_dict = {\n",
    "                abspath(\"file_name\"): original_file.readlines()}\n",
    "\n",
    "            with open(self.modified_file_name, \"r\") as modified_file:\n",
    "                modified_file_dict = {\n",
    "                    abspath(\"file_name_new\"): modified_file.readlines()}\n",
    "\n",
    "                # 'TIS THE IMPORTANT PART\n",
    "                self.assertEqual(sorted(filter_results(original_file_dict,\n",
    "                                                       modified_file_dict,\n",
    "                                                       original_result_list,\n",
    "                                                       new_result_list)),\n",
    "                                 sorted(unique_new_result_list))\n",
    "\n",
    "    def test_unrelated_file_change(self):\n",
    "        testfile_1 = ['1\\n', '2\\n']\n",
    "        testfile_2 = ['1\\n', '2\\n']\n",
    "        testfile_2_new = ['0\\n', '1\\n', '2\\n']\n",
    "        old_result = Result.from_values('origin', 'message', 'tf1', 1)\n",
    "        new_result = Result.from_values('origin', 'message', 'tf1', 1)\n",
    "        tf1 = abspath('tf1')\n",
    "        original_file_dict = {tf1: testfile_1, 'tf2': testfile_2}\n",
    "        modified_file_dict = {tf1: testfile_1, 'tf2': testfile_2_new}\n",
    "\n",
    "        new_results = filter_results(original_file_dict, modified_file_dict,\n",
    "                                     [old_result], [new_result])\n",
    "        self.assertEqual(new_results, [])\n",
    "\n",
    "    def test_result_range(self):\n",
    "        test_file = [\"123456789\", \"123456789\", \"123456789\", \"123456789\"]\n",
    "\n",
    "        self.assertEqual(remove_range(test_file,\n",
    "                                      SourceRange.from_values(\"file\",\n",
    "                                                              1,\n",
    "                                                              1,\n",
    "                                                              1,\n",
    "                                                              1)),\n",
    "                         [\"23456789\", \"123456789\", \"123456789\", \"123456789\"])\n",
    "\n",
    "        self.assertEqual(remove_range(test_file,\n",
    "                                      SourceRange.from_values(\"file\",\n",
    "                                                              1,\n",
    "                                                              9,\n",
    "                                                              1,\n",
    "                                                              9)),\n",
    "                         [\"12345678\", \"123456789\", \"123456789\", \"123456789\"])\n",
    "\n",
    "        self.assertEqual(remove_range(test_file,\n",
    "                                      SourceRange.from_values(\"file\",\n",
    "                                                              1,\n",
    "                                                              3,\n",
    "                                                              1,\n",
    "                                                              7)),\n",
    "                         [\"1289\", \"123456789\", \"123456789\", \"123456789\"])\n",
    "\n",
    "        self.assertEqual(remove_range(test_file,\n",
    "                                      SourceRange.from_values(\"file\",\n",
    "                                                              1,\n",
    "                                                              3,\n",
    "                                                              2,\n",
    "                                                              7)),\n",
    "                         [\"12\", \"89\", \"123456789\", \"123456789\"])\n",
    "\n",
    "        self.assertEqual(remove_range(test_file,\n",
    "                                      SourceRange.from_values(\"file\",\n",
    "                                                              1,\n",
    "                                                              3,\n",
    "                                                              3,\n",
    "                                                              7)),\n",
    "                         [\"12\", \"89\", \"123456789\"])\n",
    "\n",
    "        self.assertEqual(remove_range(test_file,\n",
    "                                      SourceRange.from_values(\"file\",\n",
    "                                                              1,\n",
    "                                                              3,\n",
    "                                                              4,\n",
    "                                                              7)),\n",
    "                         [\"12\", \"89\"])\n",
    "\n",
    "        self.assertEqual(remove_range(test_file,\n",
    "                                      SourceRange.from_values(\"file\",\n",
    "                                                              None,\n",
    "                                                              None,\n",
    "                                                              None,\n",
    "                                                              None)),\n",
    "                         [])\n",
    "\n",
    "        self.assertEqual(remove_range(test_file,\n",
    "                                      SourceRange.from_values(\"file\",\n",
    "                                                              None,\n",
    "                                                              None,\n",
    "                                                              3,\n",
    "                                                              None)),\n",
    "                         [\"123456789\"])\n",
    "\n",
    "        self.assertEqual(remove_range(test_file,\n",
    "                                      SourceRange.from_values(\"file\",\n",
    "                                                              3,\n",
    "                                                              None,\n",
    "                                                              3,\n",
    "                                                              None)),\n",
    "                         [\"123456789\", \"123456789\", \"123456789\"])\n",
    "\n",
    "    def test_result_range_inline_overlap(self):\n",
    "        test_file = [\"123456789\\n\"]\n",
    "        test_file_dict = {abspath(\"test_file\"): test_file}\n",
    "\n",
    "        source_range1 = SourceRange.from_values(\"test_file\", 1, 1, 1, 4)\n",
    "        source_range2 = SourceRange.from_values(\"test_file\", 1, 2, 1, 3)\n",
    "        source_range3 = SourceRange.from_values(\"test_file\", 1, 3, 1, 6)\n",
    "\n",
    "        test_result = Result(\"origin\",\n",
    "                             \"message\",\n",
    "                             (source_range1, source_range2, source_range3))\n",
    "\n",
    "        result_diff = remove_result_ranges_diffs(\n",
    "            [test_result],\n",
    "            test_file_dict)[test_result][abspath(\"test_file\")]\n",
    "        expected_diff = Diff.from_string_arrays(test_file, [\"789\\n\"])\n",
    "\n",
    "        self.assertEqual(result_diff, expected_diff)\n",
    "\n",
    "    def test_result_range_line_wise_overlap(self):\n",
    "        test_file = [\"11\", \"22\", \"33\", \"44\", \"55\", \"66\"]\n",
    "        test_file_dict = {abspath(\"test_file\"): test_file}\n",
    "\n",
    "        source_range1 = SourceRange.from_values(\"test_file\", 2, 2, 5, 1)\n",
    "        source_range2 = SourceRange.from_values(\"test_file\", 3, 1, 4, 1)\n",
    "\n",
    "        test_result = Result(\"origin\",\n",
    "                             \"message\",\n",
    "                             (source_range1, source_range2))\n",
    "\n",
    "        result_diff = remove_result_ranges_diffs(\n",
    "            [test_result],\n",
    "            test_file_dict)[test_result][abspath(\"test_file\")]\n",
    "        expected_diff = Diff.from_string_arrays(test_file,\n",
    "                                                [\"11\", \"2\", \"5\", \"66\"])\n",
    "\n",
    "        self.assertEqual(result_diff, expected_diff)\n",
    "\n",
    "    def test_no_range(self):\n",
    "        test_file = [\"abc\"]\n",
    "        test_file_dict = {abspath(\"test_file\"): test_file}\n",
    "\n",
    "        test_result = Result(\"origin\",\n",
    "                             \"message\")\n",
    "\n",
    "        result_diff = remove_result_ranges_diffs(\n",
    "            [test_result],\n",
    "            test_file_dict)[test_result][abspath(\"test_file\")]\n",
    "        expected_diff = Diff.from_string_arrays(test_file, [\"abc\"])\n",
    "\n",
    "        self.assertEqual(result_diff, expected_diff)\n",
    "\n",
    "    def test_new_file_with_result(self):\n",
    "        testfile_1 = ['1\\n', '2\\n']\n",
    "        testfile_2_new = ['0\\n', '1\\n', '2\\n']\n",
    "        tf1 = abspath('tf1')\n",
    "        tf2 = abspath('tf2')\n",
    "        old_result = Result.from_values('origin', 'message', 'tf1', 1)\n",
    "        new_result = Result.from_values('origin', 'message', 'tf2', 1)\n",
    "        original_file_dict = {tf1: testfile_1}\n",
    "        modified_file_dict = {tf1: testfile_1, tf2: testfile_2_new}\n",
    "\n",
    "        new_results = filter_results(original_file_dict, modified_file_dict,\n",
    "                                     [old_result], [new_result])\n",
    "        self.assertEqual(new_results, [new_result])\n",
    "\n",
    "    def test_delete_file_with_result(self):\n",
    "        testfile_1 = ['1\\n', '2\\n']\n",
    "        testfile_2 = ['0\\n', '1\\n', '2\\n']\n",
    "        testfile_1_new = ['0\\n', '1\\n', '2\\n']\n",
    "        tf1 = abspath('tf1')\n",
    "        tf2 = abspath('tf2')\n",
    "        old_result_tf1 = Result.from_values('origin', 'message', 'tf1', 1)\n",
    "        old_result_tf2 = Result.from_values('origin', 'message', 'tf2', 1)\n",
    "        new_result = Result.from_values('origin', 'message', 'tf1', 1)\n",
    "        original_file_dict = {tf1: testfile_1, tf2: testfile_2}\n",
    "        modified_file_dict = {tf1: testfile_1_new}\n",
    "\n",
    "        new_results = filter_results(original_file_dict,\n",
    "                                     modified_file_dict,\n",
    "                                     [old_result_tf1, old_result_tf2],\n",
    "                                     [new_result])\n",
    "        self.assertEqual(new_results, [new_result])\n"
  ],
  "/home/tushar/coala/tests/results/ResultTest.py": [
    "import unittest\n",
    "import json\n",
    "from os.path import abspath\n",
    "\n",
    "from coalib.results.Diff import Diff\n",
    "from coalib.results.Result import RESULT_SEVERITY, Result\n",
    "from coalib.results.SourceRange import SourceRange\n",
    "from coalib.output.JSONEncoder import create_json_encoder\n",
    "\n",
    "\n",
    "class ResultTest(unittest.TestCase):\n",
    "\n",
    "    def test_origin(self):\n",
    "        uut = Result(\"origin\", \"msg\")\n",
    "        self.assertEqual(uut.origin, \"origin\")\n",
    "\n",
    "        uut = Result(self, \"msg\")\n",
    "        self.assertEqual(uut.origin, \"ResultTest\")\n",
    "\n",
    "        uut = Result(None, \"msg\")\n",
    "        self.assertEqual(uut.origin, \"\")\n",
    "\n",
    "    def test_invalid_severity(self):\n",
    "        with self.assertRaises(ValueError):\n",
    "            Result(\"o\", \"m\", severity=-5)\n",
    "\n",
    "    def test_string_dict(self):\n",
    "        uut = Result(None, \"\")\n",
    "        output = uut.to_string_dict()\n",
    "        self.assertEqual(output, {\"id\": str(uut.id),\n",
    "                                  \"origin\": \"\",\n",
    "                                  \"message\": \"\",\n",
    "                                  \"file\": \"\",\n",
    "                                  \"line_nr\": \"\",\n",
    "                                  \"severity\": \"NORMAL\",\n",
    "                                  \"debug_msg\": \"\",\n",
    "                                  \"additional_info\": \"\"})\n",
    "\n",
    "        uut = Result.from_values(origin=\"origin\",\n",
    "                                 message=\"msg\",\n",
    "                                 file=\"file\",\n",
    "                                 line=2,\n",
    "                                 severity=RESULT_SEVERITY.INFO,\n",
    "                                 additional_info=\"hi!\",\n",
    "                                 debug_msg=\"dbg\")\n",
    "        output = uut.to_string_dict()\n",
    "        self.assertEqual(output, {\"id\": str(uut.id),\n",
    "                                  \"origin\": \"origin\",\n",
    "                                  \"message\": \"msg\",\n",
    "                                  \"file\": abspath(\"file\"),\n",
    "                                  \"line_nr\": \"2\",\n",
    "                                  \"severity\": \"INFO\",\n",
    "                                  \"debug_msg\": \"dbg\",\n",
    "                                  \"additional_info\": \"hi!\"})\n",
    "\n",
    "        uut = Result.from_values(origin=\"o\", message=\"m\", file=\"f\", line=5)\n",
    "        output = uut.to_string_dict()\n",
    "        self.assertEqual(output[\"line_nr\"], \"5\")\n",
    "\n",
    "    def test_apply(self):\n",
    "        file_dict = {\n",
    "            \"f_a\": [\"1\", \"2\", \"3\"],\n",
    "            \"f_b\": [\"1\", \"2\", \"3\"]\n",
    "        }\n",
    "        expected_file_dict = {\n",
    "            \"f_a\": [\"1\", \"3_changed\"],\n",
    "            \"f_b\": [\"1\", \"2\", \"3\"]\n",
    "        }\n",
    "        diff = Diff(file_dict['f_a'])\n",
    "        diff.delete_line(2)\n",
    "        diff.change_line(3, \"3\", \"3_changed\")\n",
    "\n",
    "        uut = Result(\"origin\", \"msg\", diffs={\"f_a\": diff})\n",
    "        uut.apply(file_dict)\n",
    "\n",
    "        self.assertEqual(file_dict, expected_file_dict)\n",
    "\n",
    "    def test_add(self):\n",
    "        file_dict = {\n",
    "            \"f_a\": [\"1\", \"2\", \"3\"],\n",
    "            \"f_b\": [\"1\", \"2\", \"3\"],\n",
    "            \"f_c\": [\"1\", \"2\", \"3\"]\n",
    "        }\n",
    "        expected_file_dict = {\n",
    "            \"f_a\": [\"1\", \"3_changed\"],\n",
    "            \"f_b\": [\"1\", \"2\", \"3_changed\"],\n",
    "            \"f_c\": [\"1\", \"2\", \"3\"]\n",
    "        }\n",
    "\n",
    "        diff = Diff(file_dict['f_a'])\n",
    "        diff.delete_line(2)\n",
    "        uut1 = Result(\"origin\", \"msg\", diffs={\"f_a\": diff})\n",
    "\n",
    "        diff = Diff(file_dict['f_a'])\n",
    "        diff.change_line(3, \"3\", \"3_changed\")\n",
    "        uut2 = Result(\"origin\", \"msg\", diffs={\"f_a\": diff})\n",
    "\n",
    "        diff = Diff(file_dict['f_b'])\n",
    "        diff.change_line(3, \"3\", \"3_changed\")\n",
    "        uut3 = Result(\"origin\", \"msg\", diffs={\"f_b\": diff})\n",
    "\n",
    "        uut1 += uut2 + uut3\n",
    "        uut1.apply(file_dict)\n",
    "\n",
    "        self.assertEqual(file_dict, expected_file_dict)\n",
    "\n",
    "    def test_overlaps(self):\n",
    "        overlapping_range = SourceRange.from_values(\"file1\", 1, 1, 2, 2)\n",
    "        nonoverlapping_range = SourceRange.from_values(\"file2\", 1, 1, 2, 2)\n",
    "        uut = Result.from_values(\"origin\",\n",
    "                                 \"message\",\n",
    "                                 file=\"file1\",\n",
    "                                 line=1,\n",
    "                                 column=1,\n",
    "                                 end_line=2,\n",
    "                                 end_column=2)\n",
    "        self.assertTrue(uut.overlaps(overlapping_range))\n",
    "        self.assertTrue(uut.overlaps([overlapping_range]))\n",
    "        self.assertFalse(uut.overlaps(nonoverlapping_range))\n",
    "\n",
    "    def test_location_repr(self):\n",
    "        result_a = Result(origin=\"o\", message=\"m\")\n",
    "        self.assertEqual(result_a.location_repr(), \"the whole project\")\n",
    "\n",
    "        result_b = Result.from_values(\"o\", \"m\", file=\"e\")\n",
    "        self.assertEqual(result_b.location_repr(), \"'e'\")\n",
    "\n",
    "        affected_code = (SourceRange.from_values('f'),\n",
    "                         SourceRange.from_values('g'))\n",
    "        result_c = Result(\"o\", \"m\", affected_code=affected_code)\n",
    "        self.assertEqual(result_c.location_repr(), \"'f', 'g'\")\n",
    "\n",
    "        affected_code = (SourceRange.from_values('f'),\n",
    "                         SourceRange.from_values('f'))\n",
    "        result_d = Result(\"o\", \"m\", affected_code=affected_code)\n",
    "        self.assertEqual(result_d.location_repr(), \"'f'\")\n",
    "\n",
    "    def test_json_diff(self):\n",
    "        file_dict = {\n",
    "            \"f_a\": [\"1\", \"2\", \"3\"],\n",
    "            \"f_b\": [\"1\", \"2\", \"3\"]\n",
    "        }\n",
    "        expected_file = {\n",
    "            \"f_a\": [\"1\", \"3_changed\"],\n",
    "            \"f_b\": [\"1\", \"2\", \"3\"]\n",
    "        }\n",
    "        diff = Diff(file_dict['f_a'])\n",
    "        diff.delete_line(2)\n",
    "        diff.change_line(3, \"3\", \"3_changed\")\n",
    "        uut = Result(\"origin\", \"msg\", diffs={\"f_a\": diff}).__json__(True)\n",
    "        self.assertEqual(uut[\"diffs\"]['f_a'].__json__(), \"--- \\n\"\n",
    "                                                         \"+++ \\n\"\n",
    "                                                         \"@@ -1,3 +1,2 @@\\n\"\n",
    "                                                         \" 1-2-3+3_changed\")\n",
    "        JSONEncoder = create_json_encoder(use_relpath=True)\n",
    "        json_dump = json.dumps(diff, cls=JSONEncoder, sort_keys=True)\n",
    "        self.assertEqual(\n",
    "            json_dump, '\"--- \\\\n+++ \\\\n@@ -1,3 +1,2 @@\\\\n 1-2-3+3_changed\"')\n"
  ],
  "/home/tushar/coala/tests/results/SourcePositionTest.py": [
    "import unittest\n",
    "from os.path import relpath\n",
    "\n",
    "from coalib.results.SourcePosition import SourcePosition\n",
    "from coalib.misc.ContextManagers import prepare_file\n",
    "\n",
    "\n",
    "class SourcePositionTest(unittest.TestCase):\n",
    "\n",
    "    def test_initialization(self):\n",
    "        with self.assertRaises(TypeError):\n",
    "            SourcePosition(None, 0)\n",
    "\n",
    "        with self.assertRaises(ValueError):\n",
    "            SourcePosition(\"file\", None, 1)\n",
    "\n",
    "        # However these should work:\n",
    "        SourcePosition(\"file\", None, None)\n",
    "        SourcePosition(\"file\", 4, None)\n",
    "        SourcePosition(\"file\", 4, 5)\n",
    "\n",
    "    def test_string_conversion(self):\n",
    "        uut = SourcePosition(\"filename\", 1)\n",
    "        self.assertRegex(\n",
    "            repr(uut),\n",
    "            \"<SourcePosition object\\\\(file='.*filename', line=1, \"\n",
    "                \"column=None\\\\) at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "        uut = SourcePosition(\"None\", None)\n",
    "        self.assertRegex(\n",
    "            repr(uut),\n",
    "            \"<SourcePosition object\\\\(file='.*None', line=None, column=None\\\\) \"\n",
    "                \"at 0x[0-9a-fA-F]+>\")\n",
    "\n",
    "    def test_json(self):\n",
    "        with prepare_file([\"\"], None) as (_, filename):\n",
    "            uut = SourcePosition(filename, 1)\n",
    "            self.assertEqual(uut.__json__(use_relpath=True)\n",
    "                             ['file'], relpath(filename))\n",
    "\n",
    "    def assert_equal(self, first, second):\n",
    "        self.assertGreaterEqual(first, second)\n",
    "        self.assertEqual(first, second)\n",
    "        self.assertLessEqual(first, second)\n",
    "\n",
    "    def assert_ordering(self, greater, lesser):\n",
    "        self.assertGreater(greater, lesser)\n",
    "        self.assertGreaterEqual(greater, lesser)\n",
    "        self.assertNotEqual(greater, lesser)\n",
    "        self.assertLessEqual(lesser, greater)\n",
    "        self.assertLess(lesser, greater)\n"
  ],
  "/home/tushar/coala/tests/results/SourceRangeTest.py": [
    "import unittest\n",
    "from collections import namedtuple\n",
    "from os.path import abspath\n",
    "\n",
    "from coalib.results.SourcePosition import SourcePosition\n",
    "from coalib.results.SourceRange import SourceRange\n",
    "from coalib.results.AbsolutePosition import AbsolutePosition\n",
    "from coalib.results.Diff import Diff\n",
    "\n",
    "\n",
    "class SourceRangeTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.result_fileA_noline = SourcePosition(\"A\")\n",
    "        self.result_fileA_line2 = SourcePosition(\"A\", 2)\n",
    "        self.result_fileB_noline = SourcePosition(\"B\")\n",
    "        self.result_fileB_line2 = SourcePosition(\"B\", 2)\n",
    "        self.result_fileB_line4 = SourcePosition(\"B\", 4)\n",
    "\n",
    "    def test_construction(self):\n",
    "        uut1 = SourceRange(self.result_fileA_noline)\n",
    "        self.assertEqual(uut1.end, self.result_fileA_noline)\n",
    "\n",
    "        uut2 = SourceRange.from_values(\"A\")\n",
    "        self.assertEqual(uut1, uut2)\n",
    "\n",
    "        uut = SourceRange.from_values(\"B\", start_line=2, end_line=4)\n",
    "        self.assertEqual(uut.start, self.result_fileB_line2)\n",
    "        self.assertEqual(uut.end, self.result_fileB_line4)\n",
    "\n",
    "    def test_from_clang_range(self):\n",
    "        # Simulating a clang SourceRange is easier than setting one up without\n",
    "        # actually parsing a complete C file.\n",
    "        ClangRange = namedtuple(\"ClangRange\", \"start end\")\n",
    "        ClangPosition = namedtuple(\"ClangPosition\", \"file line column\")\n",
    "        ClangFile = namedtuple(\"ClangFile\", \"name\")\n",
    "        file = ClangFile(\"t.c\")\n",
    "        start = ClangPosition(file, 1, 2)\n",
    "        end = ClangPosition(file, 3, 4)\n",
    "\n",
    "        uut = SourceRange.from_clang_range(ClangRange(start, end))\n",
    "        compare = SourceRange.from_values(\"t.c\", 1, 2, 3, 4)\n",
    "        self.assertEqual(uut, compare)\n",
    "\n",
    "    def test_from_absolute_position(self):\n",
    "        text = (\"a\\n\", \"b\\n\")\n",
    "        start = AbsolutePosition(text, 0)\n",
    "        end = AbsolutePosition(text, 2)\n",
    "\n",
    "        uut = SourceRange.from_absolute_position(\"F\", start, end)\n",
    "        compare = SourceRange.from_values(\"F\", 1, 1, 2, 1)\n",
    "        self.assertEqual(uut, compare)\n",
    "\n",
    "        uut = SourceRange.from_absolute_position(\"F\", start, None)\n",
    "        compare = SourceRange(SourcePosition(\"F\", 1, 1), None)\n",
    "        self.assertEqual(uut, compare)\n",
    "\n",
    "    def test_file_property(self):\n",
    "        uut = SourceRange(self.result_fileA_line2)\n",
    "        self.assertRegex(uut.file, \".*A\")\n",
    "\n",
    "    def test_invalid_arguments(self):\n",
    "        # arguments must be SourceRanges\n",
    "        with self.assertRaises(TypeError):\n",
    "            SourceRange(1, self.result_fileA_noline)\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            SourceRange(self.result_fileA_line2, 1)\n",
    "\n",
    "    def test_argument_file(self):\n",
    "        # both Source_Positions should describe the same file\n",
    "        with self.assertRaises(ValueError):\n",
    "            SourceRange(self.result_fileA_noline, self.result_fileB_noline)\n",
    "\n",
    "    def test_argument_order(self):\n",
    "        # end should come after the start\n",
    "        with self.assertRaises(ValueError):\n",
    "            SourceRange(self.result_fileA_line2, self.result_fileA_noline)\n",
    "\n",
    "    def test_invalid_comparison(self):\n",
    "        with self.assertRaises(TypeError):\n",
    "            SourceRange(self.result_fileB_noline, self.result_fileB_line2) < 1\n",
    "\n",
    "    def test_json(self):\n",
    "        uut = SourceRange.from_values(\"B\", start_line=2,\n",
    "                                      end_line=4).__json__(use_relpath=True)\n",
    "        self.assertEqual(uut['start'], self.result_fileB_line2)\n",
    "\n",
    "    def test_renamed_file(self):\n",
    "        src_range = SourceRange(SourcePosition(\"test_file\"))\n",
    "        self.assertEqual(src_range.renamed_file({}), abspath('test_file'))\n",
    "\n",
    "        self.assertEqual(\n",
    "            src_range.renamed_file({abspath('test_file'): Diff([])}),\n",
    "            abspath('test_file'))\n",
    "\n",
    "        self.assertEqual(\n",
    "            src_range.renamed_file(\n",
    "                {abspath('test_file'): Diff([], rename='another_file')}),\n",
    "            'another_file')\n",
    "\n",
    "\n",
    "class SourceRangeExpandTest(unittest.TestCase):\n",
    "\n",
    "    def test_expand(self):\n",
    "        empty_position = SourcePosition(\"filename\")\n",
    "        file = [\"abc\\n\", \"def\\n\", \"ghi\\n\"]\n",
    "        empty_range = SourceRange(empty_position, empty_position)\n",
    "        full_range = SourceRange.from_values(\"filename\", 1, 1, 3, 4)\n",
    "        self.assertEqual(empty_range.expand(file), full_range)\n"
  ],
  "/home/tushar/coala/tests/results/TextPositionTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.results.TextPosition import TextPosition\n",
    "\n",
    "\n",
    "class TextPositionTest(unittest.TestCase):\n",
    "\n",
    "    def test_fail_instantation(self):\n",
    "        with self.assertRaises(ValueError):\n",
    "            TextPosition(None, 2)\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            TextPosition(\"hello\", 3)\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            TextPosition(4, \"world\")\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            TextPosition(\"double\", \"string\")\n",
    "\n",
    "    def test_properties(self):\n",
    "        uut = TextPosition(None, None)\n",
    "        self.assertEqual(uut.line, None)\n",
    "        self.assertEqual(uut.column, None)\n",
    "\n",
    "        uut = TextPosition(7, None)\n",
    "        self.assertEqual(uut.line, 7)\n",
    "        self.assertEqual(uut.column, None)\n",
    "\n",
    "        uut = TextPosition(8, 39)\n",
    "        self.assertEqual(uut.line, 8)\n",
    "        self.assertEqual(uut.column, 39)\n"
  ],
  "/home/tushar/coala/tests/results/TextRangeTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.results.TextPosition import TextPosition\n",
    "from coalib.results.TextRange import TextRange\n",
    "\n",
    "\n",
    "class TextRangeTest(unittest.TestCase):\n",
    "\n",
    "    def test_fail_instantation(self):\n",
    "        with self.assertRaises(ValueError):\n",
    "            TextRange(TextPosition(3, 4), TextPosition(2, 8))\n",
    "\n",
    "        with self.assertRaises(ValueError):\n",
    "            TextRange(TextPosition(0, 10), TextPosition(0, 7))\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            TextRange(None, TextPosition(20, 80))\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            TextRange(\"string\", TextPosition(200, 800))\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            TextRange(TextPosition(5, 0), \"schtring\")\n",
    "\n",
    "    def test_properties(self):\n",
    "        uut = TextRange(TextPosition(7, 2), TextPosition(7, 3))\n",
    "        self.assertEqual(uut.start, TextPosition(7, 2))\n",
    "        self.assertEqual(uut.end, TextPosition(7, 3))\n",
    "\n",
    "        uut = TextRange(TextPosition(70, 20), None)\n",
    "        self.assertEqual(uut.start, TextPosition(70, 20))\n",
    "        self.assertEqual(uut.end, TextPosition(70, 20))\n",
    "        self.assertEqual(uut.start, uut.end)\n",
    "        self.assertIsNot(uut.start, uut.end)\n",
    "\n",
    "    def test_from_values(self):\n",
    "        # Check if invalid ranges still fail.\n",
    "        with self.assertRaises(ValueError):\n",
    "            TextRange.from_values(0, 10, 0, 7)\n",
    "\n",
    "        uut = TextRange.from_values(1, 0, 7, 3)\n",
    "        self.assertEqual(uut.start, TextPosition(1, 0))\n",
    "        self.assertEqual(uut.end, TextPosition(7, 3))\n",
    "\n",
    "        uut = TextRange.from_values(1, 0, None, 88)\n",
    "        self.assertEqual(uut.start, TextPosition(1, 0))\n",
    "        self.assertEqual(uut.end, TextPosition(1, 0))\n",
    "\n",
    "        uut = TextRange.from_values(1, 0, 7, None)\n",
    "        self.assertEqual(uut.start, TextPosition(1, 0))\n",
    "        self.assertEqual(uut.end, TextPosition(7, None))\n",
    "\n",
    "        # Test defaults.\n",
    "        uut = TextRange.from_values()\n",
    "        self.assertEqual(uut.start, TextPosition(None, None))\n",
    "        self.assertEqual(uut.end, TextPosition(None, None))\n",
    "\n",
    "    def test_no_overlap(self):\n",
    "        uut1 = TextRange.from_values(2, None, 3)\n",
    "        uut2 = TextRange.from_values(4, None, 5)\n",
    "        self.assertFalse(uut1.overlaps(uut2))\n",
    "        self.assertFalse(uut2.overlaps(uut1))\n",
    "\n",
    "        uut1 = TextRange.from_values(2, None, 3, 6)\n",
    "        uut2 = TextRange.from_values(3, 7, 5)\n",
    "        self.assertFalse(uut1.overlaps(uut2))\n",
    "        self.assertFalse(uut2.overlaps(uut1))\n",
    "\n",
    "    def test_overlap(self):\n",
    "        uut1 = TextRange.from_values(2, None, 3)\n",
    "        uut2 = TextRange.from_values(3, None, 5)\n",
    "        self.assertTrue(uut1.overlaps(uut2))\n",
    "        self.assertTrue(uut2.overlaps(uut1))\n",
    "\n",
    "        uut1 = TextRange.from_values(2, None, 3, 6)\n",
    "        uut2 = TextRange.from_values(3, 6, 5)\n",
    "        self.assertTrue(uut1.overlaps(uut2))\n",
    "        self.assertTrue(uut2.overlaps(uut1))\n",
    "\n",
    "        uut1 = TextRange.from_values(2, None, 7)\n",
    "        uut2 = TextRange.from_values(3, None, 5)\n",
    "        self.assertTrue(uut1.overlaps(uut2))\n",
    "        self.assertTrue(uut2.overlaps(uut1))\n",
    "\n",
    "        uut1 = TextRange.from_values(5, None, 7)\n",
    "        uut2 = TextRange.from_values(3, None, 6)\n",
    "        self.assertTrue(uut1.overlaps(uut2))\n",
    "        self.assertTrue(uut2.overlaps(uut1))\n",
    "\n",
    "\n",
    "class TextRangeJoinTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.pos = [TextPosition(1, 1),\n",
    "                    TextPosition(3, 1),\n",
    "                    TextPosition(3, 3),\n",
    "                    TextPosition(4, 3),\n",
    "                    TextPosition(5, 3)]\n",
    "\n",
    "    def test_fails(self):\n",
    "        # need to pass ranges\n",
    "        with self.assertRaises(TypeError):\n",
    "            TextRange.join(self.pos[0], self.pos[1])\n",
    "\n",
    "        with self.assertRaises(TypeError):\n",
    "            TextRange.join(TextRange(self.pos[0], self.pos[1]), self.pos[1])\n",
    "\n",
    "        # ranges must overlap\n",
    "        with self.assertRaises(ValueError):\n",
    "            TextRange.join(TextRange(self.pos[0], self.pos[1]),\n",
    "                           TextRange(self.pos[3], self.pos[4]))\n",
    "\n",
    "    def test_join(self):\n",
    "        # overlap\n",
    "        self.assertEqual(TextRange.join(TextRange(self.pos[0], self.pos[2]),\n",
    "                                        TextRange(self.pos[1], self.pos[3])),\n",
    "                         TextRange(self.pos[0], self.pos[3]))\n",
    "\n",
    "        self.assertEqual(TextRange.join(TextRange(self.pos[1], self.pos[3]),\n",
    "                                        TextRange(self.pos[2], self.pos[4])),\n",
    "                         TextRange(self.pos[1], self.pos[4]))\n",
    "        # embrace\n",
    "        self.assertEqual(TextRange.join(TextRange(self.pos[0], self.pos[3]),\n",
    "                                        TextRange(self.pos[1], self.pos[2])),\n",
    "                         TextRange(self.pos[0], self.pos[3]))\n",
    "\n",
    "        # touch\n",
    "        self.assertEqual(TextRange.join(TextRange(self.pos[1], self.pos[2]),\n",
    "                                        TextRange(self.pos[2], self.pos[3])),\n",
    "                         TextRange(self.pos[1], self.pos[3]))\n",
    "\n",
    "\n",
    "class TextRangeExpandTest(unittest.TestCase):\n",
    "\n",
    "    def test_expand_full(self):\n",
    "        empty_position = TextPosition()\n",
    "        file = [\"abc\\n\", \"def\\n\", \"ghi\\n\"]\n",
    "        empty_range = TextRange(empty_position, empty_position)\n",
    "        full_range = TextRange.from_values(1, 1, 3, 4)\n",
    "        self.assertEqual(empty_range.expand(file), full_range)\n",
    "\n",
    "    def test_expand_none(self):\n",
    "        start_position = TextPosition(2, 2)\n",
    "        end_position = TextPosition(3, 2)\n",
    "        file = [\"abc\\n\", \"def\\n\", \"ghi\\n\"]\n",
    "        text_range = TextRange(start_position, end_position)\n",
    "        self.assertEqual(text_range.expand(file), text_range)\n",
    "\n",
    "    def test_expand_semi(self):\n",
    "        file = [\"abc\\n\", \"defg\\n\", \"hijkl\\n\", \"mnopqr\\n\"]\n",
    "        semi_range = TextRange.from_values(2, None, 3, None)\n",
    "        full_range = TextRange.from_values(2, 1, 3, 6)\n",
    "        self.assertEqual(semi_range.expand(file), full_range)\n"
  ],
  "/home/tushar/coala/tests/results/__init__.py": [],
  "/home/tushar/coala/tests/results/result_actions/ApplyPatchActionTest.py": [
    "import unittest\n",
    "import os\n",
    "from os.path import isfile\n",
    "\n",
    "from coalib.misc.ContextManagers import make_temp\n",
    "from coalib.results.Diff import Diff\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.result_actions.ApplyPatchAction import ApplyPatchAction\n",
    "from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "class ApplyPatchActionTest(unittest.TestCase):\n",
    "\n",
    "    def test_apply(self):\n",
    "        uut = ApplyPatchAction()\n",
    "        with make_temp() as f_a, make_temp() as f_b, make_temp() as f_c:\n",
    "\n",
    "            file_dict = {\n",
    "                f_a: [\"1\\n\", \"2\\n\", \"3\\n\"],\n",
    "                f_b: [\"1\\n\", \"2\\n\", \"3\\n\"],\n",
    "                f_c: [\"1\\n\", \"2\\n\", \"3\\n\"]\n",
    "            }\n",
    "            expected_file_dict = {\n",
    "                f_a: [\"1\\n\", \"3_changed\\n\"],\n",
    "                f_b: [\"1\\n\", \"2\\n\", \"3_changed\\n\"],\n",
    "                f_c: [\"1\\n\", \"2\\n\", \"3\\n\"]\n",
    "            }\n",
    "\n",
    "            file_diff_dict = {}\n",
    "\n",
    "            diff = Diff(file_dict[f_a])\n",
    "            diff.delete_line(2)\n",
    "            uut.apply_from_section(Result(\"origin\", \"msg\", diffs={f_a: diff}),\n",
    "                                   file_dict,\n",
    "                                   file_diff_dict,\n",
    "                                   Section(\"t\"))\n",
    "\n",
    "            diff = Diff(file_dict[f_a])\n",
    "            diff.change_line(3, \"3\\n\", \"3_changed\\n\")\n",
    "            uut.apply_from_section(Result(\"origin\", \"msg\", diffs={f_a: diff}),\n",
    "                                   file_dict,\n",
    "                                   file_diff_dict,\n",
    "                                   Section(\"t\"))\n",
    "\n",
    "            diff = Diff(file_dict[f_b])\n",
    "            diff.change_line(3, \"3\\n\", \"3_changed\\n\")\n",
    "            uut.apply(Result(\"origin\", \"msg\", diffs={f_b: diff}),\n",
    "                      file_dict,\n",
    "                      file_diff_dict)\n",
    "\n",
    "            for filename in file_diff_dict:\n",
    "                file_dict[filename] = file_diff_dict[filename].modified\n",
    "\n",
    "            self.assertEqual(file_dict, expected_file_dict)\n",
    "            with open(f_a) as fa:\n",
    "                self.assertEqual(file_dict[f_a], fa.readlines())\n",
    "            with open(f_b) as fb:\n",
    "                self.assertEqual(file_dict[f_b], fb.readlines())\n",
    "            with open(f_c) as fc:\n",
    "                # File c is unchanged and should be untouched\n",
    "                self.assertEqual([], fc.readlines())\n",
    "\n",
    "    def test_apply_orig_option(self):\n",
    "        uut = ApplyPatchAction()\n",
    "        with make_temp() as f_a, make_temp() as f_b:\n",
    "            file_dict = {\n",
    "                f_a: [\"1\\n\", \"2\\n\", \"3\\n\"],\n",
    "                f_b: [\"1\\n\", \"2\\n\", \"3\\n\"]\n",
    "                }\n",
    "            expected_file_dict = {\n",
    "                f_a: [\"1\\n\", \"2\\n\", \"3_changed\\n\"],\n",
    "                f_b: [\"1\\n\", \"2\\n\", \"3_changed\\n\"]\n",
    "                }\n",
    "            file_diff_dict = {}\n",
    "            diff = Diff(file_dict[f_a])\n",
    "            diff.change_line(3, \"3\\n\", \"3_changed\\n\")\n",
    "            uut.apply(Result(\"origin\", \"msg\", diffs={f_a: diff}),\n",
    "                      file_dict,\n",
    "                      file_diff_dict,\n",
    "                      no_orig=True)\n",
    "            diff = Diff(file_dict[f_b])\n",
    "            diff.change_line(3, \"3\\n\", \"3_changed\\n\")\n",
    "            uut.apply(Result(\"origin\", \"msg\", diffs={f_b: diff}),\n",
    "                      file_dict,\n",
    "                      file_diff_dict,\n",
    "                      no_orig=False)\n",
    "            self.assertFalse(isfile(f_a+\".orig\"))\n",
    "            self.assertTrue(isfile(f_b+\".orig\"))\n",
    "\n",
    "            for filename in file_diff_dict:\n",
    "                file_dict[filename] = file_diff_dict[filename].modified\n",
    "\n",
    "            self.assertEqual(file_dict, expected_file_dict)\n",
    "\n",
    "    def test_apply_rename(self):\n",
    "        uut = ApplyPatchAction()\n",
    "        with make_temp() as f_a:\n",
    "            file_dict = {f_a: [\"1\\n\", \"2\\n\", \"3\\n\"]}\n",
    "            expected_file_dict = {f_a+\".renamed\":\n",
    "                                      [\"1\\n\", \"2_changed\\n\", \"3_changed\\n\"]}\n",
    "            file_diff_dict = {}\n",
    "            diff = Diff(file_dict[f_a], rename=f_a+\".renamed\")\n",
    "            diff.change_line(3, \"3\\n\", \"3_changed\\n\")\n",
    "            uut.apply(Result(\"origin\", \"msg\", diffs={f_a: diff}),\n",
    "                      file_dict,\n",
    "                      file_diff_dict)\n",
    "            self.assertTrue(isfile(f_a+\".orig\"))\n",
    "            self.assertTrue(isfile(f_a+\".renamed\"))\n",
    "            self.assertFalse(isfile(f_a))\n",
    "\n",
    "            diff = Diff(file_dict[f_a])\n",
    "            diff.change_line(2, \"2\\n\", \"2_changed\\n\")\n",
    "            uut.apply(Result(\"origin\", \"msg\", diffs={f_a: diff}),\n",
    "                      file_dict,\n",
    "                      file_diff_dict)\n",
    "            self.assertTrue(isfile(f_a+\".renamed.orig\"))\n",
    "\n",
    "            file_dict = {f_a+\".renamed\": open(f_a+\".renamed\").readlines()}\n",
    "\n",
    "            self.assertEqual(file_dict, expected_file_dict)\n",
    "            # Recreate file so that context manager make_temp() can delete it\n",
    "            open(f_a, 'w').close()\n",
    "\n",
    "    def test_apply_delete(self):\n",
    "        uut = ApplyPatchAction()\n",
    "        with make_temp() as f_a:\n",
    "            file_dict = {f_a: [\"1\\n\", \"2\\n\", \"3\\n\"]}\n",
    "            file_diff_dict = {}\n",
    "            diff = Diff(file_dict[f_a], delete=True)\n",
    "            uut.apply(Result(\"origin\", \"msg\", diffs={f_a: diff}),\n",
    "                      file_dict,\n",
    "                      file_diff_dict)\n",
    "            self.assertFalse(isfile(f_a))\n",
    "            self.assertTrue(isfile(f_a+\".orig\"))\n",
    "            os.remove(f_a+\".orig\")\n",
    "\n",
    "            diff = Diff(file_dict[f_a])\n",
    "            diff.change_line(3, \"3\\n\", \"3_changed\\n\")\n",
    "            uut.apply(Result(\"origin\", \"msg\", diffs={f_a: diff}),\n",
    "                      file_dict,\n",
    "                      file_diff_dict)\n",
    "            self.assertFalse(isfile(f_a+\".orig\"))\n",
    "            # Recreate file so that context manager make_temp() can delete it\n",
    "            open(f_a, 'w').close()\n",
    "\n",
    "    def test_is_applicable(self):\n",
    "        diff = Diff([\"1\\n\", \"2\\n\", \"3\\n\"])\n",
    "        diff.delete_line(2)\n",
    "        patch_result = Result(\"\", \"\", diffs={'f': diff})\n",
    "        self.assertTrue(\n",
    "            ApplyPatchAction.is_applicable(patch_result, {}, {}))\n",
    "\n",
    "    def test_is_applicable_conflict(self):\n",
    "        diff = Diff([\"1\\n\", \"2\\n\", \"3\\n\"])\n",
    "        diff.add_lines(2, ['a line'])\n",
    "\n",
    "        conflict_result = Result(\"\", \"\", diffs={'f': diff})\n",
    "        # Applying the same diff twice will result in a conflict\n",
    "        self.assertFalse(\n",
    "            ApplyPatchAction.is_applicable(conflict_result, {}, {'f': diff}))\n",
    "\n",
    "    def test_is_applicable_empty_patch(self):\n",
    "        empty_patch_result = Result(\"\", \"\", diffs={})\n",
    "        self.assertFalse(\n",
    "            ApplyPatchAction.is_applicable(empty_patch_result, {}, {}))\n",
    "\n",
    "    def test_is_applicable_without_patch(self):\n",
    "        result = Result(\"\", \"\")\n",
    "        self.assertFalse(ApplyPatchAction.is_applicable(result, {}, {}))\n"
  ],
  "/home/tushar/coala/tests/results/result_actions/OpenEditorActionTest.py": [
    "import os\n",
    "import subprocess\n",
    "import tempfile\n",
    "import unittest\n",
    "\n",
    "from coalib.results.Diff import Diff\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.result_actions.OpenEditorAction import OpenEditorAction\n",
    "from coalib.settings.Section import Section, Setting\n",
    "\n",
    "\n",
    "class OpenEditorActionTest(unittest.TestCase):\n",
    "\n",
    "    @staticmethod\n",
    "    def fake_edit(commands):\n",
    "        filename = commands[1]\n",
    "        with open(filename) as f:\n",
    "            lines = f.readlines()\n",
    "\n",
    "        del lines[1]\n",
    "\n",
    "        with open(filename, \"w\") as f:\n",
    "            f.writelines(lines)\n",
    "\n",
    "    @staticmethod\n",
    "    def fake_edit_subl(commands, stdout):\n",
    "        \"\"\"\n",
    "        Solely the declaration raises an exception if stdout not provided.\n",
    "        \"\"\"\n",
    "        assert (\"--wait\" in commands), \"Did not wait for the editor to close\"\n",
    "\n",
    "    def setUp(self):\n",
    "        fahandle, self.fa = tempfile.mkstemp()\n",
    "        os.close(fahandle)\n",
    "        fbhandle, self.fb = tempfile.mkstemp()\n",
    "        os.close(fbhandle)\n",
    "        self.old_subprocess_call = subprocess.call\n",
    "\n",
    "    def tearDown(self):\n",
    "        os.remove(self.fa)\n",
    "        os.remove(self.fb)\n",
    "        subprocess.call = self.old_subprocess_call\n",
    "\n",
    "    def test_apply(self):\n",
    "        # Initial file contents, *before* a patch was applied\n",
    "        file_dict = {\n",
    "            self.fa: [\"1\\n\", \"2\\n\", \"3\\n\"],\n",
    "            self.fb: [\"1\\n\", \"2\\n\", \"3\\n\"],\n",
    "            \"f_c\": [\"1\\n\", \"2\\n\", \"3\\n\"]}\n",
    "\n",
    "        # A patch that was applied for some reason to make things complicated\n",
    "        diff_dict = {self.fb: Diff(file_dict[self.fb])}\n",
    "        diff_dict[self.fb].change_line(3, \"3\\n\", \"3_changed\\n\")\n",
    "\n",
    "        # File contents after the patch was applied, that's what's in the files\n",
    "        current_file_dict = {\n",
    "            filename: diff_dict[filename].modified\n",
    "            if filename in diff_dict else file_dict[filename]\n",
    "            for filename in (self.fa, self.fb)}\n",
    "        for filename in current_file_dict:\n",
    "            with open(filename, 'w') as handle:\n",
    "                handle.writelines(current_file_dict[filename])\n",
    "\n",
    "        # End file contents after the patch and the OpenEditorAction was\n",
    "        # applied\n",
    "        expected_file_dict = {\n",
    "            self.fa: [\"1\\n\", \"3\\n\"],\n",
    "            self.fb: [\"1\\n\", \"3_changed\\n\"],\n",
    "            \"f_c\": [\"1\\n\", \"2\\n\", \"3\\n\"]}\n",
    "\n",
    "        section = Section(\"\")\n",
    "        section.append(Setting(\"editor\", \"\"))\n",
    "        uut = OpenEditorAction()\n",
    "        subprocess.call = self.fake_edit\n",
    "        diff_dict = uut.apply_from_section(\n",
    "            Result.from_values(\"origin\", \"msg\", self.fa),\n",
    "            file_dict,\n",
    "            diff_dict,\n",
    "            section)\n",
    "        diff_dict = uut.apply_from_section(\n",
    "            Result.from_values(\"origin\", \"msg\", self.fb),\n",
    "            file_dict,\n",
    "            diff_dict,\n",
    "            section)\n",
    "\n",
    "        for filename in diff_dict:\n",
    "            file_dict[filename] = (\n",
    "                diff_dict[filename].modified)\n",
    "\n",
    "        self.assertEqual(file_dict, expected_file_dict)\n",
    "\n",
    "    def test_subl(self):\n",
    "        file_dict = {self.fa: []}\n",
    "        section = Section(\"\")\n",
    "        section.append(Setting(\"editor\", \"subl\"))\n",
    "        uut = OpenEditorAction()\n",
    "        subprocess.call = self.fake_edit_subl\n",
    "        diff_dict = uut.apply_from_section(\n",
    "            Result.from_values(\"origin\", \"msg\", self.fa),\n",
    "            file_dict,\n",
    "            {},\n",
    "            section)\n",
    "        file_dict[self.fa] = diff_dict[self.fa].modified\n",
    "\n",
    "        self.assertEqual(file_dict, file_dict)\n",
    "\n",
    "    def test_is_applicable(self):\n",
    "        result1 = Result(\"\", \"\")\n",
    "        result2 = Result.from_values(\"\", \"\", \"\")\n",
    "        invalid_result = \"\"\n",
    "        self.assertFalse(OpenEditorAction.is_applicable(result1, None, None))\n",
    "        self.assertTrue(OpenEditorAction.is_applicable(result2, None, None))\n",
    "\n",
    "        self.assertFalse(\n",
    "            OpenEditorAction.is_applicable(invalid_result, None, None))\n"
  ],
  "/home/tushar/coala/tests/results/result_actions/PrintDebugMessageActionTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.misc.ContextManagers import retrieve_stdout\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.result_actions.PrintDebugMessageAction import (\n",
    "    PrintDebugMessageAction)\n",
    "from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "class PrintDebugMessageActionTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.uut = PrintDebugMessageAction()\n",
    "        self.test_result = Result(\"origin\", \"message\", debug_msg=\"DEBUG MSG\")\n",
    "\n",
    "    def test_is_applicable(self):\n",
    "        self.assertFalse(self.uut.is_applicable(1, None, None))\n",
    "        self.assertFalse(self.uut.is_applicable(Result(\"o\", \"m\"), None, None))\n",
    "        self.assertTrue(self.uut.is_applicable(self.test_result, None, None))\n",
    "\n",
    "    def test_apply(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            self.assertEqual(self.uut.apply_from_section(self.test_result,\n",
    "                                                         {},\n",
    "                                                         {},\n",
    "                                                         Section(\"name\")),\n",
    "                             {})\n",
    "            self.assertEqual(stdout.getvalue(),\n",
    "                             self.test_result.debug_msg+\"\\n\")\n"
  ],
  "/home/tushar/coala/tests/results/result_actions/PrintMoreInfoActionTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.misc.ContextManagers import retrieve_stdout\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.result_actions.PrintMoreInfoAction import (\n",
    "    PrintMoreInfoAction)\n",
    "from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "class PrintMoreInfoActionTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.uut = PrintMoreInfoAction()\n",
    "        self.test_result = Result(\n",
    "            \"origin\", \"message\",\n",
    "            additional_info=\"A lot of additional information can be found here\")\n",
    "\n",
    "    def test_is_applicable(self):\n",
    "        self.assertFalse(self.uut.is_applicable(1, None, None))\n",
    "        self.assertFalse(self.uut.is_applicable(Result(\"o\", \"m\"), None, None))\n",
    "        self.assertTrue(self.uut.is_applicable(self.test_result, None, None))\n",
    "\n",
    "    def test_apply(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            self.assertEqual(self.uut.apply_from_section(self.test_result,\n",
    "                                                         {},\n",
    "                                                         {},\n",
    "                                                         Section(\"name\")),\n",
    "                             {})\n",
    "            self.assertEqual(stdout.getvalue(),\n",
    "                             self.test_result.additional_info + \"\\n\")\n"
  ],
  "/home/tushar/coala/tests/results/result_actions/ResultActionTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.result_actions.ResultAction import ResultAction\n",
    "from coalib.settings.Section import Section\n",
    "\n",
    "\n",
    "class ResultActionTest(unittest.TestCase):\n",
    "\n",
    "    def test_api(self):\n",
    "        uut = ResultAction()\n",
    "        result = Result(\"\", \"\")\n",
    "\n",
    "        self.assertRaises(NotImplementedError, uut.apply, 5, {}, {})\n",
    "        self.assertRaises(NotImplementedError,\n",
    "                          uut.apply_from_section,\n",
    "                          \"\",\n",
    "                          {},\n",
    "                          {},\n",
    "                          Section(\"name\"))\n",
    "\n",
    "        self.assertRaises(TypeError, uut.apply_from_section, \"\", {}, {}, 5)\n",
    "        self.assertRaises(TypeError,\n",
    "                          uut.apply_from_section,\n",
    "                          \"\",\n",
    "                          5,\n",
    "                          {},\n",
    "                          Section(\"name\"))\n",
    "        self.assertRaises(TypeError,\n",
    "                          uut.apply_from_section,\n",
    "                          \"\",\n",
    "                          {},\n",
    "                          5,\n",
    "                          Section(\"name\"))\n",
    "\n",
    "        self.assertEqual(len(uut.get_metadata().non_optional_params), 0)\n",
    "        self.assertEqual(len(uut.get_metadata().optional_params), 0)\n",
    "        self.assertEqual(uut.get_metadata().name, \"ResultAction\")\n",
    "        self.assertTrue(uut.is_applicable(result, None, None))\n"
  ],
  "/home/tushar/coala/tests/results/result_actions/ShowPatchActionTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.misc.ContextManagers import retrieve_stdout\n",
    "from coalib.results.Diff import Diff\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.result_actions.ShowPatchAction import ShowPatchAction\n",
    "from coalib.settings.Section import Section, Setting\n",
    "\n",
    "\n",
    "class ShowPatchActionTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.uut = ShowPatchAction()\n",
    "        self.file_dict = {\"a\": [\"a\\n\", \"b\\n\", \"c\\n\"], \"b\": [\"old_first\\n\"]}\n",
    "        self.diff_dict = {\"a\": Diff(self.file_dict['a']),\n",
    "                          \"b\": Diff(self.file_dict['b'])}\n",
    "        self.diff_dict[\"a\"].add_lines(1, [\"test\\n\"])\n",
    "        self.diff_dict[\"a\"].delete_line(3)\n",
    "        self.diff_dict[\"b\"].add_lines(0, [\"first\\n\"])\n",
    "\n",
    "        self.test_result = Result(\"origin\", \"message\", diffs=self.diff_dict)\n",
    "        self.section = Section(\"name\")\n",
    "        self.section.append(Setting(\"colored\", \"false\"))\n",
    "\n",
    "    def test_is_applicable(self):\n",
    "        self.assertFalse(self.uut.is_applicable(1, None, None))\n",
    "        self.assertFalse(self.uut.is_applicable(Result(\"o\", \"m\"), None, None))\n",
    "        self.assertTrue(self.uut.is_applicable(self.test_result, {}, {}))\n",
    "        self.assertFalse(self.uut.is_applicable(self.test_result, {},\n",
    "                                                self.diff_dict))\n",
    "\n",
    "    def test_apply(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            self.assertEqual(self.uut.apply_from_section(self.test_result,\n",
    "                                                         self.file_dict,\n",
    "                                                         {},\n",
    "                                                         self.section),\n",
    "                             {})\n",
    "            self.assertEqual(stdout.getvalue(),\n",
    "                             \"|----|    | a\\n\"\n",
    "                             \"|    |++++| a\\n\"\n",
    "                             \"|   1|   1| a\\n\"\n",
    "                             \"|    |   2|+test\\n\"\n",
    "                             \"|   2|   3| b\\n\"\n",
    "                             \"|   3|    |-c\\n\"\n",
    "                             \"|----|    | b\\n\"\n",
    "                             \"|    |++++| b\\n\"\n",
    "                             \"|    |   1|+first\\n\"\n",
    "                             \"|   1|   2| old_first\\n\")\n",
    "\n",
    "    def test_apply_with_previous_patches(self):\n",
    "        with retrieve_stdout() as stdout:\n",
    "            previous_diffs = {\"a\": Diff(self.file_dict['a'])}\n",
    "            previous_diffs[\"a\"].change_line(2, \"b\\n\", \"b_changed\\n\")\n",
    "            self.assertEqual(self.uut.apply_from_section(self.test_result,\n",
    "                                                         self.file_dict,\n",
    "                                                         previous_diffs,\n",
    "                                                         self.section),\n",
    "                             previous_diffs)\n",
    "            self.assertEqual(stdout.getvalue(),\n",
    "                             \"|----|    | a\\n\"\n",
    "                             \"|    |++++| a\\n\"\n",
    "                             \"|   1|   1| a\\n\"\n",
    "                             \"|    |   2|+test\\n\"\n",
    "                             \"|   2|   3| b_changed\\n\"\n",
    "                             \"|   3|    |-c\\n\"\n",
    "                             \"|----|    | b\\n\"\n",
    "                             \"|    |++++| b\\n\"\n",
    "                             \"|    |   1|+first\\n\"\n",
    "                             \"|   1|   2| old_first\\n\")\n"
  ],
  "/home/tushar/coala/tests/results/result_actions/__init__.py": [],
  "/home/tushar/coala/tests/settings/ConfigurationGatheringTest.py": [
    "import os\n",
    "import re\n",
    "import tempfile\n",
    "import unittest\n",
    "\n",
    "from pyprint.ClosableObject import close_objects\n",
    "from pyprint.NullPrinter import NullPrinter\n",
    "\n",
    "from coalib.misc import Constants\n",
    "from coalib.misc.ContextManagers import make_temp, change_directory\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "from coalib.parsing.StringProcessing import escape\n",
    "from coalib.settings.ConfigurationGathering import (\n",
    "    find_user_config, gather_configuration, load_configuration)\n",
    "\n",
    "\n",
    "class ConfigurationGatheringTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.log_printer = LogPrinter(NullPrinter())\n",
    "\n",
    "    def tearDown(self):\n",
    "        close_objects(self.log_printer)\n",
    "\n",
    "    def test_gather_configuration(self):\n",
    "        args = (lambda *args: True, self.log_printer)\n",
    "\n",
    "        # Passing the default coafile name only triggers a warning.\n",
    "        gather_configuration(*args, arg_list=[\"-c abcdefghi/invalid/.coafile\"])\n",
    "\n",
    "        # Using a bad filename explicitly exits coala.\n",
    "        with self.assertRaises(SystemExit):\n",
    "            gather_configuration(\n",
    "                *args,\n",
    "                arg_list=[\"-S\", \"test=5\", \"-c\", \"some_bad_filename\"])\n",
    "\n",
    "        with make_temp() as temporary:\n",
    "            sections, local_bears, global_bears, targets = (\n",
    "                gather_configuration(\n",
    "                    *args,\n",
    "                    arg_list=[\"-S\",\n",
    "                              \"test=5\",\n",
    "                              \"-c\",\n",
    "                              escape(temporary, \"\\\\\"),\n",
    "                              \"-s\"]))\n",
    "\n",
    "        self.assertEqual(str(sections[\"default\"]),\n",
    "                         \"Default {config : \" +\n",
    "                         repr(temporary) + \", save : 'True', test : '5'}\")\n",
    "\n",
    "        with make_temp() as temporary:\n",
    "            sections, local_bears, global_bears, targets = (\n",
    "                gather_configuration(*args,\n",
    "                                     arg_list=[\"-S test=5\",\n",
    "                                               \"-c \" + escape(temporary, \"\\\\\"),\n",
    "                                               \"-b LineCountBear -s\"]))\n",
    "\n",
    "        self.assertEqual(len(local_bears[\"default\"]), 0)\n",
    "\n",
    "    def test_default_coafile_parsing(self):\n",
    "        tmp = Constants.system_coafile\n",
    "\n",
    "        Constants.system_coafile = os.path.abspath(os.path.join(\n",
    "            os.path.dirname(os.path.realpath(__file__)),\n",
    "            \"section_manager_test_files\",\n",
    "            \"default_coafile\"))\n",
    "\n",
    "        sections, local_bears, global_bears, targets = gather_configuration(\n",
    "            lambda *args: True,\n",
    "            self.log_printer,\n",
    "            arg_list=[])\n",
    "\n",
    "        self.assertEqual(str(sections[\"test\"]),\n",
    "                         \"test {value : '1', testval : '5'}\")\n",
    "\n",
    "        Constants.system_coafile = tmp\n",
    "\n",
    "    def test_user_coafile_parsing(self):\n",
    "        tmp = Constants.user_coafile\n",
    "\n",
    "        Constants.user_coafile = os.path.abspath(os.path.join(\n",
    "            os.path.dirname(os.path.realpath(__file__)),\n",
    "            \"section_manager_test_files\",\n",
    "            \"default_coafile\"))\n",
    "\n",
    "        sections, local_bears, global_bears, targets = gather_configuration(\n",
    "            lambda *args: True,\n",
    "            self.log_printer,\n",
    "            arg_list=[])\n",
    "\n",
    "        self.assertEqual(str(sections[\"test\"]),\n",
    "                         \"test {value : '1', testval : '5'}\")\n",
    "\n",
    "        Constants.user_coafile = tmp\n",
    "\n",
    "    def test_nonexistent_file(self):\n",
    "        filename = \"bad.one/test\\neven with bad chars in it\"\n",
    "        with self.assertRaises(SystemExit):\n",
    "            gather_configuration(lambda *args: True,\n",
    "                                 self.log_printer,\n",
    "                                 arg_list=['-S', \"config=\" + filename])\n",
    "\n",
    "        tmp = Constants.system_coafile\n",
    "        Constants.system_coafile = filename\n",
    "\n",
    "        with self.assertRaises(SystemExit):\n",
    "            gather_configuration(lambda *args: True,\n",
    "                                 self.log_printer,\n",
    "                                 arg_list=[])\n",
    "\n",
    "        Constants.system_coafile = tmp\n",
    "\n",
    "    def test_merge(self):\n",
    "        tmp = Constants.system_coafile\n",
    "        Constants.system_coafile = os.path.abspath(os.path.join(\n",
    "            os.path.dirname(os.path.realpath(__file__)),\n",
    "            \"section_manager_test_files\",\n",
    "            \"default_coafile\"))\n",
    "\n",
    "        config = os.path.abspath(os.path.join(\n",
    "            os.path.dirname(os.path.realpath(__file__)),\n",
    "            \"section_manager_test_files\",\n",
    "            \".coafile\"))\n",
    "\n",
    "        # Check merging of default_coafile and .coafile\n",
    "        sections, local_bears, global_bears, targets = gather_configuration(\n",
    "            lambda *args: True,\n",
    "            self.log_printer,\n",
    "            arg_list=[\"-c\", re.escape(config)])\n",
    "\n",
    "        self.assertEqual(str(sections[\"test\"]),\n",
    "                         \"test {value : '2'}\")\n",
    "        self.assertEqual(str(sections[\"test-2\"]),\n",
    "                         \"test-2 {files : '.', bears : 'LineCountBear'}\")\n",
    "\n",
    "        # Check merging of default_coafile, .coafile and cli\n",
    "        sections, local_bears, global_bears, targets = gather_configuration(\n",
    "            lambda *args: True,\n",
    "            self.log_printer,\n",
    "            arg_list=[\"-c\",\n",
    "                      re.escape(config),\n",
    "                      \"-S\",\n",
    "                      \"test.value=3\",\n",
    "                      \"test-2.bears=\",\n",
    "                      \"test-5.bears=TestBear2\"])\n",
    "\n",
    "        self.assertEqual(str(sections[\"test\"]), \"test {value : '3'}\")\n",
    "        self.assertEqual(str(sections[\"test-2\"]),\n",
    "                         \"test-2 {files : '.', bears : ''}\")\n",
    "        self.assertEqual(str(sections[\"test-3\"]),\n",
    "                         \"test-3 {files : 'MakeFile'}\")\n",
    "        self.assertEqual(str(sections[\"test-4\"]),\n",
    "                         \"test-4 {bears : 'TestBear'}\")\n",
    "        self.assertEqual(str(sections[\"test-5\"]),\n",
    "                         \"test-5 {bears : 'TestBear2'}\")\n",
    "\n",
    "        Constants.system_coafile = tmp\n",
    "\n",
    "    def test_merge_defaults(self):\n",
    "        with make_temp() as temporary:\n",
    "            sections, local_bears, global_bears, targets = (\n",
    "                gather_configuration(lambda *args: True,\n",
    "                                     self.log_printer,\n",
    "                                     arg_list=[\"-S\",\n",
    "                                               \"value=1\",\n",
    "                                               \"test.value=2\",\n",
    "                                               \"-c\",\n",
    "                                               escape(temporary, \"\\\\\")]))\n",
    "\n",
    "        self.assertEqual(sections[\"default\"],\n",
    "                         sections[\"test\"].defaults)\n",
    "\n",
    "    def test_back_saving(self):\n",
    "        filename = os.path.join(tempfile.gettempdir(),\n",
    "                                \"SectionManagerTestFile\")\n",
    "\n",
    "        # We need to use a bad filename or this will parse coalas .coafile\n",
    "        gather_configuration(\n",
    "            lambda *args: True,\n",
    "            self.log_printer,\n",
    "            arg_list=['-S',\n",
    "                      \"save=\" + escape(filename, '\\\\'),\n",
    "                      \"-c=some_bad_filename\"])\n",
    "\n",
    "        with open(filename, \"r\") as f:\n",
    "            lines = f.readlines()\n",
    "        self.assertEqual([\"[Default]\\n\", \"config = some_bad_filename\\n\"], lines)\n",
    "\n",
    "        gather_configuration(\n",
    "            lambda *args: True,\n",
    "            self.log_printer,\n",
    "            arg_list=['-S',\n",
    "                      \"save=true\",\n",
    "                      \"config=\" + escape(filename, '\\\\'),\n",
    "                      \"test.value=5\"])\n",
    "\n",
    "        with open(filename, \"r\") as f:\n",
    "            lines = f.readlines()\n",
    "        os.remove(filename)\n",
    "        if os.path.sep == '\\\\':\n",
    "            filename = escape(filename, '\\\\')\n",
    "        self.assertEqual([\"[Default]\\n\",\n",
    "                          \"config = \" + filename + \"\\n\",\n",
    "                          \"\\n\",\n",
    "                          \"[test]\\n\",\n",
    "                          \"value = 5\\n\"], lines)\n",
    "\n",
    "    def test_targets(self):\n",
    "        sections, local_bears, global_bears, targets = gather_configuration(\n",
    "            lambda *args: True,\n",
    "            self.log_printer,\n",
    "            arg_list=[\"default\", \"test1\", \"test2\"])\n",
    "\n",
    "        self.assertEqual(targets, [\"default\", \"test1\", \"test2\"])\n",
    "\n",
    "    def test_find_user_config(self):\n",
    "        current_dir = os.path.abspath(os.path.dirname(__file__))\n",
    "        c_file = os.path.join(current_dir,\n",
    "                              \"section_manager_test_files\",\n",
    "                              \"project\",\n",
    "                              \"test.c\")\n",
    "\n",
    "        retval = find_user_config(c_file, 1)\n",
    "        self.assertEqual(\"\", retval)\n",
    "\n",
    "        retval = find_user_config(c_file, 2)\n",
    "        self.assertEqual(os.path.join(current_dir,\n",
    "                                      \"section_manager_test_files\",\n",
    "                                      \".coafile\"), retval)\n",
    "\n",
    "        child_dir = os.path.join(current_dir,\n",
    "                                 \"section_manager_test_files\",\n",
    "                                 \"child_dir\")\n",
    "        retval = find_user_config(child_dir, 2)\n",
    "        self.assertEqual(os.path.join(current_dir,\n",
    "                                      \"section_manager_test_files\",\n",
    "                                      \"child_dir\",\n",
    "                                      \".coafile\"), retval)\n",
    "\n",
    "        with change_directory(child_dir):\n",
    "            sections, _, _, _ = gather_configuration(\n",
    "                lambda *args: True,\n",
    "                self.log_printer,\n",
    "                arg_list=[\"--find-config\"])\n",
    "            self.assertEqual(bool(sections[\"default\"]['find_config']), True)\n",
    "\n",
    "    def test_no_config(self):\n",
    "        current_dir = os.path.abspath(os.path.dirname(__file__))\n",
    "        child_dir = os.path.join(current_dir,\n",
    "                                 \"section_manager_test_files\",\n",
    "                                 \"child_dir\")\n",
    "        with change_directory(child_dir):\n",
    "            sections, targets = load_configuration([], self.log_printer)\n",
    "            self.assertIn('value', sections[\"default\"])\n",
    "\n",
    "            sections, targets = load_configuration(\n",
    "                ['--no-config'],\n",
    "                self.log_printer)\n",
    "            self.assertNotIn('value', sections[\"default\"])\n",
    "\n",
    "            sections, targets = load_configuration(\n",
    "                ['--no-config', '-S', 'use_spaces=True'],\n",
    "                self.log_printer)\n",
    "            self.assertIn('use_spaces', sections[\"default\"])\n",
    "            self.assertNotIn('values', sections[\"default\"])\n",
    "\n",
    "            sections, targets = load_configuration(\n",
    "                ['--no-config', 'False', '-S', 'use_spaces=True'],\n",
    "                self.log_printer)\n",
    "            self.assertIn('use_spaces', sections[\"default\"])\n",
    "            self.assertIn('value', sections[\"default\"])\n",
    "\n",
    "            with self.assertRaises(SystemExit) as cm:\n",
    "                sections, target = load_configuration(\n",
    "                    ['--no-config', '--save'],\n",
    "                    self.log_printer)\n",
    "                self.assertEqual(cm.exception.code, 2)\n",
    "\n",
    "            with self.assertRaises(SystemExit) as cm:\n",
    "                sections, target = load_configuration(\n",
    "                    ['--no-config', '--find-config'],\n",
    "                    self.log_printer)\n",
    "                self.assertEqual(cm.exception.code, 2)\n",
    "\n",
    "    def test_autoapply_arg(self):\n",
    "        sections, _, _, _ = gather_configuration(\n",
    "            lambda *args: True,\n",
    "            self.log_printer,\n",
    "            autoapply=False,\n",
    "            arg_list=[])\n",
    "\n",
    "        self.assertEqual(str(sections['default'].get('autoapply', None)),\n",
    "                         'False')\n",
    "\n",
    "        sections, _, _, _ = gather_configuration(\n",
    "            lambda *args: True,\n",
    "            self.log_printer,\n",
    "            autoapply=True,\n",
    "            arg_list=[])\n",
    "\n",
    "        self.assertEqual(str(sections['default'].get('autoapply', None)),\n",
    "                         'None')\n"
  ],
  "/home/tushar/coala/tests/settings/DocstringMetadataTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.settings.DocstringMetadata import DocstringMetadata\n",
    "\n",
    "\n",
    "class DocstringMetadataTest(unittest.TestCase):\n",
    "\n",
    "    def test_from_docstring(self):\n",
    "        self.check_from_docstring_dataset(\"\")\n",
    "        self.check_from_docstring_dataset(\" description only \",\n",
    "                                          desc=\"description only\")\n",
    "        self.check_from_docstring_dataset(\" :param test:  test description \",\n",
    "                                          param_dict={\n",
    "                                              \"test\": \"test description\"})\n",
    "        self.check_from_docstring_dataset(\" @param test:  test description \",\n",
    "                                          param_dict={\n",
    "                                              \"test\": \"test description\"})\n",
    "        self.check_from_docstring_dataset(\" :return: something \",\n",
    "                                          retval_desc=\"something\")\n",
    "        self.check_from_docstring_dataset(\" @return: something \",\n",
    "                                          retval_desc=\"something\")\n",
    "        self.check_from_docstring_dataset(\"\"\"\n",
    "        Main description\n",
    "\n",
    "        @param p1: this is\n",
    "\n",
    "        a multiline desc for p1\n",
    "\n",
    "        :param p2: p2 description\n",
    "\n",
    "        @return: retval description\n",
    "        :return: retval description\n",
    "        override\n",
    "        \"\"\", desc=\"Main description\", param_dict={\n",
    "            \"p1\": \"this is\\na multiline desc for p1\\n\",\n",
    "            \"p2\": \"p2 description\\n\"\n",
    "        }, retval_desc=\"retval description override\")\n",
    "\n",
    "    def test_str(self):\n",
    "        uut = DocstringMetadata.from_docstring(\n",
    "            '''\n",
    "            Description of something. No params.\n",
    "            ''')\n",
    "\n",
    "        self.assertEqual(str(uut), \"Description of something. No params.\")\n",
    "\n",
    "        uut = DocstringMetadata.from_docstring(\n",
    "            '''\n",
    "            Description of something with params.\n",
    "\n",
    "            :param x: Imagine something.\n",
    "            :param y: x^2\n",
    "            ''')\n",
    "\n",
    "        self.assertEqual(str(uut), \"Description of something with params.\")\n",
    "\n",
    "    def check_from_docstring_dataset(self,\n",
    "                                     docstring,\n",
    "                                     desc=\"\",\n",
    "                                     param_dict=None,\n",
    "                                     retval_desc=\"\"):\n",
    "        param_dict = param_dict or {}\n",
    "\n",
    "        self.assertIsInstance(docstring,\n",
    "                              str,\n",
    "                              \"docstring needs to be a string for this test.\")\n",
    "        doc_comment = DocstringMetadata.from_docstring(docstring)\n",
    "        self.assertEqual(doc_comment.desc, desc)\n",
    "        self.assertEqual(doc_comment.param_dict, param_dict)\n",
    "\n",
    "        self.assertEqual(doc_comment.retval_desc, retval_desc)\n"
  ],
  "/home/tushar/coala/tests/settings/FunctionMetadataTest.py": [
    "import unittest\n",
    "\n",
    "from coalib.settings.FunctionMetadata import FunctionMetadata\n",
    "from coalib.settings.Section import Section\n",
    "from coalib.settings.Setting import Setting\n",
    "\n",
    "\n",
    "class TestClass:\n",
    "\n",
    "    def __init__(self, param1, param2, param3=5, param4: int=6):\n",
    "        \"\"\"\n",
    "        Description\n",
    "\n",
    "        :param param2: d\n",
    "        :param param4: p4 desc\n",
    "        :return:       ret\n",
    "        \"\"\"\n",
    "\n",
    "    def good_function(self, a_param: int):\n",
    "        pass\n",
    "\n",
    "    def bad_function(self, bad_param: \"no function\"):\n",
    "        pass\n",
    "\n",
    "\n",
    "class FunctionMetadataTest(unittest.TestCase):\n",
    "\n",
    "    def test_construction(self):\n",
    "        self.check_function_metadata_data_set(FunctionMetadata(\"name\"), \"name\")\n",
    "\n",
    "    def test_from_function(self):\n",
    "        uut = FunctionMetadata.from_function(self.test_from_function)\n",
    "        self.check_function_metadata_data_set(uut, \"test_from_function\")\n",
    "        # setattr on bound methods will fail, vars() will use the dict from\n",
    "        # the unbound method which is ok.\n",
    "        vars(self.test_from_function)[\"__metadata__\"] = (\n",
    "            FunctionMetadata(\"t\"))\n",
    "        uut = FunctionMetadata.from_function(self.test_from_function)\n",
    "        self.check_function_metadata_data_set(uut, \"t\")\n",
    "\n",
    "        uut = FunctionMetadata.from_function(TestClass(5, 5).__init__)\n",
    "        self.check_function_metadata_data_set(\n",
    "            uut,\n",
    "            \"__init__\",\n",
    "            desc=\"Description\",\n",
    "            retval_desc=\"ret\",\n",
    "            non_optional_params={\n",
    "                \"param1\": (uut.str_nodesc, None),\n",
    "                \"param2\": (\"d\", None)\n",
    "            },\n",
    "            optional_params={\n",
    "                \"param3\": (uut.str_nodesc + \" (\"\n",
    "                           + uut.str_optional.format(\"5\") + \")\",\n",
    "                           None, 5),\n",
    "                \"param4\": (\"p4 desc (\"\n",
    "                           + uut.str_optional.format(\"6\") + \")\", int, 6)})\n",
    "\n",
    "        uut = FunctionMetadata.from_function(TestClass(5, 5).__init__,\n",
    "                                             omit={\"param3\", \"param2\"})\n",
    "        self.check_function_metadata_data_set(\n",
    "            uut,\n",
    "            \"__init__\",\n",
    "            desc=\"Description\",\n",
    "            retval_desc=\"ret\",\n",
    "            non_optional_params={\n",
    "                \"param1\": (uut.str_nodesc,\n",
    "                           None)\n",
    "            },\n",
    "            optional_params={\n",
    "                \"param4\": (\"p4 desc (\" + uut.str_optional.format(\"6\") + \")\",\n",
    "                           int,\n",
    "                           6)})\n",
    "\n",
    "    def test_create_params_from_section_invalid(self):\n",
    "        section = Section(\"name\")\n",
    "        section.append(Setting(\"bad_param\", \"value\"))\n",
    "        uut = FunctionMetadata.from_function(TestClass(5, 5).bad_function)\n",
    "\n",
    "        with self.assertRaises(ValueError):\n",
    "            uut.create_params_from_section(section)\n",
    "\n",
    "    def test_create_params_from_section_valid(self):\n",
    "        section = Section(\"name\")\n",
    "        section.append(Setting(\"a_param\", \"value\"))\n",
    "        uut = FunctionMetadata.from_function(TestClass(5, 5).good_function)\n",
    "\n",
    "        with self.assertRaises(ValueError):\n",
    "            uut.create_params_from_section(section)\n",
    "\n",
    "        section.append(Setting(\"a_param\", \"5\"))\n",
    "        params = uut.create_params_from_section(section)\n",
    "        self.assertEqual(params['a_param'], 5)\n",
    "\n",
    "    def check_function_metadata_data_set(self,\n",
    "                                         metadata,\n",
    "                                         name,\n",
    "                                         desc=\"\",\n",
    "                                         retval_desc=\"\",\n",
    "                                         non_optional_params=None,\n",
    "                                         optional_params=None):\n",
    "        non_optional_params = non_optional_params or {}\n",
    "        optional_params = optional_params or {}\n",
    "\n",
    "        self.assertEqual(metadata.name, name)\n",
    "        self.assertEqual(metadata.desc, desc)\n",
    "        self.assertEqual(metadata.retval_desc, retval_desc)\n",
    "        self.assertEqual(metadata.non_optional_params, non_optional_params)\n",
    "        self.assertEqual(metadata.optional_params, optional_params)\n",
    "\n",
    "    def test_merge(self):\n",
    "        metadata1 = FunctionMetadata(\n",
    "            \"main\",\n",
    "            \"Desc of main.\\n\",\n",
    "            \"Returns 0 on success\",\n",
    "            {\"argc\": (\"argc desc\", None), \"argv\": (\"argv desc\", None)},\n",
    "            {\"opt\": (\"opt desc\", int, 88)},\n",
    "            {\"self\", \"A\"})\n",
    "\n",
    "        metadata2 = FunctionMetadata(\n",
    "            \"process\",\n",
    "            \"Desc of process.\\n\",\n",
    "            \"Returns the processed stuff.\",\n",
    "            {\"argc\": (\"argc desc from process\", int),\n",
    "             \"to_process\": (\"to_process desc\", int)},\n",
    "            {\"opt2\": (\"opt2 desc\", str, \"hello\")},\n",
    "            {\"self\", \"B\"})\n",
    "\n",
    "        metadata3 = FunctionMetadata(\"nodesc\", \"\", \"\", {}, {})\n",
    "\n",
    "        merged_metadata = FunctionMetadata.merge(metadata1,\n",
    "                                                 metadata2,\n",
    "                                                 metadata3)\n",
    "\n",
    "        self.assertEqual(\n",
    "            merged_metadata.name,\n",
    "            \"<Merged signature of 'main', 'process', 'nodesc'>\")\n",
    "        self.assertEqual(merged_metadata.desc, \"Desc of process.\\n\")\n",
    "        self.assertEqual(merged_metadata.retval_desc,\n",
    "                         \"Returns the processed stuff.\")\n",
    "        self.assertEqual(\n",
    "            merged_metadata.non_optional_params,\n",
    "            {\"argc\": (\"argc desc from process\", int),\n",
    "             \"argv\": (\"argv desc\", None),\n",
    "             \"to_process\": (\"to_process desc\", int)})\n",
    "        self.assertEqual(\n",
    "            merged_metadata.optional_params,\n",
    "            {\"opt\": (\"opt desc\", int, 88),\n",
    "             \"opt2\": (\"opt2 desc\", str, \"hello\")})\n",
    "        self.assertEqual(\n",
    "            merged_metadata.omit,\n",
    "            frozenset({\"self\", \"A\", \"B\"}))\n"
  ],
  "/home/tushar/coala/tests/settings/SectionFillingTest.py": [
    "import unittest\n",
    "\n",
    "from pyprint.ConsolePrinter import ConsolePrinter\n",
    "\n",
    "from coalib.bears.GlobalBear import GlobalBear\n",
    "from coalib.bears.LocalBear import LocalBear\n",
    "from coalib.misc.ContextManagers import simulate_console_inputs\n",
    "from coalib.output.ConsoleInteraction import acquire_settings\n",
    "from coalib.output.printers.LogPrinter import LogPrinter\n",
    "from coalib.settings.Section import Section\n",
    "from coalib.settings.SectionFilling import Setting, fill_section, fill_settings\n",
    "from tests.TestUtilities import bear_test_module\n",
    "\n",
    "\n",
    "class GlobalTestBear(GlobalBear):\n",
    "\n",
    "    def __init__(self):\n",
    "        GlobalBear.__init__(self, {}, Section(\"irrelevant\"), None)\n",
    "\n",
    "    @staticmethod\n",
    "    def get_non_optional_settings():\n",
    "        return {\"global name\": \"global help text\",\n",
    "                \"key\": \"this setting does exist\"}\n",
    "\n",
    "\n",
    "class LocalTestBear(LocalBear):\n",
    "\n",
    "    def __init__(self):\n",
    "        LocalBear.__init__(self, [], \"\", Section(\"irrelevant\"), None)\n",
    "\n",
    "    @staticmethod\n",
    "    def get_non_optional_settings():\n",
    "        return {\"local name\": \"local help text\",\n",
    "                \"global name\": \"this setting is needed by two bears\"}\n",
    "\n",
    "\n",
    "class SectionFillingTest(unittest.TestCase):\n",
    "\n",
    "    def setUp(self):\n",
    "        self.log_printer = LogPrinter(ConsolePrinter())\n",
    "        self.section = Section(\"test\")\n",
    "        self.section.append(Setting(\"key\", \"val\"))\n",
    "\n",
    "    def test_fill_settings(self):\n",
    "        sections = {\"test\": self.section}\n",
    "        with simulate_console_inputs() as generator:\n",
    "            fill_settings(sections,\n",
    "                          acquire_settings,\n",
    "                          self.log_printer)\n",
    "            self.assertEqual(generator.last_input, -1)\n",
    "\n",
    "        self.section.append(Setting(\"bears\", \"SpaceConsistencyTestBear\"))\n",
    "\n",
    "        with simulate_console_inputs(\"True\"), bear_test_module():\n",
    "            local_bears, global_bears = fill_settings(sections,\n",
    "                                                      acquire_settings,\n",
    "                                                      self.log_printer)\n",
    "            self.assertEqual(len(local_bears[\"test\"]), 1)\n",
    "            self.assertEqual(len(global_bears[\"test\"]), 0)\n",
    "\n",
    "        self.assertEqual(bool(self.section[\"use_spaces\"]), True)\n",
    "        self.assertEqual(len(self.section.contents), 3)\n",
    "\n",
    "    def test_fill_section(self):\n",
    "        # Use the same value for both because order isn't predictable (uses\n",
    "        # dict)\n",
    "        with simulate_console_inputs(0, 0):\n",
    "            new_section = fill_section(self.section,\n",
    "                                       acquire_settings,\n",
    "                                       self.log_printer,\n",
    "                                       [LocalTestBear,\n",
    "                                        GlobalTestBear,\n",
    "                                        \"an inappropriate string object here\"])\n",
    "\n",
    "        self.assertEqual(int(new_section[\"local name\"]), 0)\n",
    "        self.assertEqual(int(new_section[\"global name\"]), 0)\n",
    "        self.assertEqual(new_section[\"key\"].value, \"val\")\n",
    "        self.assertEqual(len(new_section.contents), 3)\n",
    "\n",
    "        # Shouldnt change anything the second time\n",
    "        new_section = fill_section(self.section,\n",
    "                                   acquire_settings,\n",
    "                                   self.log_printer,\n",
    "                                   [LocalTestBear, GlobalTestBear])\n",
    "\n",
    "        self.assertTrue(\"local name\" in new_section)\n",
    "        self.assertTrue(\"global name\" in new_section)\n",
    "        self.assertEqual(new_section[\"key\"].value, \"val\")\n",
    "        self.assertEqual(len(new_section.contents), 3)\n"
  ],
  "/home/tushar/coala/tests/settings/SectionTest.py": [
    "import unittest\n",
    "import os\n",
    "\n",
    "from coalib.misc import Constants\n",
    "from coalib.settings.Section import Section, Setting, append_to_sections\n",
    "from coalib.settings.ConfigurationGathering import get_config_directory\n",
    "from coalib.parsing.Globbing import glob_escape\n",
    "\n",
    "\n",
    "class SectionTest(unittest.TestCase):\n",
    "\n",
    "    def test_construction(self):\n",
    "        uut = Section(Constants.COMPLEX_TEST_STRING, None)\n",
    "        uut = Section(Constants.COMPLEX_TEST_STRING, uut)\n",
    "        self.assertRaises(TypeError, Section, \"irrelevant\", 5)\n",
    "        self.assertRaises(ValueError, uut.__init__, \"name\", uut)\n",
    "\n",
    "    def test_append(self):\n",
    "        uut = Section(Constants.COMPLEX_TEST_STRING, None)\n",
    "        self.assertRaises(TypeError, uut.append, 5)\n",
    "        uut.append(Setting(5, 5, 5))\n",
    "        self.assertEqual(str(uut.get(\"5 \")), \"5\")\n",
    "        self.assertEqual(int(uut.get(\"nonexistent\", 5)), 5)\n",
    "\n",
    "    def test_enabled(self):\n",
    "        uut = Section(\"name\")\n",
    "        self.assertTrue(uut.is_enabled([]))\n",
    "        self.assertTrue(uut.is_enabled([\"name\", \"wrongname\"]))\n",
    "        self.assertFalse(uut.is_enabled([\"wrongname\"]))\n",
    "\n",
    "        uut.append(Setting(\"enabled\", \"false\"))\n",
    "        self.assertFalse(uut.is_enabled([]))\n",
    "        self.assertFalse(uut.is_enabled([\"wrong_name\"]))\n",
    "        self.assertTrue(uut.is_enabled([\"name\", \"wrongname\"]))\n",
    "\n",
    "    def test_iter(self):\n",
    "        defaults = Section(\"default\", None)\n",
    "        uut = Section(\"name\", defaults)\n",
    "        uut.append(Setting(5, 5, 5))\n",
    "        uut.add_or_create_setting(Setting(\"TEsT\", 4, 5))\n",
    "        defaults.append(Setting(\"tEsT\", 1, 3))\n",
    "        defaults.append(Setting(\" great   \", 3, 8))\n",
    "        defaults.append(Setting(\" great   \", 3, 8), custom_key=\"custom\")\n",
    "        uut.add_or_create_setting(Setting(\" NEW   \", \"val\", 8))\n",
    "        uut.add_or_create_setting(Setting(\" NEW   \", \"vl\", 8),\n",
    "                                  allow_appending=False)\n",
    "        uut.add_or_create_setting(Setting(\"new\", \"val\", 9),\n",
    "                                  custom_key=\"teSt \",\n",
    "                                  allow_appending=True)\n",
    "        self.assertEqual(list(uut), [\"5\", \"test\", \"new\", \"great\", \"custom\"])\n",
    "\n",
    "        for index in uut:\n",
    "            t = uut[index]\n",
    "            self.assertNotEqual(t, None)\n",
    "\n",
    "        self.assertIn(\"teST\", defaults)\n",
    "        self.assertIn(\"       GREAT\", defaults)\n",
    "        self.assertNotIn(\"       GrEAT !\", defaults)\n",
    "        self.assertNotIn(\"\", defaults)\n",
    "        self.assertEqual(str(uut['test']), \"4\\nval\")\n",
    "        self.assertEqual(int(uut[\"GREAT \"]), 3)\n",
    "        self.assertRaises(IndexError, uut.__getitem__, \"doesnotexist\")\n",
    "        self.assertRaises(IndexError, uut.__getitem__, \"great\", True)\n",
    "        self.assertRaises(IndexError, uut.__getitem__, \" \")\n",
    "\n",
    "    def test_setitem(self):\n",
    "        uut = Section(\"section\", None)\n",
    "        uut[\"key1\"] = \"value1\"\n",
    "        self.assertEqual(str(uut), \"section {key1 : 'value1'}\")\n",
    "        uut[\"key1\"] = \"changed_value1\"\n",
    "        self.assertEqual(str(uut), \"section {key1 : 'changed_value1'}\")\n",
    "        uut[\"key1\"] = Setting(\"any key\", \"value1\")\n",
    "        self.assertEqual(str(uut), \"section {key1 : 'value1'}\")\n",
    "\n",
    "    def test_string_conversion(self):\n",
    "        uut = Section(\"name\")\n",
    "        self.assertEqual(str(uut), \"name {}\")\n",
    "        uut.append(Setting(\"key\", \"value\"))\n",
    "        self.assertEqual(str(uut), \"name {key : 'value'}\")\n",
    "        uut.append(Setting(\"another_key\", \"another_value\"))\n",
    "        self.assertEqual(str(uut),\n",
    "                         \"name {key : 'value', another_key : 'another_value'}\")\n",
    "\n",
    "    def test_copy(self):\n",
    "        uut = Section(\"name\")\n",
    "        uut.append(Setting(\"key\", \"value\"))\n",
    "        self.assertEqual(str(uut[\"key\"]), \"value\")\n",
    "        copy = uut.copy()\n",
    "        self.assertEqual(str(copy), str(uut))\n",
    "        uut.append(Setting(\"key\", \"another_value\"))\n",
    "        self.assertNotEqual(str(copy), str(uut))\n",
    "\n",
    "        uut.defaults = copy\n",
    "        copy = uut.copy()\n",
    "        self.assertEqual(str(uut.defaults), str(copy.defaults))\n",
    "        uut.defaults.append(Setting(\"key\", \"quite_something_else\"))\n",
    "        self.assertNotEqual(str(uut.defaults), str(copy.defaults))\n",
    "\n",
    "    def test_update(self):\n",
    "        cli = Section(\"cli\", None)\n",
    "        conf = Section(\"conf\", None)\n",
    "\n",
    "        self.assertRaises(TypeError, cli.update, 4)\n",
    "\n",
    "        cli.append(Setting(\"key1\", \"value11\"))\n",
    "        cli.append(Setting(\"key2\", \"value12\"))\n",
    "        conf.append(Setting(\"key1\", \"value21\"))\n",
    "        conf.append(Setting(\"key3\", \"value23\"))\n",
    "\n",
    "        # Values are overwritten, new keys appended\n",
    "        self.assertEqual(str(conf.copy().update(cli)),\n",
    "                         \"conf {key1 : 'value11', key3 : 'value23', \"\n",
    "                         \"key2 : 'value12'}\")\n",
    "\n",
    "        cli.defaults = Section(\"clidef\", None)\n",
    "        cli.defaults.append(Setting(\"def1\", \"dval1\"))\n",
    "\n",
    "        self.assertEqual(str(conf.copy().update(cli).defaults),\n",
    "                         \"clidef {def1 : 'dval1'}\")\n",
    "\n",
    "        conf.defaults = Section(\"confdef\", None)\n",
    "        conf.defaults.append(Setting(\"def2\", \"dval2\"))\n",
    "\n",
    "        self.assertEqual(str(conf.copy().update(cli).defaults),\n",
    "                         \"confdef {def2 : 'dval2', def1 : 'dval1'}\")\n",
    "\n",
    "    def test_append_to_sections(self):\n",
    "        sections = {}\n",
    "\n",
    "        append_to_sections(sections, \"\", \"\", \"\")\n",
    "        self.assertEqual(sections, {})\n",
    "\n",
    "        append_to_sections(sections, \"key\", None, \"\")\n",
    "        self.assertEqual(sections, {})\n",
    "\n",
    "        append_to_sections(sections, \"test\", \"val\", \"origin\")\n",
    "        self.assertIn(\"default\", sections)\n",
    "        self.assertEqual(len(sections), 1)\n",
    "        self.assertEqual(len(sections[\"default\"].contents), 1)\n",
    "\n",
    "        append_to_sections(sections, \"test1\", \"val\", \"origin\", \"default\")\n",
    "        self.assertIn(\"default\", sections)\n",
    "        self.assertEqual(len(sections), 1)\n",
    "        self.assertEqual(len(sections[\"default\"].contents), 2)\n",
    "\n",
    "    def test_update_setting(self):\n",
    "        section = Section(\"section\", None)\n",
    "\n",
    "        section.append(Setting(\"key1\", \"value11\"))\n",
    "        section.append(Setting(\"key2\", \"value12\"))\n",
    "\n",
    "        section.update_setting(\"key1\", new_value=\"value13\")\n",
    "        self.assertEqual(str(section),\n",
    "                         \"section {key1 : 'value13', key2 : 'value12'}\")\n",
    "        section.update_setting(\"key1\", \"key3\")\n",
    "        self.assertEqual(str(section),\n",
    "                         \"section {key3 : 'value13', key2 : 'value12'}\")\n",
    "        section.update_setting(\"key3\", \"key4\", \"value14\")\n",
    "        self.assertEqual(str(section),\n",
    "                         \"section {key4 : 'value14', key2 : 'value12'}\")\n",
    "\n",
    "    def test_delete_setting(self):\n",
    "        section = Section(\"section\", None)\n",
    "\n",
    "        section.append(Setting(\"key1\", \"value11\"))\n",
    "        section.append(Setting(\"key2\", \"value12\"))\n",
    "\n",
    "        section.delete_setting(\"key1\")\n",
    "        self.assertEqual(str(section),\n",
    "                         \"section {key2 : 'value12'}\")\n",
    "\n",
    "        section.append(Setting(\"key3\", \"value13\"))\n",
    "        section.append(Setting(\"key4\", \"value14\"))\n",
    "\n",
    "        section.delete_setting(\"key3\")\n",
    "        self.assertEqual(str(section),\n",
    "                         \"section {key2 : 'value12', key4 : 'value14'}\")\n",
    "\n",
    "    def test_bear_dirs(self):\n",
    "        section = Section(\"section\", None)\n",
    "        empty_bear_dirs_len = len(section.bear_dirs())\n",
    "        section.append(Setting(\"bear_dirs\", \"test1, test2 (1)\"))\n",
    "        self.assertEqual(len(section.bear_dirs()), empty_bear_dirs_len + 2)\n",
    "        # Verify if bear directories are properly escaped\n",
    "        root = get_config_directory(section)\n",
    "        path = os.path.join(glob_escape(root), glob_escape(\"test2 (1)\"), \"**\")\n",
    "        self.assertIn(path, section.bear_dirs())\n"
  ],
  "/home/tushar/coala/tests/settings/SettingTest.py": [
    "import os\n",
    "import re\n",
    "import unittest\n",
    "from collections import OrderedDict\n",
    "\n",
    "from coalib.settings.Setting import (\n",
    "    Setting, path, path_list, url, typed_dict, typed_list, typed_ordered_dict,\n",
    "    glob, glob_list)\n",
    "from coalib.parsing.Globbing import glob_escape\n",
    "\n",
    "\n",
    "class SettingTest(unittest.TestCase):\n",
    "\n",
    "    def test_construction(self):\n",
    "        self.assertRaises(ValueError, Setting, \"\", 2, 2)\n",
    "        self.assertRaises(TypeError, Setting, \"\", \"\", \"\", from_cli=5)\n",
    "\n",
    "    def test_path(self):\n",
    "        self.uut = Setting(\"key\", \" 22\\n\", \".\" + os.path.sep, True)\n",
    "        self.assertEqual(path(self.uut),\n",
    "                         os.path.abspath(os.path.join(\".\", \"22\")))\n",
    "\n",
    "        abspath = os.path.abspath(\".\")\n",
    "        self.uut = Setting(\"key\", re.escape(abspath))\n",
    "        self.assertEqual(path(self.uut), abspath)\n",
    "\n",
    "        self.uut = Setting(\"key\", \" 22\", \"\")\n",
    "        self.assertRaises(ValueError, path, self.uut)\n",
    "        self.assertEqual(path(self.uut,\n",
    "                              origin=\"test\" + os.path.sep),\n",
    "                         os.path.abspath(os.path.join(\"test\", \"22\")))\n",
    "\n",
    "    def test_glob(self):\n",
    "        self.uut = Setting(\"key\", \".\",\n",
    "                           origin=os.path.join(\"test (1)\", \"somefile\"))\n",
    "        self.assertEqual(glob(self.uut),\n",
    "                         glob_escape(os.path.abspath(\"test (1)\")))\n",
    "\n",
    "    def test_path_list(self):\n",
    "        abspath = os.path.abspath(\".\")\n",
    "        # Need to escape backslashes since we use list conversion\n",
    "        self.uut = Setting(\"key\", \"., \" + abspath.replace(\"\\\\\", \"\\\\\\\\\"),\n",
    "                           origin=os.path.join(\"test\", \"somefile\"))\n",
    "        self.assertEqual(path_list(self.uut),\n",
    "                         [os.path.abspath(os.path.join(\"test\", \".\")), abspath])\n",
    "\n",
    "    def test_url(self):\n",
    "        uut = Setting(\"key\", \"http://google.com\")\n",
    "        self.assertEqual(url(uut), \"http://google.com\")\n",
    "\n",
    "        with self.assertRaises(ValueError):\n",
    "            uut = Setting(\"key\", \"abc\")\n",
    "            url(uut)\n",
    "\n",
    "    def test_glob_list(self):\n",
    "        abspath = glob_escape(os.path.abspath(\".\"))\n",
    "        # Need to escape backslashes since we use list conversion\n",
    "        self.uut = Setting(\"key\", \"., \" + abspath.replace(\"\\\\\", \"\\\\\\\\\"),\n",
    "                           origin=os.path.join(\"test (1)\", \"somefile\"))\n",
    "        self.assertEqual(\n",
    "            glob_list(self.uut),\n",
    "            [glob_escape(os.path.abspath(os.path.join(\"test (1)\", \".\"))),\n",
    "             abspath])\n",
    "\n",
    "    def test_typed_list(self):\n",
    "        self.uut = Setting(\"key\", \"1, 2, 3\")\n",
    "        self.assertEqual(typed_list(int)(self.uut),\n",
    "                         [1, 2, 3])\n",
    "\n",
    "        with self.assertRaises(ValueError):\n",
    "            self.uut = Setting(\"key\", \"1, a, 3\")\n",
    "            typed_list(int)(self.uut)\n",
    "\n",
    "    def test_typed_dict(self):\n",
    "        self.uut = Setting(\"key\", \"1, 2: t, 3\")\n",
    "        self.assertEqual(typed_dict(int, str, None)(self.uut),\n",
    "                         {1: None, 2: \"t\", 3: None})\n",
    "\n",
    "        with self.assertRaises(ValueError):\n",
    "            self.uut = Setting(\"key\", \"1, a, 3\")\n",
    "            typed_dict(int, str, \"\")(self.uut)\n",
    "\n",
    "    def test_typed_ordered_dict(self):\n",
    "        self.uut = Setting(\"key\", \"1, 2: t, 3\")\n",
    "        self.assertEqual(typed_ordered_dict(int, str, None)(self.uut),\n",
    "                         OrderedDict([(1, None), (2, \"t\"), (3, None)]))\n",
    "\n",
    "        with self.assertRaises(ValueError):\n",
    "            self.uut = Setting(\"key\", \"1, a, 3\")\n",
    "            typed_ordered_dict(int, str, \"\")(self.uut)\n",
    "\n",
    "    def test_inherited_conversions(self):\n",
    "        self.uut = Setting(\"key\", \" 22\\n\", \".\", True)\n",
    "        self.assertEqual(str(self.uut), \"22\")\n",
    "        self.assertEqual(int(self.uut), 22)\n",
    "        self.assertRaises(ValueError, bool, self.uut)\n"
  ],
  "/home/tushar/coala/tests/settings/__init__.py": [],
  "/home/tushar/coala/tests/test_bears/JavaTestBear.py": [
    "from coalib.bears.LocalBear import LocalBear\n",
    "\n",
    "\n",
    "class JavaTestBear(LocalBear):\n",
    "    LANGUAGES = 'java'\n",
    "\n",
    "    def run(self, filename, file):\n",
    "        \"\"\"\n",
    "        Bear to test that collecting of langugaes works.\n",
    "        \"\"\"\n"
  ],
  "/home/tushar/coala/tests/test_bears/LineCountTestBear.py": [
    "from coalib.bears.LocalBear import LocalBear\n",
    "from coalib.results.Result import Result\n",
    "from coalib.results.RESULT_SEVERITY import RESULT_SEVERITY\n",
    "\n",
    "\n",
    "class LineCountTestBear(LocalBear):\n",
    "\n",
    "    LANGUAGES = 'all'\n",
    "\n",
    "    def run(self, filename, file):\n",
    "        \"\"\"\n",
    "        Counts the lines of each file.\n",
    "        \"\"\"\n",
    "        yield Result.from_values(\n",
    "            origin=self,\n",
    "            message=\"This file has {count} lines.\".format(count=len(file)),\n",
    "            severity=RESULT_SEVERITY.INFO,\n",
    "            file=filename)\n"
  ],
  "/home/tushar/coala/tests/test_bears/LinterBear.py": [
    "from coalib.bearlib.abstractions.Linter import linter\n",
    "\n",
    "\n",
    "@linter(executable='echo',\n",
    "        output_format='regex',\n",
    "        output_regex=r'.+:(?P<line>\\d+):(?P<message>.*)')\n",
    "class EchoBear:\n",
    "    \"\"\"\n",
    "    A simple bear to test that collectors are importing also bears that are\n",
    "    defined in another file *but* have baseclasses in the right file.\n",
    "\n",
    "    (linter will create a new class that inherits from this class.)\n",
    "    \"\"\"\n",
    "\n",
    "    @staticmethod\n",
    "    def create_arguments(filename, file, config_file):\n",
    "        return ()\n"
  ],
  "/home/tushar/coala/tests/test_bears/__init__.py": [],
  "/home/tushar/coala/tests/test_bears/internal_folder/SpaceConsistencyTestBear.py": [
    "from coalib.bearlib.spacing.SpacingHelper import SpacingHelper\n",
    "from coalib.bears.LocalBear import LocalBear\n",
    "from coalib.results.Diff import Diff\n",
    "from coalib.results.Result import Result\n",
    "\n",
    "\n",
    "class SpaceConsistencyTestBear(LocalBear):\n",
    "\n",
    "    def run(self,\n",
    "            filename,\n",
    "            file,\n",
    "            use_spaces: bool,\n",
    "            allow_trailing_whitespace: bool=False,\n",
    "            tab_width: int=SpacingHelper.DEFAULT_TAB_WIDTH,\n",
    "            enforce_newline_at_EOF: bool=True):\n",
    "        '''\n",
    "        Checks the space consistency for each line.\n",
    "\n",
    "        :param use_spaces:                True if spaces are to be used instead\n",
    "                                          of tabs.\n",
    "        :param allow_trailing_whitespace: Whether to allow trailing whitespace\n",
    "                                          or not.\n",
    "        :param tab_width:                 Number of spaces representing one\n",
    "                                          tab.\n",
    "        :param enforce_newline_at_EOF:    Whether to enforce a newline at the\n",
    "                                          End Of File.\n",
    "        '''\n",
    "        spacing_helper = SpacingHelper(tab_width)\n",
    "        result_texts = []\n",
    "\n",
    "        for line_number, line in enumerate(file, start=1):\n",
    "            replacement = line\n",
    "\n",
    "            if enforce_newline_at_EOF:\n",
    "                # Since every line contains at the end at least one \\n, only\n",
    "                # the last line could potentially not have one. So we don't\n",
    "                # need to check whether the current line_number is the last\n",
    "                # one.\n",
    "                if replacement[-1] != \"\\n\":\n",
    "                    replacement += \"\\n\"\n",
    "                    result_texts.append(\"No newline at EOF.\")\n",
    "\n",
    "            if not allow_trailing_whitespace:\n",
    "                replacement = replacement.rstrip(\" \\t\\n\") + \"\\n\"\n",
    "                if replacement != line.rstrip(\"\\n\") + \"\\n\":\n",
    "                    result_texts.append(\"Trailing whitespaces.\")\n",
    "\n",
    "            if use_spaces:\n",
    "                pre_replacement = replacement\n",
    "                replacement = spacing_helper.replace_tabs_with_spaces(\n",
    "                    replacement)\n",
    "                if replacement != pre_replacement:\n",
    "                    result_texts.append(\"Tabs used instead of spaces.\")\n",
    "            else:\n",
    "                pre_replacement = replacement\n",
    "                replacement = spacing_helper.replace_spaces_with_tabs(\n",
    "                    replacement)\n",
    "                if replacement != pre_replacement:\n",
    "                    result_texts.append(\"Spaces used instead of tabs.\")\n",
    "\n",
    "            if len(result_texts) > 0:\n",
    "                diff = Diff(file)\n",
    "                diff.change_line(line_number, line, replacement)\n",
    "                inconsistencies = \"\".join(\"\\n- \" + string\n",
    "                                          for string in result_texts)\n",
    "                yield Result.from_values(\n",
    "                    self,\n",
    "                    \"Line contains following spacing inconsistencies:\"\n",
    "                    + inconsistencies,\n",
    "                    diffs={filename: diff},\n",
    "                    file=filename,\n",
    "                    line=line_number)\n",
    "                result_texts = []\n"
  ],
  "/home/tushar/coala/tests/test_bears/internal_folder/__init__.py": []
}
